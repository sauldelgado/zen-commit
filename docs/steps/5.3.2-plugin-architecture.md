# 5.3.2 Plugin Architecture

## Overview
This step implements a plugin architecture that allows external developers to extend the application's functionality. The plugin system will provide a standardized way to add new features, integrate with external services, and customize the application's behavior without modifying the core codebase.

## Dependencies
- Phase 3.3 - Configuration System
- Phase 5.1.2 - User Preferences Interface

## Prerequisites
- Configuration schema definition (3.3.2)
- Per-project settings implementation (3.3.3)
- User preferences interface (5.1.2)

## Implementation Order
1. Define plugin interface and lifecycle
2. Implement plugin registry
3. Create plugin loader mechanism
4. Develop plugin dependency resolution
5. Build plugin configuration system
6. Implement plugin command extension
7. Create plugin hook system

## Development Guidelines
- Use dependency injection for plugin integration
- Implement proper versioning for plugin compatibility
- Provide clear extension points for plugins
- Maintain backward compatibility for plugin APIs
- Support local and npm-installed plugins
- Validate plugins for security and reliability

## Detailed Tasks

### 1. Test File Creation
Create a test file at `src/__tests__/services/PluginService.test.ts`:

```typescript
import { PluginService } from '../../services/PluginService';
import { ConfigService } from '../../services/ConfigService';
import { UserPreferencesService } from '../../services/UserPreferencesService';
import { 
  Plugin, 
  PluginMetadata, 
  PluginLifecycle,
  PluginType
} from '../../types/Plugin';
import fs from 'fs';
import path from 'path';

jest.mock('../../services/ConfigService');
jest.mock('../../services/UserPreferencesService');
jest.mock('fs');
jest.mock('path');

describe('PluginService', () => {
  let pluginService: PluginService;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockUserPreferencesService: jest.Mocked<UserPreferencesService>;
  
  beforeEach(() => {
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    mockUserPreferencesService = new UserPreferencesService(
      mockConfigService
    ) as jest.Mocked<UserPreferencesService>;
    
    pluginService = new PluginService(
      mockConfigService,
      mockUserPreferencesService
    );
    
    // Mock filesystem functions
    (fs.existsSync as jest.Mock).mockReturnValue(true);
    (fs.readFileSync as jest.Mock).mockReturnValue(JSON.stringify({
      name: 'test-plugin',
      version: '1.0.0',
      main: 'index.js'
    }));
    (fs.readdirSync as jest.Mock).mockReturnValue(['test-plugin']);
    
    // Mock path functions
    (path.join as jest.Mock).mockImplementation((...args) => args.join('/'));
    (path.resolve as jest.Mock).mockImplementation((...args) => args.join('/'));
  });
  
  describe('discoverPlugins', () => {
    it('should discover local plugins', async () => {
      // Mock local plugin
      const mockLocalPlugin: Plugin = {
        metadata: {
          id: 'test-plugin',
          name: 'Test Plugin',
          version: '1.0.0',
          description: 'A test plugin',
          author: 'Test Author',
          type: PluginType.LOCAL
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Mock plugin loader
      jest.spyOn(pluginService as any, 'loadPlugin').mockResolvedValue(mockLocalPlugin);
      
      // Mock user preferences for plugins
      mockUserPreferencesService.getPlugins.mockResolvedValue([
        { id: 'test-plugin', enabled: true }
      ]);
      
      // Mock plugin directories
      jest.spyOn(pluginService as any, 'getPluginDirectories').mockReturnValue([
        './plugins',
        './node_modules'
      ]);
      
      const discoveredPlugins = await pluginService.discoverPlugins();
      
      expect(discoveredPlugins).toHaveLength(1);
      expect(discoveredPlugins[0].metadata.id).toBe('test-plugin');
      expect((pluginService as any).loadPlugin).toHaveBeenCalled();
    });
    
    it('should not load disabled plugins', async () => {
      // Mock user preferences for plugins
      mockUserPreferencesService.getPlugins.mockResolvedValue([
        { id: 'test-plugin', enabled: false }
      ]);
      
      // Mock plugin directories
      jest.spyOn(pluginService as any, 'getPluginDirectories').mockReturnValue([
        './plugins'
      ]);
      
      const discoveredPlugins = await pluginService.discoverPlugins();
      
      expect(discoveredPlugins).toHaveLength(0);
      expect((pluginService as any).loadPlugin).not.toHaveBeenCalled();
    });
  });
  
  describe('loadPlugin', () => {
    it('should load a plugin from a directory', async () => {
      // Mock plugin module
      const mockPluginModule = {
        metadata: {
          id: 'test-plugin',
          name: 'Test Plugin',
          version: '1.0.0',
          description: 'A test plugin',
          author: 'Test Author'
        },
        initialize: jest.fn(),
        activate: jest.fn(),
        deactivate: jest.fn(),
        hooks: {
          'before-commit': jest.fn()
        },
        commands: [
          {
            name: 'test-command',
            description: 'A test command',
            execute: jest.fn()
          }
        ]
      };
      
      // Mock require function
      jest.spyOn(global, 'require').mockImplementation(() => mockPluginModule);
      
      const pluginDir = './plugins/test-plugin';
      const plugin = await (pluginService as any).loadPlugin(pluginDir, PluginType.LOCAL);
      
      expect(plugin).toBeDefined();
      expect(plugin.metadata.id).toBe('test-plugin');
      expect(plugin.lifecycle.initialize).toBeDefined();
      expect(plugin.hooks['before-commit']).toBeDefined();
      expect(plugin.commands).toHaveLength(1);
    });
    
    it('should validate plugin metadata', async () => {
      // Mock plugin module with invalid metadata
      const mockPluginModule = {
        metadata: {
          // Missing id
          name: 'Test Plugin',
          version: '1.0.0'
        },
        initialize: jest.fn()
      };
      
      // Mock require function
      jest.spyOn(global, 'require').mockImplementation(() => mockPluginModule);
      
      await expect((pluginService as any).loadPlugin('./plugins/invalid-plugin', PluginType.LOCAL))
        .rejects.toThrow('Invalid plugin metadata: missing required fields');
    });
  });
  
  describe('initializePlugins', () => {
    it('should initialize loaded plugins', async () => {
      // Mock loaded plugins
      const mockPlugin1: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL
        },
        lifecycle: {
          initialize: jest.fn().mockResolvedValue(undefined),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      const mockPlugin2: Plugin = {
        metadata: {
          id: 'plugin2',
          name: 'Plugin 2',
          version: '1.0.0',
          description: 'Plugin 2',
          author: 'Author',
          type: PluginType.NPM
        },
        lifecycle: {
          initialize: jest.fn().mockResolvedValue(undefined),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin1, mockPlugin2];
      
      await pluginService.initializePlugins();
      
      expect(mockPlugin1.lifecycle.initialize).toHaveBeenCalled();
      expect(mockPlugin2.lifecycle.initialize).toHaveBeenCalled();
    });
    
    it('should handle plugin initialization errors', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'error-plugin',
          name: 'Error Plugin',
          version: '1.0.0',
          description: 'Error Plugin',
          author: 'Author',
          type: PluginType.LOCAL
        },
        lifecycle: {
          initialize: jest.fn().mockRejectedValue(new Error('Initialization error')),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      // Mock console.error
      jest.spyOn(console, 'error').mockImplementation(() => {});
      
      await pluginService.initializePlugins();
      
      expect(mockPlugin.lifecycle.initialize).toHaveBeenCalled();
      expect(console.error).toHaveBeenCalledWith(
        expect.stringContaining('Failed to initialize plugin'),
        expect.any(Error)
      );
    });
  });
  
  describe('activatePlugins', () => {
    it('should activate initialized plugins', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn().mockResolvedValue(undefined),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      await pluginService.activatePlugins();
      
      expect(mockPlugin.lifecycle.activate).toHaveBeenCalled();
      expect(mockPlugin.metadata.active).toBe(true);
    });
  });
  
  describe('deactivatePlugins', () => {
    it('should deactivate active plugins', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn().mockResolvedValue(undefined)
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      await pluginService.deactivatePlugins();
      
      expect(mockPlugin.lifecycle.deactivate).toHaveBeenCalled();
      expect(mockPlugin.metadata.active).toBe(false);
    });
  });
  
  describe('executeHook', () => {
    it('should execute hook handlers for active plugins', async () => {
      // Mock loaded plugins
      const mockPlugin1: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {
          'before-commit': jest.fn().mockResolvedValue({ message: 'Modified' })
        },
        commands: []
      };
      
      const mockPlugin2: Plugin = {
        metadata: {
          id: 'plugin2',
          name: 'Plugin 2',
          version: '1.0.0',
          description: 'Plugin 2',
          author: 'Author',
          type: PluginType.NPM,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {
          'before-commit': jest.fn().mockResolvedValue(null)
        },
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin1, mockPlugin2];
      
      const result = await pluginService.executeHook('before-commit', { message: 'Original' });
      
      expect(mockPlugin1.hooks['before-commit']).toHaveBeenCalledWith({ message: 'Original' });
      expect(mockPlugin2.hooks['before-commit']).toHaveBeenCalledWith({ message: 'Modified' });
      expect(result).toEqual({ message: 'Modified' });
    });
    
    it('should skip inactive plugins when executing hooks', async () => {
      // Mock loaded plugins
      const mockPlugin1: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {
          'before-commit': jest.fn().mockResolvedValue({ message: 'Modified' })
        },
        commands: []
      };
      
      const mockPlugin2: Plugin = {
        metadata: {
          id: 'plugin2',
          name: 'Plugin 2',
          version: '1.0.0',
          description: 'Plugin 2',
          author: 'Author',
          type: PluginType.NPM,
          initialized: true,
          active: false // Inactive plugin
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {
          'before-commit': jest.fn().mockResolvedValue(null)
        },
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin1, mockPlugin2];
      
      const result = await pluginService.executeHook('before-commit', { message: 'Original' });
      
      expect(mockPlugin1.hooks['before-commit']).toHaveBeenCalled();
      expect(mockPlugin2.hooks['before-commit']).not.toHaveBeenCalled();
      expect(result).toEqual({ message: 'Modified' });
    });
  });
  
  describe('getPluginCommands', () => {
    it('should return commands from active plugins', () => {
      // Mock loaded plugins
      const mockPlugin1: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: [
          {
            name: 'command1',
            description: 'Command 1',
            execute: jest.fn()
          }
        ]
      };
      
      const mockPlugin2: Plugin = {
        metadata: {
          id: 'plugin2',
          name: 'Plugin 2',
          version: '1.0.0',
          description: 'Plugin 2',
          author: 'Author',
          type: PluginType.NPM,
          initialized: true,
          active: false // Inactive plugin
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: [
          {
            name: 'command2',
            description: 'Command 2',
            execute: jest.fn()
          }
        ]
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin1, mockPlugin2];
      
      const commands = pluginService.getPluginCommands();
      
      expect(commands).toHaveLength(1);
      expect(commands[0].name).toBe('command1');
    });
  });
  
  describe('getPlugin', () => {
    it('should return the plugin with the specified ID', () => {
      // Mock loaded plugins
      const mockPlugin1: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      const mockPlugin2: Plugin = {
        metadata: {
          id: 'plugin2',
          name: 'Plugin 2',
          version: '1.0.0',
          description: 'Plugin 2',
          author: 'Author',
          type: PluginType.NPM
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin1, mockPlugin2];
      
      const plugin = pluginService.getPlugin('plugin2');
      
      expect(plugin).toBeDefined();
      expect(plugin?.metadata.id).toBe('plugin2');
    });
    
    it('should return undefined if the plugin is not found', () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      const plugin = pluginService.getPlugin('non-existent');
      
      expect(plugin).toBeUndefined();
    });
  });
  
  describe('enablePlugin', () => {
    it('should enable a disabled plugin', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: false
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn().mockResolvedValue(undefined),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      await pluginService.enablePlugin('plugin1');
      
      expect(mockPlugin.lifecycle.activate).toHaveBeenCalled();
      expect(mockPlugin.metadata.active).toBe(true);
      expect(mockUserPreferencesService.updatePluginStatus).toHaveBeenCalledWith('plugin1', true);
    });
    
    it('should do nothing if the plugin is already enabled', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn()
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      await pluginService.enablePlugin('plugin1');
      
      expect(mockPlugin.lifecycle.activate).not.toHaveBeenCalled();
      expect(mockUserPreferencesService.updatePluginStatus).not.toHaveBeenCalled();
    });
  });
  
  describe('disablePlugin', () => {
    it('should disable an enabled plugin', async () => {
      // Mock loaded plugins
      const mockPlugin: Plugin = {
        metadata: {
          id: 'plugin1',
          name: 'Plugin 1',
          version: '1.0.0',
          description: 'Plugin 1',
          author: 'Author',
          type: PluginType.LOCAL,
          initialized: true,
          active: true
        },
        lifecycle: {
          initialize: jest.fn(),
          activate: jest.fn(),
          deactivate: jest.fn().mockResolvedValue(undefined)
        },
        hooks: {},
        commands: []
      };
      
      // Set loaded plugins
      (pluginService as any).loadedPlugins = [mockPlugin];
      
      await pluginService.disablePlugin('plugin1');
      
      expect(mockPlugin.lifecycle.deactivate).toHaveBeenCalled();
      expect(mockPlugin.metadata.active).toBe(false);
      expect(mockUserPreferencesService.updatePluginStatus).toHaveBeenCalledWith('plugin1', false);
    });
  });
});
```

### 2. Plugin Types
Create a file for plugin types at `src/types/Plugin.ts`:

```typescript
import { Command } from './Command';

/**
 * Plugin type enum
 */
export enum PluginType {
  LOCAL = 'local',
  NPM = 'npm'
}

/**
 * Hook types supported by the application
 */
export enum HookType {
  BEFORE_COMMIT = 'before-commit',
  AFTER_COMMIT = 'after-commit',
  BEFORE_TEMPLATE_SELECTION = 'before-template-selection',
  AFTER_TEMPLATE_SELECTION = 'after-template-selection',
  BEFORE_MESSAGE_VALIDATION = 'before-message-validation',
  AFTER_MESSAGE_VALIDATION = 'after-message-validation'
}

/**
 * Plugin metadata
 */
export interface PluginMetadata {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  type: PluginType;
  dependencies?: string[];
  initialized?: boolean;
  active?: boolean;
}

/**
 * Plugin lifecycle methods
 */
export interface PluginLifecycle {
  initialize: (context: PluginContext) => Promise<void>;
  activate: () => Promise<void>;
  deactivate: () => Promise<void>;
}

/**
 * Plugin context provided to plugins during initialization
 */
export interface PluginContext {
  services: any;
  config: any;
  hooks: {
    register: (type: HookType, handler: HookHandler) => void;
  };
  commands: {
    register: (command: Command) => void;
  };
  logger: {
    debug: (message: string, ...args: any[]) => void;
    info: (message: string, ...args: any[]) => void;
    warn: (message: string, ...args: any[]) => void;
    error: (message: string, ...args: any[]) => void;
  };
}

/**
 * Hook handler function type
 */
export type HookHandler = (data: any) => Promise<any>;

/**
 * Map of hook types to handler functions
 */
export type HookHandlers = Partial<Record<HookType, HookHandler>>;

/**
 * Plugin interface
 */
export interface Plugin {
  metadata: PluginMetadata;
  lifecycle: PluginLifecycle;
  hooks: HookHandlers;
  commands: Command[];
}

/**
 * Plugin user preference
 */
export interface PluginPreference {
  id: string;
  enabled: boolean;
}
```

### 3. Plugin Service Implementation
Create a service file at `src/services/PluginService.ts`:

```typescript
import { ConfigService } from './ConfigService';
import { UserPreferencesService } from './UserPreferencesService';
import { 
  Plugin, 
  PluginMetadata, 
  PluginLifecycle,
  PluginContext,
  PluginType,
  HookType,
  HookHandler,
  HookHandlers
} from '../types/Plugin';
import { Command } from '../types/Command';
import fs from 'fs';
import path from 'path';

/**
 * Service for managing plugins
 */
export class PluginService {
  private loadedPlugins: Plugin[] = [];
  private pluginContext: PluginContext;
  
  constructor(
    private configService: ConfigService,
    private userPreferencesService: UserPreferencesService
  ) {
    // Create plugin context
    this.pluginContext = {
      services: {
        configService,
        userPreferencesService
      },
      config: {},
      hooks: {
        register: (type: HookType, handler: HookHandler) => {
          // Hook registration is handled during plugin loading
        }
      },
      commands: {
        register: (command: Command) => {
          // Command registration is handled during plugin loading
        }
      },
      logger: {
        debug: (message: string, ...args: any[]) => console.debug(`[Plugin] ${message}`, ...args),
        info: (message: string, ...args: any[]) => console.info(`[Plugin] ${message}`, ...args),
        warn: (message: string, ...args: any[]) => console.warn(`[Plugin] ${message}`, ...args),
        error: (message: string, ...args: any[]) => console.error(`[Plugin] ${message}`, ...args)
      }
    };
  }
  
  /**
   * Discover and load available plugins
   */
  public async discoverPlugins(): Promise<Plugin[]> {
    // Get plugin preferences
    const pluginPreferences = await this.userPreferencesService.getPlugins();
    
    // Get plugin directories
    const pluginDirs = this.getPluginDirectories();
    
    // Discover local plugins
    const localPlugins = await this.discoverLocalPlugins(pluginDirs[0], pluginPreferences);
    
    // Discover npm plugins
    const npmPlugins = await this.discoverNpmPlugins(pluginDirs[1], pluginPreferences);
    
    // Combine and sort plugins
    this.loadedPlugins = [...localPlugins, ...npmPlugins]
      .sort((a, b) => a.metadata.name.localeCompare(b.metadata.name));
    
    return this.loadedPlugins;
  }
  
  /**
   * Initialize all loaded plugins
   */
  public async initializePlugins(): Promise<void> {
    for (const plugin of this.loadedPlugins) {
      try {
        await plugin.lifecycle.initialize(this.pluginContext);
        plugin.metadata.initialized = true;
      } catch (error) {
        console.error(`Failed to initialize plugin ${plugin.metadata.name}:`, error);
      }
    }
  }
  
  /**
   * Activate all initialized plugins
   */
  public async activatePlugins(): Promise<void> {
    for (const plugin of this.loadedPlugins) {
      if (plugin.metadata.initialized && !plugin.metadata.active) {
        try {
          await plugin.lifecycle.activate();
          plugin.metadata.active = true;
        } catch (error) {
          console.error(`Failed to activate plugin ${plugin.metadata.name}:`, error);
        }
      }
    }
  }
  
  /**
   * Deactivate all active plugins
   */
  public async deactivatePlugins(): Promise<void> {
    for (const plugin of this.loadedPlugins) {
      if (plugin.metadata.active) {
        try {
          await plugin.lifecycle.deactivate();
          plugin.metadata.active = false;
        } catch (error) {
          console.error(`Failed to deactivate plugin ${plugin.metadata.name}:`, error);
        }
      }
    }
  }
  
  /**
   * Execute a hook across all active plugins
   */
  public async executeHook(type: HookType, data: any): Promise<any> {
    let result = data;
    
    for (const plugin of this.loadedPlugins) {
      if (plugin.metadata.active && plugin.hooks[type]) {
        try {
          const hookResult = await plugin.hooks[type]!(result);
          
          // Only update the result if the hook returned a non-null value
          if (hookResult !== null && hookResult !== undefined) {
            result = hookResult;
          }
        } catch (error) {
          console.error(`Error executing hook ${type} in plugin ${plugin.metadata.name}:`, error);
        }
      }
    }
    
    return result;
  }
  
  /**
   * Get all commands provided by active plugins
   */
  public getPluginCommands(): Command[] {
    const commands: Command[] = [];
    
    for (const plugin of this.loadedPlugins) {
      if (plugin.metadata.active) {
        commands.push(...plugin.commands);
      }
    }
    
    return commands;
  }
  
  /**
   * Get all loaded plugins
   */
  public getPlugins(): Plugin[] {
    return this.loadedPlugins;
  }
  
  /**
   * Get a specific plugin by ID
   */
  public getPlugin(id: string): Plugin | undefined {
    return this.loadedPlugins.find(plugin => plugin.metadata.id === id);
  }
  
  /**
   * Enable a plugin
   */
  public async enablePlugin(id: string): Promise<boolean> {
    const plugin = this.getPlugin(id);
    
    if (!plugin) {
      return false;
    }
    
    if (plugin.metadata.active) {
      return true; // Already enabled
    }
    
    try {
      // Initialize if not already
      if (!plugin.metadata.initialized) {
        await plugin.lifecycle.initialize(this.pluginContext);
        plugin.metadata.initialized = true;
      }
      
      // Activate
      await plugin.lifecycle.activate();
      plugin.metadata.active = true;
      
      // Update preferences
      await this.userPreferencesService.updatePluginStatus(id, true);
      
      return true;
    } catch (error) {
      console.error(`Failed to enable plugin ${id}:`, error);
      return false;
    }
  }
  
  /**
   * Disable a plugin
   */
  public async disablePlugin(id: string): Promise<boolean> {
    const plugin = this.getPlugin(id);
    
    if (!plugin || !plugin.metadata.active) {
      return false;
    }
    
    try {
      await plugin.lifecycle.deactivate();
      plugin.metadata.active = false;
      
      // Update preferences
      await this.userPreferencesService.updatePluginStatus(id, false);
      
      return true;
    } catch (error) {
      console.error(`Failed to disable plugin ${id}:`, error);
      return false;
    }
  }
  
  /**
   * Install a plugin from npm
   */
  public async installPlugin(packageName: string): Promise<boolean> {
    try {
      // Execute npm install
      const { execSync } = require('child_process');
      execSync(`npm install ${packageName} --save`);
      
      // Refresh plugins
      await this.discoverPlugins();
      
      // Get the installed plugin
      const plugin = this.loadedPlugins.find(p => p.metadata.id === packageName);
      
      if (!plugin) {
        return false;
      }
      
      // Enable the plugin
      await this.enablePlugin(plugin.metadata.id);
      
      return true;
    } catch (error) {
      console.error(`Failed to install plugin ${packageName}:`, error);
      return false;
    }
  }
  
  /**
   * Uninstall a plugin
   */
  public async uninstallPlugin(id: string): Promise<boolean> {
    const plugin = this.getPlugin(id);
    
    if (!plugin) {
      return false;
    }
    
    try {
      // Disable the plugin
      if (plugin.metadata.active) {
        await this.disablePlugin(id);
      }
      
      // Remove from loaded plugins
      this.loadedPlugins = this.loadedPlugins.filter(p => p.metadata.id !== id);
      
      // If npm plugin, uninstall from npm
      if (plugin.metadata.type === PluginType.NPM) {
        const { execSync } = require('child_process');
        execSync(`npm uninstall ${id}`);
      }
      
      // Update preferences
      await this.userPreferencesService.removePlugin(id);
      
      return true;
    } catch (error) {
      console.error(`Failed to uninstall plugin ${id}:`, error);
      return false;
    }
  }
  
  /**
   * Get plugin directories (local and npm)
   */
  private getPluginDirectories(): string[] {
    const rootDir = process.cwd();
    const localPluginsDir = path.join(rootDir, 'plugins');
    const nodeModulesDir = path.join(rootDir, 'node_modules');
    
    return [localPluginsDir, nodeModulesDir];
  }
  
  /**
   * Discover local plugins
   */
  private async discoverLocalPlugins(
    pluginsDir: string,
    preferences: Array<{ id: string; enabled: boolean }>
  ): Promise<Plugin[]> {
    const plugins: Plugin[] = [];
    
    if (!fs.existsSync(pluginsDir)) {
      return plugins;
    }
    
    const pluginFolders = fs.readdirSync(pluginsDir)
      .filter(folder => {
        const pluginDir = path.join(pluginsDir, folder);
        return fs.statSync(pluginDir).isDirectory();
      });
    
    for (const folder of pluginFolders) {
      const pluginDir = path.join(pluginsDir, folder);
      
      // Check if a plugin.json file exists
      const pluginJsonPath = path.join(pluginDir, 'plugin.json');
      
      if (!fs.existsSync(pluginJsonPath)) {
        continue;
      }
      
      // Read plugin.json
      const pluginJson = JSON.parse(fs.readFileSync(pluginJsonPath, 'utf-8'));
      const pluginId = pluginJson.id || folder;
      
      // Check if plugin is enabled
      const preference = preferences.find(p => p.id === pluginId);
      const enabled = preference ? preference.enabled : true; // Enable by default
      
      if (!enabled) {
        continue; // Skip disabled plugins
      }
      
      try {
        const plugin = await this.loadPlugin(pluginDir, PluginType.LOCAL);
        plugins.push(plugin);
      } catch (error) {
        console.error(`Failed to load plugin from ${pluginDir}:`, error);
      }
    }
    
    return plugins;
  }
  
  /**
   * Discover npm plugins
   */
  private async discoverNpmPlugins(
    nodeModulesDir: string,
    preferences: Array<{ id: string; enabled: boolean }>
  ): Promise<Plugin[]> {
    const plugins: Plugin[] = [];
    
    if (!fs.existsSync(nodeModulesDir)) {
      return plugins;
    }
    
    // Get package.json dependencies
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      return plugins;
    }
    
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    const dependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };
    
    // Find plugins
    for (const [packageName, version] of Object.entries(dependencies)) {
      // Check if package name starts with 'zencommit-plugin-'
      if (!packageName.startsWith('zencommit-plugin-')) {
        continue;
      }
      
      const pluginDir = path.join(nodeModulesDir, packageName);
      
      if (!fs.existsSync(pluginDir)) {
        continue;
      }
      
      // Check if plugin is enabled
      const preference = preferences.find(p => p.id === packageName);
      const enabled = preference ? preference.enabled : true; // Enable by default
      
      if (!enabled) {
        continue; // Skip disabled plugins
      }
      
      try {
        const plugin = await this.loadPlugin(pluginDir, PluginType.NPM);
        plugins.push(plugin);
      } catch (error) {
        console.error(`Failed to load plugin from ${pluginDir}:`, error);
      }
    }
    
    return plugins;
  }
  
  /**
   * Load a plugin from a directory
   */
  private async loadPlugin(pluginDir: string, type: PluginType): Promise<Plugin> {
    // Get package.json
    const packageJsonPath = path.join(pluginDir, 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error(`package.json not found in ${pluginDir}`);
    }
    
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    
    // Get main file
    const mainFile = packageJson.main || 'index.js';
    const mainFilePath = path.resolve(pluginDir, mainFile);
    
    if (!fs.existsSync(mainFilePath)) {
      throw new Error(`Main file ${mainFile} not found in ${pluginDir}`);
    }
    
    // Load the plugin module
    const pluginModule = require(mainFilePath);
    
    // Validate plugin module
    this.validatePluginModule(pluginModule);
    
    // Create plugin metadata
    const metadata: PluginMetadata = {
      id: pluginModule.metadata.id,
      name: pluginModule.metadata.name,
      version: pluginModule.metadata.version,
      description: pluginModule.metadata.description,
      author: pluginModule.metadata.author,
      type,
      dependencies: pluginModule.metadata.dependencies || [],
      initialized: false,
      active: false
    };
    
    // Create plugin lifecycle
    const lifecycle: PluginLifecycle = {
      initialize: pluginModule.initialize || (async () => {}),
      activate: pluginModule.activate || (async () => {}),
      deactivate: pluginModule.deactivate || (async () => {})
    };
    
    // Create plugin hooks
    const hooks: HookHandlers = pluginModule.hooks || {};
    
    // Create plugin commands
    const commands: Command[] = pluginModule.commands || [];
    
    // Return the plugin
    return {
      metadata,
      lifecycle,
      hooks,
      commands
    };
  }
  
  /**
   * Validate plugin module
   */
  private validatePluginModule(pluginModule: any): void {
    if (!pluginModule) {
      throw new Error('Plugin module is null or undefined');
    }
    
    if (!pluginModule.metadata) {
      throw new Error('Plugin metadata is missing');
    }
    
    const { metadata } = pluginModule;
    
    if (!metadata.id || !metadata.name || !metadata.version || !metadata.description || !metadata.author) {
      throw new Error('Invalid plugin metadata: missing required fields');
    }
  }
}
```

### 4. Update UserPreferencesService
Update `src/services/UserPreferencesService.ts` to include plugin-related methods:

```typescript
/**
 * Get installed plugins
 */
public async getPlugins(): Promise<Array<{ id: string; enabled: boolean }>> {
  const preferences = await this.getPreferences();
  return preferences.plugins || [];
}

/**
 * Update plugin status
 */
public async updatePluginStatus(id: string, enabled: boolean): Promise<void> {
  const preferences = await this.getPreferences();
  
  if (!preferences.plugins) {
    preferences.plugins = [];
  }
  
  const pluginIndex = preferences.plugins.findIndex(p => p.id === id);
  
  if (pluginIndex >= 0) {
    preferences.plugins[pluginIndex].enabled = enabled;
  } else {
    preferences.plugins.push({ id, enabled });
  }
  
  await this.savePreferences(preferences);
}

/**
 * Remove plugin
 */
public async removePlugin(id: string): Promise<void> {
  const preferences = await this.getPreferences();
  
  if (!preferences.plugins) {
    return;
  }
  
  preferences.plugins = preferences.plugins.filter(p => p.id !== id);
  
  await this.savePreferences(preferences);
}
```

### 5. Create UI Component for Plugin Management
Create a UI component file at `src/components/plugins/PluginManager.tsx`:

```typescript
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import { usePluginService } from '../../hooks/usePluginService';
import { Plugin, PluginType } from '../../types/Plugin';
import { Spinner } from '../feedback/Spinner';
import TextInput from '../inputs/TextInput';
import SelectInput from '../inputs/SelectInput';

interface PluginManagerProps {
  onClose: () => void;
}

type ViewMode = 'list' | 'detail' | 'install';

/**
 * Component for managing plugins
 */
export const PluginManager: React.FC<PluginManagerProps> = ({ onClose }) => {
  const pluginService = usePluginService();
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [plugins, setPlugins] = useState<Plugin[]>([]);
  const [selectedPluginIndex, setSelectedPluginIndex] = useState(0);
  const [selectedPlugin, setSelectedPlugin] = useState<Plugin | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [packageName, setPackageName] = useState('');
  const [installProgress, setInstallProgress] = useState<string | null>(null);
  
  // Load plugins
  const loadPlugins = async () => {
    try {
      setLoading(true);
      const loadedPlugins = await pluginService.discoverPlugins();
      setPlugins(loadedPlugins);
      
      if (loadedPlugins.length > 0 && selectedPluginIndex < loadedPlugins.length) {
        setSelectedPlugin(loadedPlugins[selectedPluginIndex]);
      }
      
      setError(null);
    } catch (err) {
      setError(`Failed to load plugins: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Initial load
  useEffect(() => {
    loadPlugins();
  }, []);
  
  // Handle plugin enable/disable
  const togglePluginStatus = async (plugin: Plugin) => {
    try {
      if (plugin.metadata.active) {
        await pluginService.disablePlugin(plugin.metadata.id);
      } else {
        await pluginService.enablePlugin(plugin.metadata.id);
      }
      
      // Refresh plugins
      await loadPlugins();
    } catch (err) {
      setError(`Failed to ${plugin.metadata.active ? 'disable' : 'enable'} plugin: ${err.message}`);
    }
  };
  
  // Handle plugin uninstall
  const uninstallPlugin = async (plugin: Plugin) => {
    try {
      const confirmed = await confirm(`Are you sure you want to uninstall ${plugin.metadata.name}?`);
      
      if (!confirmed) {
        return;
      }
      
      await pluginService.uninstallPlugin(plugin.metadata.id);
      
      // Refresh plugins
      await loadPlugins();
      setViewMode('list');
    } catch (err) {
      setError(`Failed to uninstall plugin: ${err.message}`);
    }
  };
  
  // Handle plugin installation
  const installPlugin = async () => {
    try {
      setInstallProgress(`Installing ${packageName}...`);
      
      const success = await pluginService.installPlugin(packageName);
      
      if (success) {
        setInstallProgress(`Successfully installed ${packageName}`);
        
        // Refresh plugins
        await loadPlugins();
        setViewMode('list');
      } else {
        setInstallProgress(`Failed to install ${packageName}`);
      }
    } catch (err) {
      setInstallProgress(`Failed to install plugin: ${err.message}`);
    } finally {
      setTimeout(() => {
        setInstallProgress(null);
      }, 3000);
    }
  };
  
  // Confirm dialog
  const confirm = (message: string): Promise<boolean> => {
    return new Promise((resolve) => {
      const confirmDialog = (
        <Box flexDirection="column" padding={1}>
          <Text>{message}</Text>
          <Text>Press Y to confirm, N to cancel</Text>
        </Box>
      );
      
      // TODO: Implement confirmation dialog
      resolve(true);
    });
  };
  
  // Handle user input
  useInput((input, key) => {
    if (viewMode === 'list') {
      if (key.escape || input === 'q') {
        onClose();
        return;
      }
      
      if (key.upArrow || input === 'k') {
        setSelectedPluginIndex(prev => (prev > 0 ? prev - 1 : prev));
        if (plugins[selectedPluginIndex - 1]) {
          setSelectedPlugin(plugins[selectedPluginIndex - 1]);
        }
      }
      
      if (key.downArrow || input === 'j') {
        setSelectedPluginIndex(prev => 
          (prev < plugins.length - 1 ? prev + 1 : prev)
        );
        if (plugins[selectedPluginIndex + 1]) {
          setSelectedPlugin(plugins[selectedPluginIndex + 1]);
        }
      }
      
      if (key.return && plugins.length > 0) {
        setSelectedPlugin(plugins[selectedPluginIndex]);
        setViewMode('detail');
      }
      
      if (input === 'i') {
        setViewMode('install');
      }
      
      if (input === 'r') {
        loadPlugins();
      }
    } else if (viewMode === 'detail') {
      if (key.escape) {
        setViewMode('list');
      }
      
      if (selectedPlugin && input === 't') {
        togglePluginStatus(selectedPlugin);
      }
      
      if (selectedPlugin && input === 'u') {
        uninstallPlugin(selectedPlugin);
      }
    } else if (viewMode === 'install') {
      if (key.escape) {
        setViewMode('list');
      }
    }
  });
  
  if (loading && plugins.length === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Loading plugins..." />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color="red">{error}</Text>
        <Text>Press any key to retry</Text>
      </Box>
    );
  }
  
  // Plugin List View
  if (viewMode === 'list') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Plugin Manager</Text>
          <Text dimColor> - Press I to install new plugin, R to refresh, Q to quit</Text>
        </Box>
        
        {plugins.length === 0 ? (
          <Text>No plugins installed.</Text>
        ) : (
          <>
            {plugins.map((plugin, index) => (
              <Box 
                key={plugin.metadata.id} 
                flexDirection="row" 
                padding={1}
                backgroundColor={index === selectedPluginIndex ? 'blue' : undefined}
              >
                <Box width={3}>
                  <Text>{plugin.metadata.active ? '✓' : '☐'}</Text>
                </Box>
                <Box width={20}>
                  <Text>{plugin.metadata.name}</Text>
                </Box>
                <Box width={10}>
                  <Text dimColor>v{plugin.metadata.version}</Text>
                </Box>
                <Box>
                  <Text dimColor>{plugin.metadata.description}</Text>
                </Box>
              </Box>
            ))}
          </>
        )}
        
        {installProgress && (
          <Box marginTop={1}>
            <Text color="yellow">{installProgress}</Text>
          </Box>
        )}
      </Box>
    );
  }
  
  // Plugin Detail View
  if (viewMode === 'detail' && selectedPlugin) {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>{selectedPlugin.metadata.name} v{selectedPlugin.metadata.version}</Text>
          <Text dimColor> - Press ESC to go back, T to toggle status, U to uninstall</Text>
        </Box>
        
        <Box marginY={1}>
          <Text>{selectedPlugin.metadata.description}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Author: </Text>
          <Text>{selectedPlugin.metadata.author}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>ID: </Text>
          <Text>{selectedPlugin.metadata.id}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Type: </Text>
          <Text>{selectedPlugin.metadata.type === PluginType.LOCAL ? 'Local' : 'NPM'}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Status: </Text>
          <Text color={selectedPlugin.metadata.active ? 'green' : 'yellow'}>
            {selectedPlugin.metadata.active ? 'Active' : 'Inactive'}
          </Text>
        </Box>
        
        {selectedPlugin.commands.length > 0 && (
          <Box marginY={1} flexDirection="column">
            <Text bold>Commands:</Text>
            {selectedPlugin.commands.map((command, index) => (
              <Box key={index} marginLeft={2} marginTop={1}>
                <Text>{command.name} - {command.description}</Text>
              </Box>
            ))}
          </Box>
        )}
        
        {Object.keys(selectedPlugin.hooks).length > 0 && (
          <Box marginY={1} flexDirection="column">
            <Text bold>Hooks:</Text>
            {Object.keys(selectedPlugin.hooks).map((hook, index) => (
              <Box key={index} marginLeft={2} marginTop={1}>
                <Text>{hook}</Text>
              </Box>
            ))}
          </Box>
        )}
      </Box>
    );
  }
  
  // Plugin Install View
  if (viewMode === 'install') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Install Plugin</Text>
          <Text dimColor> - Press ESC to cancel</Text>
        </Box>
        
        <Box marginY={1}>
          <Text>Enter the plugin package name:</Text>
        </Box>
        
        <TextInput 
          value={packageName} 
          onChange={setPackageName} 
          placeholder="zencommit-plugin-name"
          onSubmit={installPlugin}
        />
        
        <Box marginTop={2}>
          <Text>Press Enter to install</Text>
        </Box>
        
        {installProgress && (
          <Box marginTop={1}>
            <Text color="yellow">{installProgress}</Text>
          </Box>
        )}
      </Box>
    );
  }
  
  return null;
};
```

### 6. Create Plugin Hook
Create a custom hook at `src/hooks/usePluginService.ts`:

```typescript
import { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import { PluginService } from '../services/PluginService';

/**
 * Hook to access the PluginService instance
 */
export function usePluginService(): PluginService {
  const { services } = useContext(AppContext);
  
  if (!services.pluginService) {
    throw new Error('PluginService not available in context');
  }
  
  return services.pluginService;
}
```

### 7. Create Plugin Command
Create a command file at `src/commands/plugin.ts`:

```typescript
import { Command } from '../types/Command';
import { render } from 'ink';
import React from 'react';
import { PluginManager } from '../components/plugins/PluginManager';
import { createAppContext } from '../context/createAppContext';

/**
 * Command for managing plugins
 */
export const pluginCommand: Command = {
  name: 'plugin',
  description: 'Manage plugins',
  options: [
    {
      name: 'list',
      description: 'List installed plugins',
      alias: 'l',
      type: 'boolean'
    },
    {
      name: 'install',
      description: 'Install a plugin',
      alias: 'i',
      type: 'string'
    },
    {
      name: 'uninstall',
      description: 'Uninstall a plugin',
      alias: 'u',
      type: 'string'
    },
    {
      name: 'enable',
      description: 'Enable a plugin',
      alias: 'e',
      type: 'string'
    },
    {
      name: 'disable',
      description: 'Disable a plugin',
      alias: 'd',
      type: 'string'
    }
  ],
  
  async execute(args, options): Promise<void> {
    const context = await createAppContext();
    const { pluginService } = context.services;
    
    // Install plugin
    if (options.install) {
      console.log(`Installing plugin: ${options.install}`);
      const success = await pluginService.installPlugin(options.install);
      
      if (success) {
        console.log(`✅ Plugin ${options.install} installed successfully`);
      } else {
        console.error(`❌ Failed to install plugin ${options.install}`);
      }
      return;
    }
    
    // Uninstall plugin
    if (options.uninstall) {
      console.log(`Uninstalling plugin: ${options.uninstall}`);
      const success = await pluginService.uninstallPlugin(options.uninstall);
      
      if (success) {
        console.log(`✅ Plugin ${options.uninstall} uninstalled successfully`);
      } else {
        console.error(`❌ Failed to uninstall plugin ${options.uninstall}`);
      }
      return;
    }
    
    // Enable plugin
    if (options.enable) {
      console.log(`Enabling plugin: ${options.enable}`);
      const success = await pluginService.enablePlugin(options.enable);
      
      if (success) {
        console.log(`✅ Plugin ${options.enable} enabled successfully`);
      } else {
        console.error(`❌ Failed to enable plugin ${options.enable}`);
      }
      return;
    }
    
    // Disable plugin
    if (options.disable) {
      console.log(`Disabling plugin: ${options.disable}`);
      const success = await pluginService.disablePlugin(options.disable);
      
      if (success) {
        console.log(`✅ Plugin ${options.disable} disabled successfully`);
      } else {
        console.error(`❌ Failed to disable plugin ${options.disable}`);
      }
      return;
    }
    
    // List plugins
    if (options.list) {
      await pluginService.discoverPlugins();
      const plugins = pluginService.getPlugins();
      
      console.log('Installed plugins:');
      
      if (plugins.length === 0) {
        console.log('No plugins installed');
      } else {
        plugins.forEach(plugin => {
          console.log(`- ${plugin.metadata.name} v${plugin.metadata.version} [${plugin.metadata.active ? 'Active' : 'Inactive'}]`);
          console.log(`  ${plugin.metadata.description}`);
          console.log(`  ID: ${plugin.metadata.id}, Type: ${plugin.metadata.type}`);
          console.log();
        });
      }
      return;
    }
    
    // Default: show plugin manager
    const { waitUntilExit } = render(
      React.createElement(
        PluginManager, 
        { onClose: () => process.exit(0) }
      )
    );
    
    await waitUntilExit();
  }
};
```

### 8. Update Core Exports
Update `src/index.ts` to include the plugin service:

```typescript
// Add to imports
import { PluginService } from './services/PluginService';
import { pluginCommand } from './commands/plugin';

// Add to commandRegistry
commandRegistry.register(pluginCommand);

// Add to service initialization
const pluginService = new PluginService(
  configService,
  userPreferencesService
);

// Add to context
context.services.pluginService = pluginService;

// Initialize and activate plugins
(async () => {
  await pluginService.discoverPlugins();
  await pluginService.initializePlugins();
  await pluginService.activatePlugins();
})();
```

### 9. Update App Context Type
Update `src/context/AppContext.ts`:

```typescript
import { PluginService } from '../services/PluginService';

// Add to Services interface
export interface Services {
  // ... existing services
  pluginService: PluginService;
}
```

### 10. Create Plugin Repository Example
Create an example plugin structure at `plugins/example-plugin/`:

File: `plugins/example-plugin/plugin.json`:
```json
{
  "id": "example-plugin",
  "name": "Example Plugin",
  "version": "1.0.0",
  "description": "An example plugin for demonstration purposes",
  "author": "Your Name"
}
```

File: `plugins/example-plugin/package.json`:
```json
{
  "name": "example-plugin",
  "version": "1.0.0",
  "description": "An example plugin for demonstration purposes",
  "main": "index.js",
  "author": "Your Name",
  "license": "MIT"
}
```

File: `plugins/example-plugin/index.js`:
```javascript
/**
 * Example plugin for Zen Commit
 */

// Plugin metadata
exports.metadata = {
  id: 'example-plugin',
  name: 'Example Plugin',
  version: '1.0.0',
  description: 'An example plugin for demonstration purposes',
  author: 'Your Name'
};

// Initialize plugin
exports.initialize = async (context) => {
  context.logger.info('Example plugin initialized');
};

// Activate plugin
exports.activate = async () => {
  console.log('Example plugin activated');
};

// Deactivate plugin
exports.deactivate = async () => {
  console.log('Example plugin deactivated');
};

// Hook handlers
exports.hooks = {
  'before-commit': async (data) => {
    // Example: Append a signature to the commit message
    if (data && data.message) {
      data.message += '\n\nSigned-off-by: Example Plugin';
      return data;
    }
    return data;
  }
};

// Commands
exports.commands = [
  {
    name: 'example',
    description: 'Example command from the example plugin',
    options: [
      {
        name: 'message',
        description: 'A message to display',
        alias: 'm',
        type: 'string'
      }
    ],
    execute: async (args, options) => {
      const message = options.message || 'Hello from the example plugin!';
      console.log(message);
    }
  }
];
```

### 11. Create Plugin Documentation
Create a documentation file at `docs/plugin-development.md`:

```markdown
# Zen Commit Plugin Development Guide

This guide explains how to create plugins for Zen Commit. Plugins allow you to extend the functionality of Zen Commit with custom commands, hooks, and integrations.

## Plugin Structure

A Zen Commit plugin is a JavaScript module that exports specific objects and functions.

```javascript
// Plugin metadata (required)
exports.metadata = {
  id: 'your-plugin-id',          // Unique identifier
  name: 'Your Plugin Name',      // Display name
  version: '1.0.0',              // Semantic version
  description: 'Description',    // Plugin description
  author: 'Your Name'            // Author name
};

// Lifecycle methods
exports.initialize = async (context) => {
  // Initialize plugin with context
};

exports.activate = async () => {
  // Activate plugin
};

exports.deactivate = async () => {
  // Deactivate plugin
};

// Hook handlers
exports.hooks = {
  'before-commit': async (data) => {
    // Modify commit data
    return data; // Must return modified data
  },
  // Other hooks...
};

// Commands
exports.commands = [
  {
    name: 'your-command',
    description: 'Command description',
    options: [
      {
        name: 'option-name',
        description: 'Option description',
        alias: 'o',
        type: 'string' // or 'boolean', 'number'
      }
    ],
    execute: async (args, options) => {
      // Command implementation
    }
  }
];
```

## Plugin Types

There are two types of plugins:

1. **Local Plugins**: Installed in the `plugins/` directory of your project
2. **NPM Plugins**: Installed via npm as packages with names starting with `zencommit-plugin-`

## Plugin Context

The plugin context is provided to your plugin during initialization and gives access to:

- **services**: Core application services
  - `configService`: Configuration service
  - `userPreferencesService`: User preferences service
  - (Other services may be available)
- **config**: Plugin configuration
- **hooks**: Hook registration
- **commands**: Command registration
- **logger**: Logging utilities

Example usage:

```javascript
exports.initialize = async (context) => {
  // Access services
  const config = await context.services.configService.getConfig();
  
  // Log information
  context.logger.info('Plugin initialized with config:', config);
};
```

## Available Hooks

Hooks allow plugins to modify data or behavior at specific points in the application lifecycle:

- `before-commit`: Called before a commit is created, allows modifying commit data
- `after-commit`: Called after a commit is created
- `before-template-selection`: Called before template selection, allows modifying templates
- `after-template-selection`: Called after template selection
- `before-message-validation`: Called before commit message validation
- `after-message-validation`: Called after commit message validation

Example hook implementation:

```javascript
exports.hooks = {
  'before-commit': async (data) => {
    // Modify commit message
    if (data && data.message) {
      data.message = data.message.trim();
      
      // Add issue reference if missing
      if (!data.message.includes('#')) {
        // Extract branch name to find issue number
        const branchName = process.env.BRANCH_NAME || '';
        const issueMatch = branchName.match(/(\w+-\d+)/);
        
        if (issueMatch) {
          data.message += `\n\nRefs: ${issueMatch[1]}`;
        }
      }
    }
    
    return data;
  }
};
```

## Creating Custom Commands

Plugins can add custom commands to Zen Commit:

```javascript
exports.commands = [
  {
    name: 'analyze',
    description: 'Analyze commit patterns',
    options: [
      {
        name: 'days',
        description: 'Number of days to analyze',
        alias: 'd',
        type: 'number'
      }
    ],
    execute: async (args, options) => {
      const days = options.days || 30;
      console.log(`Analyzing commit patterns for the last ${days} days...`);
      
      // Implementation...
    }
  }
];
```

## Publishing Your Plugin

To publish your plugin as an npm package:

1. Create a package with a name starting with `zencommit-plugin-`
2. Make sure the `main` field in your `package.json` points to your plugin's entry point
3. Include the necessary plugin exports (metadata, lifecycle methods, etc.)
4. Publish to npm: `npm publish`

## Installing Plugins

Users can install your plugin using:

```
zencommit plugin --install zencommit-plugin-your-plugin
```

## Plugin Configuration

Plugins can store and retrieve configuration using the ConfigService:

```javascript
exports.initialize = async (context) => {
  // Get plugin configuration
  const config = await context.services.configService.getPluginConfig('your-plugin-id');
  
  // Store plugin configuration
  await context.services.configService.setPluginConfig('your-plugin-id', {
    setting1: 'value1',
    setting2: true
  });
};
```

## Best Practices

1. Follow semantic versioning for your plugin
2. Document your plugin's functionality and configuration options
3. Handle errors gracefully and provide meaningful error messages
4. Test your plugin thoroughly before publishing
5. Use async/await for asynchronous operations
6. Always return data from hook handlers, even if unchanged
7. Keep plugin code modular and maintainable
8. Respect the application's performance and UX

## Example Plugin

See the `plugins/example-plugin` directory for a complete example plugin.
```

## Definition of Done
- Plugin interface defined with lifecycle methods, hooks, and commands
- Plugin registry implemented for discovering and loading plugins
- Plugin loader mechanism for local and npm plugins
- Plugin activation and deactivation functionality
- Plugin hook system for extending core functionality
- Plugin command system for adding custom commands
- Plugin configuration support
- Plugin management UI
- Documentation for plugin development

## Potential Blockers
- Module loading complexity across different environments
- Versioning and dependency management for plugins
- Security considerations for third-party plugins
- Ensuring proper lifecycle management for plugins
- Resolving conflicts between plugins

## Next Steps
- Implement extension marketplace (5.3.3)