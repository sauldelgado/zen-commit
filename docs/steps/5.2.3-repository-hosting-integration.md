# 5.2.3 Repository Hosting Integration

## Overview
This step implements integration with popular repository hosting platforms like GitHub, GitLab, and Bitbucket. The integration will provide features for creating and managing pull requests, reviewing code, accessing repository statistics, and synchronizing repository settings.

## Dependencies
- Phase 3.3 - Configuration System
- Phase 5.1.3 - Team Integration Features
- Phase 5.2.1 - Issue Tracker Integration

## Prerequisites
- Configuration schema definition (3.3.2)
- Per-project settings implementation (3.3.3)
- Team integration features (5.1.3)
- Issue tracker integration (5.2.1)

## Implementation Order
1. Define repository hosting integration interfaces
2. Implement GitHub repository integration
3. Create GitLab repository integration
4. Develop Bitbucket repository integration
5. Build pull request creation and management
6. Implement code review workflows
7. Create repository statistics collection

## Development Guidelines
- Use adapter pattern to support multiple repository hosting platforms
- Implement proper error handling for API rate limits and connection issues
- Use token-based authentication with secure storage
- Cache repository data to minimize API calls
- Handle platform-specific features with graceful degradation
- Provide consistent interface across different platforms

## Detailed Tasks

### 1. Test File Creation
Create a test file at `src/__tests__/services/RepositoryService.test.ts`:

```typescript
import { RepositoryService } from '../../services/RepositoryService';
import { GitHubRepositoryAdapter } from '../../adapters/GitHubRepositoryAdapter';
import { GitLabRepositoryAdapter } from '../../adapters/GitLabRepositoryAdapter';
import { BitbucketRepositoryAdapter } from '../../adapters/BitbucketRepositoryAdapter';
import { ConfigService } from '../../services/ConfigService';
import { GitService } from '../../services/GitService';
import { 
  PullRequestDetails, 
  RepositoryStats, 
  CodeReviewComment 
} from '../../types/Repository';

jest.mock('../../adapters/GitHubRepositoryAdapter');
jest.mock('../../adapters/GitLabRepositoryAdapter');
jest.mock('../../adapters/BitbucketRepositoryAdapter');
jest.mock('../../services/ConfigService');
jest.mock('../../services/GitService');

describe('RepositoryService', () => {
  let repositoryService: RepositoryService;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockGitService: jest.Mocked<GitService>;
  let mockGitHubAdapter: jest.Mocked<GitHubRepositoryAdapter>;
  let mockGitLabAdapter: jest.Mocked<GitLabRepositoryAdapter>;
  let mockBitbucketAdapter: jest.Mocked<BitbucketRepositoryAdapter>;
  
  beforeEach(() => {
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    mockGitService = new GitService() as jest.Mocked<GitService>;
    mockGitHubAdapter = new GitHubRepositoryAdapter(mockConfigService) as jest.Mocked<GitHubRepositoryAdapter>;
    mockGitLabAdapter = new GitLabRepositoryAdapter(mockConfigService) as jest.Mocked<GitLabRepositoryAdapter>;
    mockBitbucketAdapter = new BitbucketRepositoryAdapter(mockConfigService) as jest.Mocked<BitbucketRepositoryAdapter>;
    
    mockConfigService.getRepositoryConfig.mockResolvedValue({
      type: 'github',
      project: 'organization/repo',
      auth: {
        token: 'mock-token'
      }
    });
    
    mockGitService.getRemoteUrl.mockResolvedValue('https://github.com/organization/repo.git');
    
    repositoryService = new RepositoryService(
      mockConfigService, 
      mockGitService,
      mockGitHubAdapter,
      mockGitLabAdapter,
      mockBitbucketAdapter
    );
  });
  
  describe('detectRepositoryHosting', () => {
    it('should detect GitHub as repository hosting from remote URL', async () => {
      const result = await repositoryService.detectRepositoryHosting();
      
      expect(mockGitService.getRemoteUrl).toHaveBeenCalled();
      expect(result).toBe('github');
    });
    
    it('should detect GitLab when config specifies it', async () => {
      mockConfigService.getRepositoryConfig.mockResolvedValue({
        type: 'gitlab',
        project: 'group/project',
        baseUrl: 'https://gitlab.com',
        auth: {
          token: 'token'
        }
      });
      
      const result = await repositoryService.detectRepositoryHosting();
      
      expect(result).toBe('gitlab');
    });
    
    it('should return null if no repository hosting is detected', async () => {
      mockGitService.getRemoteUrl.mockResolvedValue(null);
      mockConfigService.getRepositoryConfig.mockResolvedValue(null);
      
      const result = await repositoryService.detectRepositoryHosting();
      
      expect(result).toBeNull();
    });
  });
  
  describe('createPullRequest', () => {
    it('should create a GitHub pull request', async () => {
      const prDetails: PullRequestDetails = {
        title: 'Implement authentication',
        description: 'This PR adds user authentication',
        sourceBranch: 'feature/auth',
        targetBranch: 'main',
        draft: false,
        labels: ['feature']
      };
      
      const mockPR = {
        id: '123',
        number: 42,
        title: prDetails.title,
        description: prDetails.description,
        sourceBranch: prDetails.sourceBranch,
        targetBranch: prDetails.targetBranch,
        state: 'open',
        url: 'https://github.com/organization/repo/pull/42',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        author: 'user',
        labels: prDetails.labels,
        reviewers: []
      };
      
      mockGitHubAdapter.createPullRequest.mockResolvedValue(mockPR);
      
      const result = await repositoryService.createPullRequest(prDetails);
      
      expect(mockGitHubAdapter.createPullRequest).toHaveBeenCalledWith(prDetails);
      expect(result).toEqual(mockPR);
    });
    
    it('should create a GitLab merge request', async () => {
      mockConfigService.getRepositoryConfig.mockResolvedValue({
        type: 'gitlab',
        project: 'group/project',
        baseUrl: 'https://gitlab.com',
        auth: {
          token: 'token'
        }
      });
      
      const prDetails: PullRequestDetails = {
        title: 'Implement authentication',
        description: 'This PR adds user authentication',
        sourceBranch: 'feature/auth',
        targetBranch: 'main',
        draft: false,
        labels: ['feature']
      };
      
      const mockPR = {
        id: '123',
        number: 42,
        title: prDetails.title,
        description: prDetails.description,
        sourceBranch: prDetails.sourceBranch,
        targetBranch: prDetails.targetBranch,
        state: 'open',
        url: 'https://gitlab.com/group/project/-/merge_requests/42',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        author: 'user',
        labels: prDetails.labels,
        reviewers: []
      };
      
      mockGitLabAdapter.createPullRequest.mockResolvedValue(mockPR);
      
      const result = await repositoryService.createPullRequest(prDetails);
      
      expect(mockGitLabAdapter.createPullRequest).toHaveBeenCalledWith(prDetails);
      expect(result).toEqual(mockPR);
    });
    
    it('should throw error if repository hosting type is not supported', async () => {
      mockConfigService.getRepositoryConfig.mockResolvedValue({
        type: 'unsupported' as any,
        project: 'project',
      });
      
      await expect(repositoryService.createPullRequest({} as any)).rejects.toThrow(
        'Unsupported repository hosting: unsupported'
      );
    });
  });
  
  describe('getPullRequests', () => {
    it('should fetch GitHub pull requests', async () => {
      const mockPRs = [
        {
          id: '123',
          number: 42,
          title: 'Implement authentication',
          description: 'This PR adds user authentication',
          sourceBranch: 'feature/auth',
          targetBranch: 'main',
          state: 'open',
          url: 'https://github.com/organization/repo/pull/42',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          author: 'user',
          labels: ['feature'],
          reviewers: []
        }
      ];
      
      mockGitHubAdapter.getPullRequests.mockResolvedValue(mockPRs);
      
      const result = await repositoryService.getPullRequests();
      
      expect(mockGitHubAdapter.getPullRequests).toHaveBeenCalled();
      expect(result).toEqual(mockPRs);
    });
  });
  
  describe('getRepositoryStats', () => {
    it('should fetch repository statistics', async () => {
      const mockStats: RepositoryStats = {
        commitCount: 150,
        contributorCount: 5,
        branchCount: 10,
        pullRequestCount: 25,
        openIssuesCount: 15,
        lastActivityDate: new Date().toISOString(),
        topContributors: [
          { name: 'User1', commitCount: 50 },
          { name: 'User2', commitCount: 40 }
        ],
        languageStats: {
          'TypeScript': 70,
          'JavaScript': 20,
          'CSS': 10
        }
      };
      
      mockGitHubAdapter.getRepositoryStats.mockResolvedValue(mockStats);
      
      const result = await repositoryService.getRepositoryStats();
      
      expect(mockGitHubAdapter.getRepositoryStats).toHaveBeenCalled();
      expect(result).toEqual(mockStats);
    });
  });
  
  describe('getPullRequestReviews', () => {
    it('should fetch pull request reviews', async () => {
      const prId = '42';
      const mockReviews = [
        {
          id: '123',
          author: 'reviewer1',
          state: 'approved',
          comment: 'LGTM!',
          createdAt: new Date().toISOString()
        }
      ];
      
      mockGitHubAdapter.getPullRequestReviews.mockResolvedValue(mockReviews);
      
      const result = await repositoryService.getPullRequestReviews(prId);
      
      expect(mockGitHubAdapter.getPullRequestReviews).toHaveBeenCalledWith(prId);
      expect(result).toEqual(mockReviews);
    });
  });
  
  describe('createReviewComment', () => {
    it('should create a review comment', async () => {
      const prId = '42';
      const comment: CodeReviewComment = {
        path: 'src/index.ts',
        position: 10,
        body: 'Consider using a more descriptive variable name'
      };
      
      mockGitHubAdapter.createReviewComment.mockResolvedValue({
        id: '123',
        ...comment,
        author: 'user',
        createdAt: new Date().toISOString()
      });
      
      const result = await repositoryService.createReviewComment(prId, comment);
      
      expect(mockGitHubAdapter.createReviewComment).toHaveBeenCalledWith(prId, comment);
      expect(result.id).toBe('123');
      expect(result.body).toBe(comment.body);
    });
  });
});
```

### 2. Repository Types
Create a file for repository hosting types at `src/types/Repository.ts`:

```typescript
/**
 * Pull request state
 */
export type PullRequestState = 'open' | 'closed' | 'merged' | 'draft';

/**
 * Details for creating a pull request
 */
export interface PullRequestDetails {
  title: string;
  description: string;
  sourceBranch: string;
  targetBranch: string;
  draft?: boolean;
  labels?: string[];
  reviewers?: string[];
}

/**
 * Pull request object returned from API
 */
export interface PullRequest {
  id: string;
  number: number;
  title: string;
  description: string;
  sourceBranch: string;
  targetBranch: string;
  state: PullRequestState;
  url: string;
  createdAt: string;
  updatedAt: string;
  author: string;
  labels: string[];
  reviewers: string[];
}

/**
 * Review state
 */
export type ReviewState = 'pending' | 'approved' | 'changes_requested' | 'commented';

/**
 * Review object
 */
export interface Review {
  id: string;
  author: string;
  state: ReviewState;
  comment: string;
  createdAt: string;
}

/**
 * Comment for code review
 */
export interface CodeReviewComment {
  path: string;
  position: number;
  body: string;
  id?: string;
  author?: string;
  createdAt?: string;
}

/**
 * Contributor statistics
 */
export interface Contributor {
  name: string;
  commitCount: number;
}

/**
 * Repository statistics
 */
export interface RepositoryStats {
  commitCount: number;
  contributorCount: number;
  branchCount: number;
  pullRequestCount: number;
  openIssuesCount: number;
  lastActivityDate: string;
  topContributors: Contributor[];
  languageStats: Record<string, number>;
}

/**
 * Interface for repository hosting adapters
 */
export interface RepositoryAdapter {
  initialize(): Promise<void>;
  getPullRequests(): Promise<PullRequest[]>;
  getPullRequest(id: string): Promise<PullRequest>;
  createPullRequest(details: PullRequestDetails): Promise<PullRequest>;
  updatePullRequest(id: string, details: Partial<PullRequestDetails>): Promise<PullRequest>;
  mergePullRequest(id: string): Promise<boolean>;
  closePullRequest(id: string): Promise<boolean>;
  getPullRequestReviews(id: string): Promise<Review[]>;
  createReviewComment(prId: string, comment: CodeReviewComment): Promise<CodeReviewComment>;
  getRepositoryStats(): Promise<RepositoryStats>;
}

/**
 * Repository hosting configuration structure
 */
export interface RepositoryConfig {
  type: 'github' | 'gitlab' | 'bitbucket';
  project: string;
  baseUrl?: string;
  auth?: {
    username?: string;
    token?: string;
  };
}
```

### 3. GitHub Repository Adapter Implementation
Create an adapter file at `src/adapters/GitHubRepositoryAdapter.ts`:

```typescript
import { ConfigService } from '../services/ConfigService';
import { 
  RepositoryAdapter, 
  PullRequest, 
  PullRequestDetails,
  Review,
  CodeReviewComment,
  RepositoryStats
} from '../types/Repository';
import axios from 'axios';

/**
 * GitHub repository adapter implementing the RepositoryAdapter interface
 */
export class GitHubRepositoryAdapter implements RepositoryAdapter {
  private token: string | null = null;
  private owner: string | null = null;
  private repo: string | null = null;
  
  constructor(private configService: ConfigService) {}
  
  /**
   * Initialize the adapter with configuration
   */
  public async initialize(): Promise<void> {
    const config = await this.configService.getRepositoryConfig();
    
    if (config?.type !== 'github') {
      throw new Error('Configuration is not for GitHub');
    }
    
    this.token = config.auth?.token || null;
    
    // Parse owner and repo from project field (format: owner/repo)
    if (config.project) {
      const [owner, repo] = config.project.split('/');
      this.owner = owner;
      this.repo = repo;
    }
  }
  
  /**
   * Get pull requests from GitHub
   */
  public async getPullRequests(): Promise<PullRequest[]> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const pulls = response.data || [];
      
      return pulls.map((pull: any) => ({
        id: pull.id.toString(),
        number: pull.number,
        title: pull.title,
        description: pull.body || '',
        sourceBranch: pull.head.ref,
        targetBranch: pull.base.ref,
        state: pull.draft ? 'draft' : pull.state,
        url: pull.html_url,
        createdAt: pull.created_at,
        updatedAt: pull.updated_at,
        author: pull.user.login,
        labels: pull.labels.map((label: any) => label.name),
        reviewers: pull.requested_reviewers.map((reviewer: any) => reviewer.login)
      }));
    } catch (error) {
      throw new Error(`Failed to fetch GitHub pull requests: ${error.message}`);
    }
  }
  
  /**
   * Get a specific pull request from GitHub
   */
  public async getPullRequest(id: string): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const pull = response.data;
      
      return {
        id: pull.id.toString(),
        number: pull.number,
        title: pull.title,
        description: pull.body || '',
        sourceBranch: pull.head.ref,
        targetBranch: pull.base.ref,
        state: pull.draft ? 'draft' : pull.state,
        url: pull.html_url,
        createdAt: pull.created_at,
        updatedAt: pull.updated_at,
        author: pull.user.login,
        labels: pull.labels.map((label: any) => label.name),
        reviewers: pull.requested_reviewers.map((reviewer: any) => reviewer.login)
      };
    } catch (error) {
      throw new Error(`Failed to fetch GitHub pull request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Create a new pull request on GitHub
   */
  public async createPullRequest(details: PullRequestDetails): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to create pull requests');
    }
    
    try {
      const response = await axios.post(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls`,
        {
          title: details.title,
          body: details.description,
          head: details.sourceBranch,
          base: details.targetBranch,
          draft: details.draft || false
        },
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const pull = response.data;
      
      // Set labels if provided
      if (details.labels && details.labels.length > 0) {
        await axios.post(
          `https://api.github.com/repos/${this.owner}/${this.repo}/issues/${pull.number}/labels`,
          { labels: details.labels },
          {
            headers: { Authorization: `token ${this.token}` }
          }
        );
      }
      
      // Set reviewers if provided
      if (details.reviewers && details.reviewers.length > 0) {
        await axios.post(
          `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${pull.number}/requested_reviewers`,
          { reviewers: details.reviewers },
          {
            headers: { Authorization: `token ${this.token}` }
          }
        );
      }
      
      return {
        id: pull.id.toString(),
        number: pull.number,
        title: pull.title,
        description: pull.body || '',
        sourceBranch: pull.head.ref,
        targetBranch: pull.base.ref,
        state: pull.draft ? 'draft' : pull.state,
        url: pull.html_url,
        createdAt: pull.created_at,
        updatedAt: pull.updated_at,
        author: pull.user.login,
        labels: details.labels || [],
        reviewers: details.reviewers || []
      };
    } catch (error) {
      throw new Error(`Failed to create GitHub pull request: ${error.message}`);
    }
  }
  
  /**
   * Update an existing pull request on GitHub
   */
  public async updatePullRequest(id: string, details: Partial<PullRequestDetails>): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to update pull requests');
    }
    
    try {
      // Update title and body
      const updateData: any = {};
      if (details.title) updateData.title = details.title;
      if (details.description) updateData.body = details.description;
      
      const response = await axios.patch(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}`,
        updateData,
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const pull = response.data;
      
      // Update labels if provided
      if (details.labels) {
        await axios.put(
          `https://api.github.com/repos/${this.owner}/${this.repo}/issues/${id}/labels`,
          { labels: details.labels },
          {
            headers: { Authorization: `token ${this.token}` }
          }
        );
      }
      
      // Update reviewers if provided
      if (details.reviewers) {
        await axios.post(
          `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}/requested_reviewers`,
          { reviewers: details.reviewers },
          {
            headers: { Authorization: `token ${this.token}` }
          }
        );
      }
      
      return {
        id: pull.id.toString(),
        number: pull.number,
        title: pull.title,
        description: pull.body || '',
        sourceBranch: pull.head.ref,
        targetBranch: pull.base.ref,
        state: pull.draft ? 'draft' : pull.state,
        url: pull.html_url,
        createdAt: pull.created_at,
        updatedAt: pull.updated_at,
        author: pull.user.login,
        labels: pull.labels.map((label: any) => label.name),
        reviewers: pull.requested_reviewers.map((reviewer: any) => reviewer.login)
      };
    } catch (error) {
      throw new Error(`Failed to update GitHub pull request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Merge a pull request on GitHub
   */
  public async mergePullRequest(id: string): Promise<boolean> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to merge pull requests');
    }
    
    try {
      await axios.put(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}/merge`,
        {},
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      return true;
    } catch (error) {
      throw new Error(`Failed to merge GitHub pull request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Close a pull request on GitHub
   */
  public async closePullRequest(id: string): Promise<boolean> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to close pull requests');
    }
    
    try {
      await axios.patch(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}`,
        { state: 'closed' },
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      return true;
    } catch (error) {
      throw new Error(`Failed to close GitHub pull request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Get reviews for a pull request on GitHub
   */
  public async getPullRequestReviews(id: string): Promise<Review[]> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${id}/reviews`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const reviews = response.data || [];
      
      return reviews.map((review: any) => {
        let state: Review['state'] = 'commented';
        
        if (review.state === 'APPROVED') state = 'approved';
        else if (review.state === 'CHANGES_REQUESTED') state = 'changes_requested';
        else if (review.state === 'PENDING') state = 'pending';
        
        return {
          id: review.id.toString(),
          author: review.user.login,
          state,
          comment: review.body || '',
          createdAt: review.submitted_at
        };
      });
    } catch (error) {
      throw new Error(`Failed to fetch GitHub pull request reviews for #${id}: ${error.message}`);
    }
  }
  
  /**
   * Create a review comment on GitHub
   */
  public async createReviewComment(prId: string, comment: CodeReviewComment): Promise<CodeReviewComment> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to create review comments');
    }
    
    try {
      // First get the pull request
      const prResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${prId}`,
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const pr = prResponse.data;
      
      // Create a new review with a comment
      const response = await axios.post(
        `https://api.github.com/repos/${this.owner}/${this.repo}/pulls/${prId}/comments`,
        {
          body: comment.body,
          commit_id: pr.head.sha,
          path: comment.path,
          position: comment.position
        },
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const reviewComment = response.data;
      
      return {
        id: reviewComment.id.toString(),
        path: comment.path,
        position: comment.position,
        body: reviewComment.body,
        author: reviewComment.user.login,
        createdAt: reviewComment.created_at
      };
    } catch (error) {
      throw new Error(`Failed to create review comment for GitHub pull request #${prId}: ${error.message}`);
    }
  }
  
  /**
   * Get repository statistics from GitHub
   */
  public async getRepositoryStats(): Promise<RepositoryStats> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      // Get repository info
      const repoResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const repo = repoResponse.data;
      
      // Get contributors
      const contributorsResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/stats/contributors`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const contributors = contributorsResponse.data || [];
      
      // Get languages
      const languagesResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/languages`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const languages = languagesResponse.data || {};
      
      // Calculate language percentages
      const totalBytes = Object.values(languages).reduce((sum: any, bytes: any) => sum + bytes, 0);
      const languageStats: Record<string, number> = {};
      
      if (totalBytes > 0) {
        Object.entries(languages).forEach(([lang, bytes]: [string, any]) => {
          languageStats[lang] = Math.round((bytes / totalBytes) * 100);
        });
      }
      
      // Sort contributors by commit count
      const topContributors = contributors
        .map((contributor: any) => ({
          name: contributor.author.login,
          commitCount: contributor.total
        }))
        .sort((a: Contributor, b: Contributor) => b.commitCount - a.commitCount)
        .slice(0, 5);
      
      return {
        commitCount: contributors.reduce((sum: number, contributor: any) => sum + contributor.total, 0),
        contributorCount: contributors.length,
        branchCount: repo.forks_count + 1, // Rough estimate
        pullRequestCount: repo.open_issues_count, // GitHub includes PRs in issues count
        openIssuesCount: repo.open_issues_count,
        lastActivityDate: repo.updated_at,
        topContributors,
        languageStats
      };
    } catch (error) {
      throw new Error(`Failed to fetch GitHub repository statistics: ${error.message}`);
    }
  }
}
```

### 4. GitLab Repository Adapter Implementation
Create an adapter file at `src/adapters/GitLabRepositoryAdapter.ts`:

```typescript
import { ConfigService } from '../services/ConfigService';
import { 
  RepositoryAdapter, 
  PullRequest, 
  PullRequestDetails,
  Review,
  CodeReviewComment,
  RepositoryStats
} from '../types/Repository';
import axios from 'axios';

/**
 * GitLab repository adapter implementing the RepositoryAdapter interface
 */
export class GitLabRepositoryAdapter implements RepositoryAdapter {
  private token: string | null = null;
  private baseUrl: string = 'https://gitlab.com';
  private projectId: string | null = null;
  
  constructor(private configService: ConfigService) {}
  
  /**
   * Initialize the adapter with configuration
   */
  public async initialize(): Promise<void> {
    const config = await this.configService.getRepositoryConfig();
    
    if (config?.type !== 'gitlab') {
      throw new Error('Configuration is not for GitLab');
    }
    
    this.token = config.auth?.token || null;
    this.baseUrl = config.baseUrl || 'https://gitlab.com';
    
    // Project ID or path (can be numeric ID or group/project path)
    this.projectId = config.project || null;
  }
  
  /**
   * Get pull requests (merge requests) from GitLab
   */
  public async getPullRequests(): Promise<PullRequest[]> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      const response = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const mergeRequests = response.data || [];
      
      return mergeRequests.map((mr: any) => {
        let state: PullRequestState = 'open';
        
        if (mr.state === 'closed') state = 'closed';
        else if (mr.state === 'merged') state = 'merged';
        else if (mr.work_in_progress) state = 'draft';
        
        return {
          id: mr.id.toString(),
          number: mr.iid,
          title: mr.title,
          description: mr.description || '',
          sourceBranch: mr.source_branch,
          targetBranch: mr.target_branch,
          state,
          url: mr.web_url,
          createdAt: mr.created_at,
          updatedAt: mr.updated_at,
          author: mr.author.username,
          labels: mr.labels || [],
          reviewers: (mr.reviewers || []).map((reviewer: any) => reviewer.username)
        };
      });
    } catch (error) {
      throw new Error(`Failed to fetch GitLab merge requests: ${error.message}`);
    }
  }
  
  /**
   * Get a specific pull request (merge request) from GitLab
   */
  public async getPullRequest(id: string): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      const response = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const mr = response.data;
      
      let state: PullRequestState = 'open';
      
      if (mr.state === 'closed') state = 'closed';
      else if (mr.state === 'merged') state = 'merged';
      else if (mr.work_in_progress) state = 'draft';
      
      return {
        id: mr.id.toString(),
        number: mr.iid,
        title: mr.title,
        description: mr.description || '',
        sourceBranch: mr.source_branch,
        targetBranch: mr.target_branch,
        state,
        url: mr.web_url,
        createdAt: mr.created_at,
        updatedAt: mr.updated_at,
        author: mr.author.username,
        labels: mr.labels || [],
        reviewers: (mr.reviewers || []).map((reviewer: any) => reviewer.username)
      };
    } catch (error) {
      throw new Error(`Failed to fetch GitLab merge request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Create a new pull request (merge request) on GitLab
   */
  public async createPullRequest(details: PullRequestDetails): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to create merge requests');
    }
    
    try {
      const response = await axios.post(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests`,
        {
          title: details.title,
          description: details.description,
          source_branch: details.sourceBranch,
          target_branch: details.targetBranch,
          labels: details.labels?.join(',') || '',
          reviewer_ids: details.reviewers || [],
          remove_source_branch: true,
          squash: false
        },
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      const mr = response.data;
      
      let state: PullRequestState = 'open';
      
      if (mr.state === 'closed') state = 'closed';
      else if (mr.state === 'merged') state = 'merged';
      else if (mr.work_in_progress) state = 'draft';
      
      return {
        id: mr.id.toString(),
        number: mr.iid,
        title: mr.title,
        description: mr.description || '',
        sourceBranch: mr.source_branch,
        targetBranch: mr.target_branch,
        state,
        url: mr.web_url,
        createdAt: mr.created_at,
        updatedAt: mr.updated_at,
        author: mr.author.username,
        labels: mr.labels || [],
        reviewers: (mr.reviewers || []).map((reviewer: any) => reviewer.username)
      };
    } catch (error) {
      throw new Error(`Failed to create GitLab merge request: ${error.message}`);
    }
  }
  
  /**
   * Update an existing pull request (merge request) on GitLab
   */
  public async updatePullRequest(id: string, details: Partial<PullRequestDetails>): Promise<PullRequest> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to update merge requests');
    }
    
    try {
      const updateData: any = {};
      if (details.title) updateData.title = details.title;
      if (details.description) updateData.description = details.description;
      if (details.labels) updateData.labels = details.labels.join(',');
      if (details.reviewers) updateData.reviewer_ids = details.reviewers;
      
      const response = await axios.put(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}`,
        updateData,
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      const mr = response.data;
      
      let state: PullRequestState = 'open';
      
      if (mr.state === 'closed') state = 'closed';
      else if (mr.state === 'merged') state = 'merged';
      else if (mr.work_in_progress) state = 'draft';
      
      return {
        id: mr.id.toString(),
        number: mr.iid,
        title: mr.title,
        description: mr.description || '',
        sourceBranch: mr.source_branch,
        targetBranch: mr.target_branch,
        state,
        url: mr.web_url,
        createdAt: mr.created_at,
        updatedAt: mr.updated_at,
        author: mr.author.username,
        labels: mr.labels || [],
        reviewers: (mr.reviewers || []).map((reviewer: any) => reviewer.username)
      };
    } catch (error) {
      throw new Error(`Failed to update GitLab merge request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Merge a pull request (merge request) on GitLab
   */
  public async mergePullRequest(id: string): Promise<boolean> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to merge merge requests');
    }
    
    try {
      await axios.put(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}/merge`,
        {},
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      return true;
    } catch (error) {
      throw new Error(`Failed to merge GitLab merge request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Close a pull request (merge request) on GitLab
   */
  public async closePullRequest(id: string): Promise<boolean> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to close merge requests');
    }
    
    try {
      await axios.put(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}`,
        { state_event: 'close' },
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      return true;
    } catch (error) {
      throw new Error(`Failed to close GitLab merge request #${id}: ${error.message}`);
    }
  }
  
  /**
   * Get reviews for a pull request (merge request) on GitLab
   */
  public async getPullRequestReviews(id: string): Promise<Review[]> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      const mrResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const mr = mrResponse.data;
      
      // GitLab doesn't have a direct API for reviews, so we collect approvals
      const approvalsResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}/approvals`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const approvals = approvalsResponse.data.approved_by || [];
      
      // Get discussions (comments)
      const discussionsResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${id}/discussions`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const discussions = discussionsResponse.data || [];
      
      // Extract top-level comments as reviews
      const topLevelComments = discussions
        .filter((discussion: any) => discussion.notes && discussion.notes.length > 0)
        .map((discussion: any) => discussion.notes[0]);
      
      // Combine approvals and comments
      const reviews: Review[] = [];
      
      // Add approvals
      approvals.forEach((approval: any) => {
        reviews.push({
          id: `approval-${approval.user.id}`,
          author: approval.user.username,
          state: 'approved',
          comment: 'Approved',
          createdAt: approval.created_at
        });
      });
      
      // Add top-level comments
      topLevelComments.forEach((comment: any) => {
        // Skip if already added as approval
        const isApprover = approvals.some((approval: any) => 
          approval.user.id === comment.author.id
        );
        
        if (!isApprover) {
          reviews.push({
            id: comment.id.toString(),
            author: comment.author.username,
            state: 'commented',
            comment: comment.body,
            createdAt: comment.created_at
          });
        }
      });
      
      return reviews;
    } catch (error) {
      throw new Error(`Failed to fetch GitLab merge request reviews for #${id}: ${error.message}`);
    }
  }
  
  /**
   * Create a review comment on GitLab
   */
  public async createReviewComment(prId: string, comment: CodeReviewComment): Promise<CodeReviewComment> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to create review comments');
    }
    
    try {
      // In GitLab, we post a comment on a merge request diff
      const response = await axios.post(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/merge_requests/${prId}/discussions`,
        {
          body: comment.body,
          position: {
            position_type: 'text',
            new_path: comment.path,
            old_path: comment.path,
            new_line: comment.position,
            old_line: null
          }
        },
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      const discussion = response.data;
      const note = discussion.notes[0];
      
      return {
        id: note.id.toString(),
        path: comment.path,
        position: comment.position,
        body: note.body,
        author: note.author.username,
        createdAt: note.created_at
      };
    } catch (error) {
      throw new Error(`Failed to create review comment for GitLab merge request #${prId}: ${error.message}`);
    }
  }
  
  /**
   * Get repository statistics from GitLab
   */
  public async getRepositoryStats(): Promise<RepositoryStats> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      // Get repository info
      const projectResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const project = projectResponse.data;
      
      // Get contributors
      const contributorsResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/repository/contributors`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const contributors = contributorsResponse.data || [];
      
      // Get languages
      const languagesResponse = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/languages`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const languages = languagesResponse.data || {};
      
      // Sort contributors by commit count
      const topContributors = contributors
        .map((contributor: any) => ({
          name: contributor.name,
          commitCount: contributor.commits
        }))
        .sort((a: Contributor, b: Contributor) => b.commitCount - a.commitCount)
        .slice(0, 5);
      
      return {
        commitCount: contributors.reduce((sum: number, contributor: any) => sum + contributor.commits, 0),
        contributorCount: contributors.length,
        branchCount: project.forks_count + 1, // Rough estimate
        pullRequestCount: project.merge_requests_count || 0,
        openIssuesCount: project.open_issues_count || 0,
        lastActivityDate: project.last_activity_at,
        topContributors,
        languageStats: languages
      };
    } catch (error) {
      throw new Error(`Failed to fetch GitLab repository statistics: ${error.message}`);
    }
  }
}
```

### 5. Create Bitbucket Repository Adapter
Following similar patterns as the GitHub and GitLab adapters, create:

- `src/adapters/BitbucketRepositoryAdapter.ts`

### 6. Repository Service Implementation
Create a service file at `src/services/RepositoryService.ts`:

```typescript
import { ConfigService } from './ConfigService';
import { GitService } from './GitService';
import { GitHubRepositoryAdapter } from '../adapters/GitHubRepositoryAdapter';
import { GitLabRepositoryAdapter } from '../adapters/GitLabRepositoryAdapter';
import { BitbucketRepositoryAdapter } from '../adapters/BitbucketRepositoryAdapter';
import { 
  PullRequest,
  PullRequestDetails,
  Review,
  CodeReviewComment,
  RepositoryStats,
  RepositoryAdapter
} from '../types/Repository';

/**
 * Service for integrating with repository hosting platforms
 */
export class RepositoryService {
  private activeAdapter: RepositoryAdapter | null = null;
  private repoType: string | null = null;
  
  constructor(
    private configService: ConfigService,
    private gitService: GitService,
    private githubAdapter: GitHubRepositoryAdapter,
    private gitlabAdapter: GitLabRepositoryAdapter,
    private bitbucketAdapter: BitbucketRepositoryAdapter
  ) {}
  
  /**
   * Detect the repository hosting platform from remote URL and configuration
   */
  public async detectRepositoryHosting(): Promise<string | null> {
    // First check configuration
    const config = await this.configService.getRepositoryConfig();
    
    if (config?.type) {
      this.repoType = config.type;
      return config.type;
    }
    
    // If not configured, try to detect from remote URL
    const remoteUrl = await this.gitService.getRemoteUrl();
    
    if (!remoteUrl) {
      return null;
    }
    
    if (remoteUrl.includes('github.com')) {
      this.repoType = 'github';
      return 'github';
    }
    
    if (remoteUrl.includes('gitlab.com')) {
      this.repoType = 'gitlab';
      return 'gitlab';
    }
    
    if (remoteUrl.includes('bitbucket.org')) {
      this.repoType = 'bitbucket';
      return 'bitbucket';
    }
    
    return null;
  }
  
  /**
   * Get the appropriate adapter for the current repository hosting
   */
  private async getAdapter(): Promise<RepositoryAdapter> {
    if (!this.repoType) {
      this.repoType = await this.detectRepositoryHosting();
    }
    
    if (!this.repoType) {
      throw new Error('No repository hosting configured or detected');
    }
    
    switch (this.repoType) {
      case 'github':
        return this.githubAdapter;
      case 'gitlab':
        return this.gitlabAdapter;
      case 'bitbucket':
        return this.bitbucketAdapter;
      default:
        throw new Error(`Unsupported repository hosting: ${this.repoType}`);
    }
  }
  
  /**
   * Get all pull requests
   */
  public async getPullRequests(): Promise<PullRequest[]> {
    const adapter = await this.getAdapter();
    return adapter.getPullRequests();
  }
  
  /**
   * Get a specific pull request
   */
  public async getPullRequest(id: string): Promise<PullRequest> {
    const adapter = await this.getAdapter();
    return adapter.getPullRequest(id);
  }
  
  /**
   * Create a new pull request
   */
  public async createPullRequest(details: PullRequestDetails): Promise<PullRequest> {
    const adapter = await this.getAdapter();
    return adapter.createPullRequest(details);
  }
  
  /**
   * Update an existing pull request
   */
  public async updatePullRequest(id: string, details: Partial<PullRequestDetails>): Promise<PullRequest> {
    const adapter = await this.getAdapter();
    return adapter.updatePullRequest(id, details);
  }
  
  /**
   * Merge a pull request
   */
  public async mergePullRequest(id: string): Promise<boolean> {
    const adapter = await this.getAdapter();
    return adapter.mergePullRequest(id);
  }
  
  /**
   * Close a pull request
   */
  public async closePullRequest(id: string): Promise<boolean> {
    const adapter = await this.getAdapter();
    return adapter.closePullRequest(id);
  }
  
  /**
   * Get reviews for a pull request
   */
  public async getPullRequestReviews(id: string): Promise<Review[]> {
    const adapter = await this.getAdapter();
    return adapter.getPullRequestReviews(id);
  }
  
  /**
   * Create a review comment
   */
  public async createReviewComment(prId: string, comment: CodeReviewComment): Promise<CodeReviewComment> {
    const adapter = await this.getAdapter();
    return adapter.createReviewComment(prId, comment);
  }
  
  /**
   * Get repository statistics
   */
  public async getRepositoryStats(): Promise<RepositoryStats> {
    const adapter = await this.getAdapter();
    return adapter.getRepositoryStats();
  }
  
  /**
   * Generate a pull request from the current branch
   */
  public async generatePullRequestFromCurrentBranch(): Promise<PullRequestDetails> {
    const currentBranch = await this.gitService.getCurrentBranchName();
    const defaultBranch = await this.gitService.getDefaultBranchName();
    
    if (!currentBranch) {
      throw new Error('Failed to get current branch name');
    }
    
    if (!defaultBranch) {
      throw new Error('Failed to get default branch name');
    }
    
    // Get commits on this branch
    const commits = await this.gitService.getCommitMessages(defaultBranch, currentBranch);
    
    // Generate title from branch name
    const branchTitle = currentBranch
      .replace(/[-_]/g, ' ')
      .replace(/^(feature|fix|docs|chore|refactor)\//, '')
      .trim();
    
    const title = branchTitle.charAt(0).toUpperCase() + branchTitle.slice(1);
    
    // Generate description from commits
    const description = commits.length > 0
      ? `## Changes\n\n${commits.map(commit => `- ${commit}`).join('\n')}`
      : '';
    
    return {
      title,
      description,
      sourceBranch: currentBranch,
      targetBranch: defaultBranch,
      draft: false,
      labels: []
    };
  }
}
```

### 7. Create UI Component for Pull Request Management
Create a UI component file at `src/components/repository/PullRequestManager.tsx`:

```typescript
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import SelectInput from '../inputs/SelectInput';
import TextInput from '../inputs/TextInput';
import { Spinner } from '../feedback/Spinner';
import { useRepositoryService } from '../../hooks/useRepositoryService';
import { PullRequest, PullRequestDetails } from '../../types/Repository';

interface PullRequestManagerProps {
  onClose: () => void;
}

type ViewMode = 'list' | 'create' | 'detail';

/**
 * Component for managing pull requests
 */
export const PullRequestManager: React.FC<PullRequestManagerProps> = ({ onClose }) => {
  const repositoryService = useRepositoryService();
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [pullRequests, setPullRequests] = useState<PullRequest[]>([]);
  const [selectedPrIndex, setSelectedPrIndex] = useState(0);
  const [selectedPr, setSelectedPr] = useState<PullRequest | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // New PR details
  const [newPrTitle, setNewPrTitle] = useState('');
  const [newPrDescription, setNewPrDescription] = useState('');
  const [newPrSourceBranch, setNewPrSourceBranch] = useState('');
  const [newPrTargetBranch, setNewPrTargetBranch] = useState('');
  const [newPrIsDraft, setNewPrIsDraft] = useState(false);
  
  // Load pull requests
  const loadPullRequests = async () => {
    try {
      setLoading(true);
      const prs = await repositoryService.getPullRequests();
      setPullRequests(prs);
      
      if (prs.length > 0 && selectedPrIndex < prs.length) {
        setSelectedPr(prs[selectedPrIndex]);
      }
      
      setError(null);
    } catch (err) {
      setError(`Failed to load pull requests: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Initial load
  useEffect(() => {
    loadPullRequests();
  }, []);
  
  // Handle PR creation
  const handleCreatePR = async () => {
    try {
      setLoading(true);
      
      const newPr = await repositoryService.createPullRequest({
        title: newPrTitle,
        description: newPrDescription,
        sourceBranch: newPrSourceBranch,
        targetBranch: newPrTargetBranch,
        draft: newPrIsDraft
      });
      
      // Refresh list and go back to it
      await loadPullRequests();
      setViewMode('list');
    } catch (err) {
      setError(`Failed to create pull request: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Generate PR from current branch
  const generatePRFromCurrentBranch = async () => {
    try {
      setLoading(true);
      
      const prDetails = await repositoryService.generatePullRequestFromCurrentBranch();
      
      setNewPrTitle(prDetails.title);
      setNewPrDescription(prDetails.description);
      setNewPrSourceBranch(prDetails.sourceBranch);
      setNewPrTargetBranch(prDetails.targetBranch);
      setNewPrIsDraft(false);
      
      setError(null);
    } catch (err) {
      setError(`Failed to generate pull request details: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Merge the selected PR
  const mergePullRequest = async () => {
    if (!selectedPr) return;
    
    try {
      setLoading(true);
      await repositoryService.mergePullRequest(selectedPr.id);
      await loadPullRequests();
      setViewMode('list');
    } catch (err) {
      setError(`Failed to merge pull request: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Close the selected PR
  const closePullRequest = async () => {
    if (!selectedPr) return;
    
    try {
      setLoading(true);
      await repositoryService.closePullRequest(selectedPr.id);
      await loadPullRequests();
      setViewMode('list');
    } catch (err) {
      setError(`Failed to close pull request: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Handle user input
  useInput((input, key) => {
    if (viewMode === 'list') {
      if (key.escape || input === 'q') {
        onClose();
        return;
      }
      
      if (key.return && pullRequests.length > 0) {
        setSelectedPr(pullRequests[selectedPrIndex]);
        setViewMode('detail');
        return;
      }
      
      if (input === 'c') {
        setViewMode('create');
        generatePRFromCurrentBranch();
        return;
      }
      
      if (input === 'r') {
        loadPullRequests();
        return;
      }
    } else if (viewMode === 'detail') {
      if (key.escape) {
        setViewMode('list');
        return;
      }
      
      if (input === 'm' && selectedPr && selectedPr.state === 'open') {
        mergePullRequest();
        return;
      }
      
      if (input === 'c' && selectedPr && selectedPr.state === 'open') {
        closePullRequest();
        return;
      }
    } else if (viewMode === 'create') {
      if (key.escape) {
        setViewMode('list');
        return;
      }
    }
  });
  
  if (loading && viewMode === 'list' && pullRequests.length === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Loading pull requests..." />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color="red">{error}</Text>
        <Text>Press any key to try again</Text>
      </Box>
    );
  }
  
  // Pull Request List View
  if (viewMode === 'list') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Pull Requests</Text>
          <Text dimColor> - Press C to create new PR, R to refresh, Q to quit</Text>
        </Box>
        
        {pullRequests.length === 0 ? (
          <Text>No pull requests found.</Text>
        ) : (
          <>
            {pullRequests.map((pr, index) => (
              <Box 
                key={pr.id} 
                flexDirection="row" 
                padding={1}
                backgroundColor={index === selectedPrIndex ? 'blue' : undefined}
              >
                <Box width={5}>
                  <Text>#{pr.number}</Text>
                </Box>
                <Box width={30}>
                  <Text>{pr.title}</Text>
                </Box>
                <Box width={15}>
                  <Text 
                    color={
                      pr.state === 'open' ? 'green' : 
                      pr.state === 'merged' ? 'magenta' : 
                      pr.state === 'draft' ? 'yellow' : 'gray'
                    }
                  >
                    {pr.state}
                  </Text>
                </Box>
                <Box>
                  <Text dimColor>by {pr.author}</Text>
                </Box>
              </Box>
            ))}
          </>
        )}
      </Box>
    );
  }
  
  // Pull Request Detail View
  if (viewMode === 'detail' && selectedPr) {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>#{selectedPr.number}: {selectedPr.title}</Text>
          <Text dimColor> - Press ESC to go back, M to merge, C to close</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Status: </Text>
          <Text 
            color={
              selectedPr.state === 'open' ? 'green' : 
              selectedPr.state === 'merged' ? 'magenta' : 
              selectedPr.state === 'draft' ? 'yellow' : 'gray'
            }
          >
            {selectedPr.state}
          </Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Author: </Text>
          <Text>{selectedPr.author}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Branches: </Text>
          <Text>{selectedPr.sourceBranch} → {selectedPr.targetBranch}</Text>
        </Box>
        
        <Box marginY={1} flexDirection="column">
          <Text bold>Description:</Text>
          <Box marginLeft={2} marginTop={1}>
            <Text>{selectedPr.description || 'No description provided.'}</Text>
          </Box>
        </Box>
        
        {selectedPr.labels.length > 0 && (
          <Box marginY={1} flexDirection="column">
            <Text bold>Labels:</Text>
            <Box marginLeft={2} marginTop={1}>
              <Text>{selectedPr.labels.join(', ')}</Text>
            </Box>
          </Box>
        )}
        
        <Box marginY={1}>
          <Text>URL: {selectedPr.url}</Text>
        </Box>
      </Box>
    );
  }
  
  // Create PR View
  if (viewMode === 'create') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Create Pull Request</Text>
          <Text dimColor> - Press ESC to cancel</Text>
        </Box>
        
        {loading ? (
          <Spinner text="Generating pull request details..." />
        ) : (
          <>
            <Box marginY={1} flexDirection="column">
              <Text bold>Title:</Text>
              <TextInput 
                value={newPrTitle} 
                onChange={setNewPrTitle} 
                placeholder="Enter title"
              />
            </Box>
            
            <Box marginY={1} flexDirection="column">
              <Text bold>Description:</Text>
              <TextInput 
                value={newPrDescription} 
                onChange={setNewPrDescription} 
                placeholder="Enter description" 
                multiline
              />
            </Box>
            
            <Box marginY={1} flexDirection="column">
              <Text bold>Source Branch:</Text>
              <TextInput 
                value={newPrSourceBranch} 
                onChange={setNewPrSourceBranch} 
                placeholder="Enter source branch"
              />
            </Box>
            
            <Box marginY={1} flexDirection="column">
              <Text bold>Target Branch:</Text>
              <TextInput 
                value={newPrTargetBranch} 
                onChange={setNewPrTargetBranch} 
                placeholder="Enter target branch"
              />
            </Box>
            
            <Box marginY={1} flexDirection="row">
              <Text bold>Draft: </Text>
              <Text>{newPrIsDraft ? 'Yes' : 'No'}</Text>
              <Box marginLeft={2}>
                <Text dimColor>(Press D to toggle)</Text>
              </Box>
            </Box>
            
            <Box marginY={2}>
              <Text bold>Press ENTER to create pull request</Text>
            </Box>
          </>
        )}
      </Box>
    );
  }
  
  return null;
};
```

### 8. Create Repository Hook
Create a custom hook at `src/hooks/useRepositoryService.ts`:

```typescript
import { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import { RepositoryService } from '../services/RepositoryService';

/**
 * Hook to access the RepositoryService instance
 */
export function useRepositoryService(): RepositoryService {
  const { services } = useContext(AppContext);
  
  if (!services.repositoryService) {
    throw new Error('RepositoryService not available in context');
  }
  
  return services.repositoryService;
}
```

### 9. Create Repository Command
Create a command file at `src/commands/repo.ts`:

```typescript
import { Command } from '../types/Command';
import { render } from 'ink';
import React from 'react';
import { PullRequestManager } from '../components/repository/PullRequestManager';
import { createAppContext } from '../context/createAppContext';

/**
 * Command for repository hosting operations
 */
export const repoCommand: Command = {
  name: 'repo',
  description: 'Manage repository and pull requests',
  options: [
    {
      name: 'pr',
      description: 'Manage pull requests',
      alias: 'p',
      type: 'boolean'
    },
    {
      name: 'create-pr',
      description: 'Create a pull request from current branch',
      alias: 'c',
      type: 'boolean'
    },
    {
      name: 'stats',
      description: 'Show repository statistics',
      alias: 's',
      type: 'boolean'
    }
  ],
  
  async execute(args, options): Promise<void> {
    const context = await createAppContext();
    const { repositoryService } = context.services;
    
    // Show repository statistics
    if (options.stats) {
      try {
        const stats = await repositoryService.getRepositoryStats();
        
        console.log('📊 Repository Statistics:');
        console.log(`Commits: ${stats.commitCount}`);
        console.log(`Contributors: ${stats.contributorCount}`);
        console.log(`Branches: ${stats.branchCount}`);
        console.log(`Pull Requests: ${stats.pullRequestCount}`);
        console.log(`Open Issues: ${stats.openIssuesCount}`);
        console.log(`Last Activity: ${new Date(stats.lastActivityDate).toLocaleDateString()}`);
        
        console.log('\nTop Contributors:');
        stats.topContributors.forEach(contributor => {
          console.log(`  ${contributor.name}: ${contributor.commitCount} commits`);
        });
        
        console.log('\nLanguages:');
        Object.entries(stats.languageStats)
          .sort((a, b) => b[1] - a[1])
          .forEach(([language, percentage]) => {
            console.log(`  ${language}: ${percentage}%`);
          });
      } catch (error) {
        console.error('❌ Failed to get repository statistics:', error.message);
      }
      return;
    }
    
    // Create a pull request from current branch
    if (options['create-pr']) {
      try {
        const prDetails = await repositoryService.generatePullRequestFromCurrentBranch();
        
        console.log('Pull Request Details:');
        console.log(`Title: ${prDetails.title}`);
        console.log(`Source Branch: ${prDetails.sourceBranch}`);
        console.log(`Target Branch: ${prDetails.targetBranch}`);
        console.log('\nDescription:');
        console.log(prDetails.description);
        
        const confirm = await context.ui.confirm('Create this pull request?');
        
        if (confirm) {
          const pr = await repositoryService.createPullRequest(prDetails);
          console.log(`✅ Pull request created: ${pr.url}`);
        } else {
          console.log('❌ Pull request creation cancelled');
        }
      } catch (error) {
        console.error('❌ Failed to create pull request:', error.message);
      }
      return;
    }
    
    // Default: show PR manager
    const { waitUntilExit } = render(
      React.createElement(
        PullRequestManager, 
        { onClose: () => process.exit(0) }
      )
    );
    
    await waitUntilExit();
  }
};
```

### 10. Update Configuration Service
Update `src/services/ConfigService.ts` to include repository hosting configuration:

```typescript
// Add new methods
/**
 * Get repository hosting configuration
 */
public async getRepositoryConfig(): Promise<RepositoryConfig | null> {
  await this.loadConfig();
  return this.config.repository || null;
}

/**
 * Update repository hosting configuration
 */
public async updateRepositoryConfig(config: RepositoryConfig): Promise<void> {
  await this.loadConfig();
  this.config.repository = config;
  await this.saveConfig();
}
```

### 11. Update Core Exports
Update `src/index.ts` to include the repository service:

```typescript
// Add to imports
import { RepositoryService } from './services/RepositoryService';
import { GitHubRepositoryAdapter } from './adapters/GitHubRepositoryAdapter';
import { GitLabRepositoryAdapter } from './adapters/GitLabRepositoryAdapter';
import { BitbucketRepositoryAdapter } from './adapters/BitbucketRepositoryAdapter';
import { repoCommand } from './commands/repo';

// Add to commandRegistry
commandRegistry.register(repoCommand);

// Add to service initialization
const githubRepositoryAdapter = new GitHubRepositoryAdapter(configService);
const gitlabRepositoryAdapter = new GitLabRepositoryAdapter(configService);
const bitbucketRepositoryAdapter = new BitbucketRepositoryAdapter(configService);

const repositoryService = new RepositoryService(
  configService,
  gitService,
  githubRepositoryAdapter,
  gitlabRepositoryAdapter,
  bitbucketRepositoryAdapter
);

// Add to context
context.services.repositoryService = repositoryService;
```

### 12. Update App Context Type
Update `src/context/AppContext.ts`:

```typescript
import { RepositoryService } from '../services/RepositoryService';

// Add to Services interface
export interface Services {
  // ... existing services
  repositoryService: RepositoryService;
}
```

## Definition of Done
- Repository service implemented with adapter pattern supporting GitHub, GitLab, and Bitbucket
- Pull request creation and management functionality
- Code review and commenting capabilities
- Repository statistics collection and visualization
- Integration with existing commit workflow
- Documentation updated for repository hosting integration features

## Potential Blockers
- API rate limits for repository hosting platforms
- Authentication complexity for different platforms
- Differences in API structure between platforms
- Limited access to certain repository hosting features from the CLI
- Network connectivity issues affecting API calls

## Next Steps
- Implement documentation generation (5.3.1)
- Create plugin architecture (5.3.2)