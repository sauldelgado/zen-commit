# Phase 3.1.4: Testing Infrastructure Improvements

## Overview

This step focuses on improving the testing infrastructure to better support React function components, particularly for Ink-based UI components. During the implementation of step 3.1.3 (Template Selection UI), issues were discovered with the current mocking system that hindered proper testing of function components. This task will modernize the test mocks, fix compatibility issues with function components, and improve the overall type safety of the test suite.

## Dependencies

- React and Ink (for terminal UI)
- Jest and ink-testing-library (for testing)
- TypeScript (for type definitions)

## Prerequisites

- Phase 1 and 2 must be complete
- Steps 3.1.1 through 3.1.3 should be completed

## Implementation Order

1. Update base mocks for Ink components to support function components
2. Improve the mocking strategy for Ink's third-party components
3. Add proper type definitions for component props in tests
4. Refactor existing test files to use the improved mocking system
5. Document type assertions as technical debt

## Development Workflow Guidelines

Before implementing this step, please adhere to the following guidelines:

1. **Check for Claude.md Files**
   - Look for both global and project-specific Claude.md files
   - If conflicts exist, project-specific settings override global settings
   - In absence of conflicts, adhere to both sets of guidelines

2. **Test-Driven Development (TDD)**
   - Make changes to test mocks in small, incremental steps
   - Run tests after each change to ensure they still pass
   - Fix failing tests immediately before continuing

3. **Reference Git History and External Resources**
   - Use `gh` commands to understand similar implementations
   - Review existing test files for patterns to follow

## Tasks

### 1. Update Base Ink Mocks

- [ ] Update the mock implementation in `tests/mocks/ink.js` to support function components
  ```javascript
  // Old implementation (class-based)
  class Box extends React.Component {
    render() {
      return this.props.children || null;
    }
  }

  // New implementation (function-based)
  const Box = ({ children, ...props }) => children || null;
  ```

- [ ] Update all basic component mocks (Box, Text, etc.) to use function components
  ```javascript
  const Text = ({ children, color, bold, dimColor, ...props }) => {
    // Process props as needed for tests
    return children || '';
  };
  ```

- [ ] Improve the render function mock to handle both function and class components
  ```javascript
  const render = (element) => {
    // Extract component type and props regardless of component type
    const getComponent = (el) => {
      if (!el) return { type: 'unknown', props: {} };
      
      // Handle function components
      if (typeof el.type === 'function') {
        return {
          type: el.type.displayName || el.type.name || 'FunctionComponent',
          props: el.props || {}
        };
      }
      
      // Handle class components
      if (el.type && el.type.name) {
        return {
          type: el.type.name,
          props: el.props || {}
        };
      }
      
      // Handle string type elements (DOM nodes)
      return {
        type: el.type || 'unknown',
        props: el.props || {}
      };
    };
    
    const component = getComponent(element);
    // Generate output based on component type and props
    
    return {
      lastFrame: () => 'Mocked output',
      frames: ['Mocked output'],
      stdin: { write: jest.fn() },
      rerender: jest.fn(),
      unmount: jest.fn(),
      cleanup: jest.fn(),
    };
  };
  ```

### 2. Improve Third-Party Component Mocks

- [ ] Update the ink-select-input mock to better support function components
  ```javascript
  // In tests/mocks/ink-select-input.js
  const SelectInput = ({ items, onSelect, itemComponent, ...props }) => {
    // Simplified mock implementation
    return items.map((item, i) => (
      React.createElement('div', 
        { 
          key: i, 
          onClick: () => onSelect(item),
          'data-testid': `select-item-${i}`
        },
        itemComponent ? 
          itemComponent({ isSelected: i === 0, item }) : 
          item.label
      )
    ));
  };
  ```

- [ ] Update the ink-text-input mock for proper function component support
  ```javascript
  // In tests/mocks/ink-text-input.js
  const TextInput = ({ value, onChange, onSubmit, placeholder, ...props }) => {
    return React.createElement('input', { 
      value, 
      onChange: (e) => onChange(e.target.value),
      onKeyDown: (e) => {
        if (e.key === 'Enter' && onSubmit) {
          onSubmit(value);
        }
      },
      placeholder,
      'data-testid': 'text-input' 
    });
  };
  ```

- [ ] Create proper type definitions for component props in mocks
  ```typescript
  // Define types for component props to match actual components
  type SelectInputProps = {
    items: Array<{ label: string; value: any; [key: string]: any }>;
    onSelect: (item: any) => void;
    itemComponent?: React.FC<{ isSelected: boolean; item: any }>;
    [key: string]: any;
  };
  ```

### 3. Update Template Component Tests

- [ ] Refactor `TemplateSelector.test.tsx` to use the improved mocks
  ```typescript
  import React from 'react';
  import { render } from 'ink-testing-library';
  import TemplateSelector from '@ui/components/TemplateSelector';
  import { TemplateDefinition } from '@core/template-definition';

  // Define proper item component type
  type ItemComponentProps = {
    isSelected: boolean;
    item: {
      label: string;
      value: TemplateDefinition;
      description?: string;
    };
  };

  // Mock SelectInput component to simulate selection
  jest.mock('ink-select-input', () => {
    const React = require('react');
    return function MockSelectInput({ items, onSelect, itemComponent }: { 
      items: any[]; 
      onSelect: (item: any) => void; 
      itemComponent: React.FC<ItemComponentProps>;
    }) {
      // Render items using the provided itemComponent
      return (
        <div data-testid="select-input">
          {items.map((item, i) => (
            <div key={i} data-testid={`select-item-${i}`} onClick={() => onSelect(item)}>
              {itemComponent({ isSelected: i === 0, item })}
            </div>
          ))}
        </div>
      );
    };
  });

  describe('TemplateSelector Component', () => {
    // Test implementation...
  });
  ```

- [ ] Refactor `TemplateForm.test.tsx` to use the improved mocks
  ```typescript
  import React from 'react';
  import { render, fireEvent } from 'ink-testing-library';
  import TemplateForm from '@ui/components/TemplateForm';
  import { TemplateDefinition } from '@core/template-definition';

  // Define proper input types
  type TextInputProps = {
    value: string;
    onChange: (value: string) => void;
    onSubmit: () => void;
    placeholder?: string;
  };

  // Mock Ink text input component
  jest.mock('ink-text-input', () => {
    const React = require('react');
    return ({ value, onChange, onSubmit, placeholder }: TextInputProps) => {
      return (
        <input
          data-testid="text-input"
          value={value}
          onChange={(e: any) => onChange(e.target.value)}
          onKeyDown={(e: any) => {
            if (e.key === 'Enter' && onSubmit) {
              onSubmit();
            }
          }}
          placeholder={placeholder}
        />
      );
    };
  });

  describe('TemplateForm Component', () => {
    // Test implementation...
  });
  ```

- [ ] Refactor `TemplateBrowser.test.tsx` to use the improved mocks
  ```typescript
  import React from 'react';
  import { render } from 'ink-testing-library';
  import TemplateBrowser from '@ui/components/TemplateBrowser';
  import { TemplateDefinition } from '@core/template-definition';
  import { TemplateManager } from '@core/template-manager';

  // Mock dependencies with better typing
  jest.mock('@ui/components/TemplateSelector', () => {
    const React = require('react');
    return ({ onSelectTemplate, templates }: { 
      onSelectTemplate: (template: TemplateDefinition) => void; 
      templates: TemplateDefinition[]; 
    }) => {
      return (
        <div
          data-testid="template-selector"
          onClick={() => onSelectTemplate(templates[0])}>
          Template Selector
        </div>
      );
    };
  });

  describe('TemplateBrowser Component', () => {
    // Test implementation...
  });
  ```

### 4. Create Utility Functions for Testing

- [ ] Create test utility function for simulating user input
  ```typescript
  // In tests/helpers/user-input.ts
  export function simulateInput(stdin: any, input: string) {
    stdin.write(input);
  }

  export function simulateKey(stdin: any, key: string) {
    stdin.write({ key });
  }

  export function simulateSelect(element: HTMLElement, index: number) {
    const item = element.querySelectorAll(`[data-testid^="select-item-"]`)[index];
    if (item) {
      (item as HTMLElement).click();
    }
  }
  ```

- [ ] Create utility for handling function component testing
  ```typescript
  // In tests/helpers/component-utils.ts
  import React from 'react';
  import { render as inkRender } from 'ink-testing-library';

  // Wrapper to add data-testid attribute to components
  export function wrapWithTestId<P extends object>(
    Component: React.ComponentType<P>,
    testId: string
  ): React.FC<P> {
    const WrappedComponent: React.FC<P> = (props) => (
      <div data-testid={testId}>
        <Component {...props} />
      </div>
    );
    WrappedComponent.displayName = `TestWrapper(${Component.displayName || Component.name})`;
    return WrappedComponent;
  }

  // Enhanced render function for testing
  export function render<P extends object>(
    Component: React.ComponentType<P>,
    props: P
  ) {
    const result = inkRender(<Component {...props} />);
    return {
      ...result,
      getByTestId: (testId: string) => {
        // Simple implementation to simulate finding by testId
        return {
          click: jest.fn(),
          textContent: result.lastFrame(),
        };
      },
    };
  }
  ```

### 5. Document Type Assertions

- [ ] Create a technical debt document for tracking type assertions
  ```markdown
  # Technical Debt: Type Assertions

  ## Overview
  
  This document tracks type assertions used in the codebase as temporary workarounds
  for TypeScript typing issues, particularly related to third-party libraries.

  ## Current Type Assertions

  ### Template Components
  
  1. `TemplateSelector.tsx`
     - Line 79: `itemComponent={TemplateSelectItem as any}`
     - Reason: Incompatibility between Ink's type definitions and our function components
     - Planned resolution: Update @types/ink-select-input or create proper type overrides

  2. `TemplateForm.tsx`
     - Line 118: `itemComponent={TemplateFormSelectItem as any}`
     - Reason: Same as above
     - Planned resolution: Same as above

  ## Resolution Strategy

  These type assertions should be addressed in a future refactoring task by either:
  
  1. Creating proper type definitions that extend the existing ones
  2. Submitting fixes to the @types packages
  3. Creating wrapper components that handle the type conversion properly

  ## Timeline

  These issues should be addressed before the 1.0 release to ensure type safety throughout
  the codebase.
  ```

## Testing

- [ ] Run tests to verify improved component mocking
  ```bash
  npm test -- -t "Template"
  ```

- [ ] Ensure all tests pass with improved mocks

## Definition of Done

- All basic Ink component mocks are updated to function components
- Third-party component mocks properly support function components 
- Template component tests pass with improved mocks
- Type safety is improved through proper type definitions
- Technical debt related to type assertions is documented
- No regression in test functionality (all tests still pass)
- The mocking strategy is well-documented for future component testing

## Potential Blockers

- Incompatibilities between types in @types packages and actual component behavior
- Complex event handling in Ink components that may be difficult to mock
- Dependencies between different mock components causing cascading failures

## Next Steps

After completing this step, continue with the main implementation plan:
1. Complete any remaining work for step 3.1.3 (Template Selection UI)
2. Move on to step 3.2.1 (Pattern Detection Engine)