# 5.2.2 CI/CD Integration

## Overview
This step implements integration with continuous integration and continuous deployment systems to enhance the commit workflow. The integration will allow for validating commit messages against CI/CD pipelines, viewing pipeline status directly from the CLI, and automatically triggering specific workflows based on commit patterns.

## Dependencies
- Phase 3.3 - Configuration System
- Phase 5.1.3 - Team Integration Features

## Prerequisites
- Configuration schema definition (3.3.2)
- Per-project settings implementation (3.3.3)
- Team integration features (5.1.3)

## Implementation Order
1. Define CI/CD integration interfaces
2. Implement GitHub Actions integration
3. Create GitLab CI integration
4. Develop Jenkins integration
5. Build CircleCI integration
6. Implement pipeline status visualization
7. Create commit message validation against CI rules

## Development Guidelines
- Use adapter pattern to support multiple CI/CD systems
- Implement proper error handling for API rate limits and connection issues
- Use token-based authentication with secure storage
- Cache pipeline status information to minimize API calls
- Handle CI/CD system-specific features with graceful degradation

## Detailed Tasks

### 1. Test File Creation
Create a test file at `src/__tests__/services/CICDService.test.ts`:

```typescript
import { CICDService } from '../../services/CICDService';
import { GitHubActionsAdapter } from '../../adapters/GitHubActionsAdapter';
import { GitLabCIAdapter } from '../../adapters/GitLabCIAdapter';
import { JenkinsCIAdapter } from '../../adapters/JenkinsCIAdapter';
import { CircleCIAdapter } from '../../adapters/CircleCIAdapter';
import { ConfigService } from '../../services/ConfigService';
import { GitService } from '../../services/GitService';
import { PipelineStatus, CICDPipeline, CICDRule } from '../../types/CICD';

jest.mock('../../adapters/GitHubActionsAdapter');
jest.mock('../../adapters/GitLabCIAdapter');
jest.mock('../../adapters/JenkinsCIAdapter');
jest.mock('../../adapters/CircleCIAdapter');
jest.mock('../../services/ConfigService');
jest.mock('../../services/GitService');

describe('CICDService', () => {
  let cicdService: CICDService;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockGitService: jest.Mocked<GitService>;
  let mockGitHubAdapter: jest.Mocked<GitHubActionsAdapter>;
  let mockGitLabAdapter: jest.Mocked<GitLabCIAdapter>;
  let mockJenkinsAdapter: jest.Mocked<JenkinsCIAdapter>;
  let mockCircleCIAdapter: jest.Mocked<CircleCIAdapter>;
  
  beforeEach(() => {
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    mockGitService = new GitService() as jest.Mocked<GitService>;
    mockGitHubAdapter = new GitHubActionsAdapter(mockConfigService) as jest.Mocked<GitHubActionsAdapter>;
    mockGitLabAdapter = new GitLabCIAdapter(mockConfigService) as jest.Mocked<GitLabCIAdapter>;
    mockJenkinsAdapter = new JenkinsCIAdapter(mockConfigService) as jest.Mocked<JenkinsCIAdapter>;
    mockCircleCIAdapter = new CircleCIAdapter(mockConfigService) as jest.Mocked<CircleCIAdapter>;
    
    mockConfigService.getCICDConfig.mockResolvedValue({
      type: 'github-actions',
      project: 'organization/repo',
      auth: {
        token: 'mock-token'
      }
    });
    
    mockGitService.getRemoteUrl.mockResolvedValue('https://github.com/organization/repo.git');
    
    cicdService = new CICDService(
      mockConfigService, 
      mockGitService,
      mockGitHubAdapter,
      mockGitLabAdapter,
      mockJenkinsAdapter,
      mockCircleCIAdapter
    );
  });
  
  describe('detectCICDSystem', () => {
    it('should detect GitHub Actions as CI/CD system from repository URL', async () => {
      const result = await cicdService.detectCICDSystem();
      
      expect(mockGitService.getRemoteUrl).toHaveBeenCalled();
      expect(result).toBe('github-actions');
    });
    
    it('should detect GitLab CI when config specifies it', async () => {
      mockConfigService.getCICDConfig.mockResolvedValue({
        type: 'gitlab-ci',
        project: 'group/project',
        baseUrl: 'https://gitlab.com',
        auth: {
          token: 'token'
        }
      });
      
      const result = await cicdService.detectCICDSystem();
      
      expect(result).toBe('gitlab-ci');
    });
    
    it('should return null if no CI/CD system is detected', async () => {
      mockGitService.getRemoteUrl.mockResolvedValue(null);
      mockConfigService.getCICDConfig.mockResolvedValue(null);
      
      const result = await cicdService.detectCICDSystem();
      
      expect(result).toBeNull();
    });
  });
  
  describe('getPipelineStatus', () => {
    it('should fetch GitHub Actions pipeline status', async () => {
      const mockPipelines: CICDPipeline[] = [
        {
          id: '123456789',
          name: 'Build and Test',
          status: PipelineStatus.SUCCESS,
          url: 'https://github.com/organization/repo/actions/runs/123456789',
          branch: 'main',
          commit: 'abcdef1234567890',
          triggeredBy: 'user',
          startedAt: new Date().toISOString(),
          finishedAt: new Date().toISOString()
        }
      ];
      
      mockGitHubAdapter.getPipelineStatus.mockResolvedValue(mockPipelines);
      
      const result = await cicdService.getPipelineStatus();
      
      expect(mockGitHubAdapter.getPipelineStatus).toHaveBeenCalled();
      expect(result).toEqual(mockPipelines);
    });
    
    it('should fetch GitLab CI pipeline status', async () => {
      mockConfigService.getCICDConfig.mockResolvedValue({
        type: 'gitlab-ci',
        project: 'group/project',
        baseUrl: 'https://gitlab.com',
        auth: {
          token: 'token'
        }
      });
      
      const mockPipelines: CICDPipeline[] = [
        {
          id: '123456',
          name: 'Pipeline',
          status: PipelineStatus.RUNNING,
          url: 'https://gitlab.com/group/project/-/pipelines/123456',
          branch: 'feature-branch',
          commit: 'abcdef1234567890',
          triggeredBy: 'user',
          startedAt: new Date().toISOString(),
          finishedAt: null
        }
      ];
      
      mockGitLabAdapter.getPipelineStatus.mockResolvedValue(mockPipelines);
      
      const result = await cicdService.getPipelineStatus();
      
      expect(mockGitLabAdapter.getPipelineStatus).toHaveBeenCalled();
      expect(result).toEqual(mockPipelines);
    });
    
    it('should throw error if CI/CD system type is not supported', async () => {
      mockConfigService.getCICDConfig.mockResolvedValue({
        type: 'unsupported' as any,
        project: 'project',
      });
      
      await expect(cicdService.getPipelineStatus()).rejects.toThrow(
        'Unsupported CI/CD system: unsupported'
      );
    });
  });
  
  describe('validateCommitMessage', () => {
    it('should validate commit message against CI rules', async () => {
      const rules: CICDRule[] = [
        {
          name: 'Conventional Commits',
          pattern: '^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .+$',
          message: 'Commit message must follow Conventional Commits format'
        },
        {
          name: 'No WIP commits',
          pattern: '^(?!WIP).+$',
          message: 'WIP commits are not allowed'
        }
      ];
      
      mockGitHubAdapter.getCommitMessageRules.mockResolvedValue(rules);
      
      const validResult = await cicdService.validateCommitMessage('feat(auth): implement login functionality');
      expect(validResult.valid).toBe(true);
      expect(validResult.errors).toEqual([]);
      
      const invalidResult = await cicdService.validateCommitMessage('WIP: implementing stuff');
      expect(invalidResult.valid).toBe(false);
      expect(invalidResult.errors).toHaveLength(2);
      expect(invalidResult.errors[0]).toEqual({
        rule: 'Conventional Commits',
        message: 'Commit message must follow Conventional Commits format'
      });
      expect(invalidResult.errors[1]).toEqual({
        rule: 'No WIP commits',
        message: 'WIP commits are not allowed'
      });
    });
  });
  
  describe('triggerPipeline', () => {
    it('should trigger a pipeline run', async () => {
      const pipelineId = '123456';
      mockGitHubAdapter.triggerPipeline.mockResolvedValue({
        id: pipelineId,
        name: 'Build and Test',
        status: PipelineStatus.PENDING,
        url: 'https://github.com/organization/repo/actions/runs/123456',
        branch: 'main',
        commit: 'abcdef1234567890',
        triggeredBy: 'user',
        startedAt: new Date().toISOString(),
        finishedAt: null
      });
      
      const result = await cicdService.triggerPipeline('workflow-name', { ref: 'main' });
      
      expect(mockGitHubAdapter.triggerPipeline).toHaveBeenCalledWith('workflow-name', { ref: 'main' });
      expect(result.id).toBe(pipelineId);
      expect(result.status).toBe(PipelineStatus.PENDING);
    });
  });
});
```

### 2. CICD Types
Create a file for CI/CD system types at `src/types/CICD.ts`:

```typescript
/**
 * Pipeline status enum representing common statuses across CI/CD systems
 */
export enum PipelineStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  SUCCESS = 'success',
  FAILURE = 'failure',
  CANCELED = 'canceled',
  SKIPPED = 'skipped',
  UNKNOWN = 'unknown'
}

/**
 * Pipeline job interface representing a CI/CD job
 */
export interface PipelineJob {
  id: string;
  name: string;
  status: PipelineStatus;
  url: string;
  startedAt: string | null;
  finishedAt: string | null;
  duration?: number;
}

/**
 * Pipeline interface representing a CI/CD pipeline run
 */
export interface CICDPipeline {
  id: string;
  name: string;
  status: PipelineStatus;
  url: string;
  branch: string;
  commit: string;
  triggeredBy: string;
  startedAt: string | null;
  finishedAt: string | null;
  jobs?: PipelineJob[];
}

/**
 * Commit message validation rule
 */
export interface CICDRule {
  name: string;
  pattern: string;
  message: string;
}

/**
 * Validation error for commit message
 */
export interface ValidationError {
  rule: string;
  message: string;
}

/**
 * Validation result for commit message
 */
export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

/**
 * Parameters for triggering a pipeline
 */
export interface TriggerParameters {
  ref?: string;
  variables?: Record<string, string>;
  [key: string]: any;
}

/**
 * Interface for CI/CD system adapters
 */
export interface CICDAdapter {
  initialize(): Promise<void>;
  getPipelineStatus(): Promise<CICDPipeline[]>;
  getCommitMessageRules(): Promise<CICDRule[]>;
  validateCommitMessage(message: string): Promise<ValidationResult>;
  triggerPipeline(name: string, params: TriggerParameters): Promise<CICDPipeline>;
}

/**
 * CI/CD system configuration structure
 */
export interface CICDConfig {
  type: 'github-actions' | 'gitlab-ci' | 'jenkins' | 'circle-ci';
  project: string;
  baseUrl?: string;
  auth?: {
    username?: string;
    token?: string;
  };
}
```

### 3. GitHub Actions Adapter Implementation
Create an adapter file at `src/adapters/GitHubActionsAdapter.ts`:

```typescript
import { ConfigService } from '../services/ConfigService';
import { 
  CICDAdapter, 
  CICDPipeline, 
  PipelineStatus, 
  CICDRule,
  ValidationResult,
  ValidationError,
  TriggerParameters,
  PipelineJob
} from '../types/CICD';
import axios from 'axios';

/**
 * GitHub Actions adapter implementing the CICDAdapter interface
 */
export class GitHubActionsAdapter implements CICDAdapter {
  private token: string | null = null;
  private owner: string | null = null;
  private repo: string | null = null;
  
  constructor(private configService: ConfigService) {}
  
  /**
   * Initialize the adapter with configuration
   */
  public async initialize(): Promise<void> {
    const config = await this.configService.getCICDConfig();
    
    if (config?.type !== 'github-actions') {
      throw new Error('Configuration is not for GitHub Actions');
    }
    
    this.token = config.auth?.token || null;
    
    // Parse owner and repo from project field (format: owner/repo)
    if (config.project) {
      const [owner, repo] = config.project.split('/');
      this.owner = owner;
      this.repo = repo;
    }
  }
  
  /**
   * Get pipeline status from GitHub Actions
   */
  public async getPipelineStatus(): Promise<CICDPipeline[]> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/actions/runs`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const runs = response.data.workflow_runs || [];
      
      return runs.map((run: any) => {
        let status = PipelineStatus.UNKNOWN;
        
        if (run.status === 'queued') status = PipelineStatus.PENDING;
        else if (run.status === 'in_progress') status = PipelineStatus.RUNNING;
        else if (run.status === 'completed' && run.conclusion === 'success') status = PipelineStatus.SUCCESS;
        else if (run.status === 'completed' && run.conclusion === 'failure') status = PipelineStatus.FAILURE;
        else if (run.status === 'completed' && run.conclusion === 'cancelled') status = PipelineStatus.CANCELED;
        else if (run.status === 'completed' && run.conclusion === 'skipped') status = PipelineStatus.SKIPPED;
        
        return {
          id: run.id.toString(),
          name: run.name || run.workflow_name || 'GitHub Actions Workflow',
          status,
          url: run.html_url,
          branch: run.head_branch,
          commit: run.head_sha,
          triggeredBy: run.actor?.login || 'unknown',
          startedAt: run.created_at,
          finishedAt: run.status === 'completed' ? run.updated_at : null
        };
      });
    } catch (error) {
      throw new Error(`Failed to fetch GitHub Actions workflows: ${error.message}`);
    }
  }
  
  /**
   * Get job details for a specific workflow run
   */
  public async getJobDetails(runId: string): Promise<PipelineJob[]> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/actions/runs/${runId}/jobs`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      const jobs = response.data.jobs || [];
      
      return jobs.map((job: any) => {
        let status = PipelineStatus.UNKNOWN;
        
        if (job.status === 'queued') status = PipelineStatus.PENDING;
        else if (job.status === 'in_progress') status = PipelineStatus.RUNNING;
        else if (job.status === 'completed' && job.conclusion === 'success') status = PipelineStatus.SUCCESS;
        else if (job.status === 'completed' && job.conclusion === 'failure') status = PipelineStatus.FAILURE;
        else if (job.status === 'completed' && job.conclusion === 'cancelled') status = PipelineStatus.CANCELED;
        else if (job.status === 'completed' && job.conclusion === 'skipped') status = PipelineStatus.SKIPPED;
        
        return {
          id: job.id.toString(),
          name: job.name,
          status,
          url: job.html_url,
          startedAt: job.started_at,
          finishedAt: job.completed_at,
          duration: job.completed_at && job.started_at 
            ? new Date(job.completed_at).getTime() - new Date(job.started_at).getTime() 
            : undefined
        };
      });
    } catch (error) {
      throw new Error(`Failed to fetch GitHub Actions jobs: ${error.message}`);
    }
  }
  
  /**
   * Get commit message validation rules from GitHub
   */
  public async getCommitMessageRules(): Promise<CICDRule[]> {
    await this.initialize();
    
    // First check if there's a commitlint.config.js file in the repo
    try {
      const response = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/contents/commitlint.config.js`,
        {
          headers: this.token 
            ? { Authorization: `token ${this.token}` } 
            : undefined
        }
      );
      
      // If file exists, return conventional commits rules
      if (response.status === 200) {
        return [
          {
            name: 'Conventional Commits',
            pattern: '^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .+$',
            message: 'Commit message must follow Conventional Commits format'
          },
          {
            name: 'Subject length',
            pattern: '^.{1,100}$',
            message: 'Commit subject must be 100 characters or less'
          }
        ];
      }
    } catch (error) {
      // File doesn't exist, continue with default rules
    }
    
    // Default rules
    return [
      {
        name: 'No empty message',
        pattern: '.+',
        message: 'Commit message cannot be empty'
      },
      {
        name: 'No WIP commits',
        pattern: '^(?!WIP).+$',
        message: 'WIP commits are not allowed'
      }
    ];
  }
  
  /**
   * Validate a commit message against rules
   */
  public async validateCommitMessage(message: string): Promise<ValidationResult> {
    const rules = await this.getCommitMessageRules();
    const errors: ValidationError[] = [];
    
    for (const rule of rules) {
      const regex = new RegExp(rule.pattern);
      if (!regex.test(message)) {
        errors.push({
          rule: rule.name,
          message: rule.message
        });
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  /**
   * Trigger a GitHub Actions workflow
   */
  public async triggerPipeline(workflowName: string, params: TriggerParameters): Promise<CICDPipeline> {
    await this.initialize();
    
    if (!this.owner || !this.repo) {
      throw new Error('GitHub repository information not configured');
    }
    
    if (!this.token) {
      throw new Error('GitHub token is required to trigger workflows');
    }
    
    try {
      // First, get workflow ID by name
      const workflowsResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/actions/workflows`,
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const workflows = workflowsResponse.data.workflows || [];
      const workflow = workflows.find((wf: any) => wf.name === workflowName);
      
      if (!workflow) {
        throw new Error(`Workflow '${workflowName}' not found`);
      }
      
      // Trigger the workflow
      const response = await axios.post(
        `https://api.github.com/repos/${this.owner}/${this.repo}/actions/workflows/${workflow.id}/dispatches`,
        {
          ref: params.ref || 'main',
          inputs: params.variables
        },
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      // GitHub API doesn't return the created workflow run directly
      // So we fetch the most recent run for this workflow
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for workflow to register
      
      const runsResponse = await axios.get(
        `https://api.github.com/repos/${this.owner}/${this.repo}/actions/workflows/${workflow.id}/runs`,
        {
          headers: { Authorization: `token ${this.token}` }
        }
      );
      
      const latestRun = runsResponse.data.workflow_runs[0];
      
      return {
        id: latestRun.id.toString(),
        name: latestRun.name || workflow.name,
        status: PipelineStatus.PENDING,
        url: latestRun.html_url,
        branch: params.ref || 'main',
        commit: latestRun.head_sha,
        triggeredBy: 'api',
        startedAt: new Date().toISOString(),
        finishedAt: null
      };
    } catch (error) {
      throw new Error(`Failed to trigger GitHub Actions workflow: ${error.message}`);
    }
  }
}
```

### 4. GitLab CI Adapter Implementation
Create an adapter file at `src/adapters/GitLabCIAdapter.ts`:

```typescript
import { ConfigService } from '../services/ConfigService';
import { 
  CICDAdapter, 
  CICDPipeline, 
  PipelineStatus, 
  CICDRule,
  ValidationResult,
  ValidationError,
  TriggerParameters,
  PipelineJob
} from '../types/CICD';
import axios from 'axios';

/**
 * GitLab CI adapter implementing the CICDAdapter interface
 */
export class GitLabCIAdapter implements CICDAdapter {
  private token: string | null = null;
  private baseUrl: string = 'https://gitlab.com';
  private projectId: string | null = null;
  
  constructor(private configService: ConfigService) {}
  
  /**
   * Initialize the adapter with configuration
   */
  public async initialize(): Promise<void> {
    const config = await this.configService.getCICDConfig();
    
    if (config?.type !== 'gitlab-ci') {
      throw new Error('Configuration is not for GitLab CI');
    }
    
    this.token = config.auth?.token || null;
    this.baseUrl = config.baseUrl || 'https://gitlab.com';
    
    // Project ID or path (can be numeric ID or group/project path)
    this.projectId = config.project || null;
  }
  
  /**
   * Get pipeline status from GitLab CI
   */
  public async getPipelineStatus(): Promise<CICDPipeline[]> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      const response = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/pipelines`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const pipelines = response.data || [];
      
      return await Promise.all(pipelines.map(async (pipeline: any) => {
        const detailsResponse = await axios.get(
          `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/pipelines/${pipeline.id}`,
          {
            headers: this.token 
              ? { 'PRIVATE-TOKEN': this.token } 
              : undefined
          }
        );
        
        const details = detailsResponse.data;
        
        let status = PipelineStatus.UNKNOWN;
        
        if (details.status === 'pending') status = PipelineStatus.PENDING;
        else if (details.status === 'running') status = PipelineStatus.RUNNING;
        else if (details.status === 'success') status = PipelineStatus.SUCCESS;
        else if (details.status === 'failed') status = PipelineStatus.FAILURE;
        else if (details.status === 'canceled') status = PipelineStatus.CANCELED;
        else if (details.status === 'skipped') status = PipelineStatus.SKIPPED;
        
        return {
          id: details.id.toString(),
          name: `Pipeline #${details.id}`,
          status,
          url: details.web_url,
          branch: details.ref,
          commit: details.sha,
          triggeredBy: details.user?.username || 'unknown',
          startedAt: details.created_at,
          finishedAt: details.finished_at
        };
      }));
    } catch (error) {
      throw new Error(`Failed to fetch GitLab CI pipelines: ${error.message}`);
    }
  }
  
  /**
   * Get job details for a specific pipeline
   */
  public async getJobDetails(pipelineId: string): Promise<PipelineJob[]> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    try {
      const response = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/pipelines/${pipelineId}/jobs`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      const jobs = response.data || [];
      
      return jobs.map((job: any) => {
        let status = PipelineStatus.UNKNOWN;
        
        if (job.status === 'pending') status = PipelineStatus.PENDING;
        else if (job.status === 'running') status = PipelineStatus.RUNNING;
        else if (job.status === 'success') status = PipelineStatus.SUCCESS;
        else if (job.status === 'failed') status = PipelineStatus.FAILURE;
        else if (job.status === 'canceled') status = PipelineStatus.CANCELED;
        else if (job.status === 'skipped') status = PipelineStatus.SKIPPED;
        
        return {
          id: job.id.toString(),
          name: job.name,
          status,
          url: job.web_url,
          startedAt: job.started_at,
          finishedAt: job.finished_at,
          duration: job.duration
        };
      });
    } catch (error) {
      throw new Error(`Failed to fetch GitLab CI jobs: ${error.message}`);
    }
  }
  
  /**
   * Get commit message validation rules from GitLab
   */
  public async getCommitMessageRules(): Promise<CICDRule[]> {
    await this.initialize();
    
    // Check if there's a .gitlab/merge_request_templates directory with templates
    try {
      const response = await axios.get(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/repository/tree?path=.gitlab/merge_request_templates`,
        {
          headers: this.token 
            ? { 'PRIVATE-TOKEN': this.token } 
            : undefined
        }
      );
      
      // If directory exists, return more specific rules
      if (response.status === 200 && response.data.length > 0) {
        return [
          {
            name: 'Descriptive commit',
            pattern: '^.{10,}$',
            message: 'Commit message must be at least 10 characters long'
          },
          {
            name: 'Issue reference',
            pattern: '(#\\d+|\\[\\w+-\\d+\\])',
            message: 'Commit should reference an issue (#123 or [PROJECT-123])'
          }
        ];
      }
    } catch (error) {
      // Directory doesn't exist, continue with default rules
    }
    
    // Default rules
    return [
      {
        name: 'No empty message',
        pattern: '.+',
        message: 'Commit message cannot be empty'
      },
      {
        name: 'No WIP commits',
        pattern: '^(?!WIP).+$',
        message: 'WIP commits are not allowed to be pushed directly'
      }
    ];
  }
  
  /**
   * Validate a commit message against rules
   */
  public async validateCommitMessage(message: string): Promise<ValidationResult> {
    const rules = await this.getCommitMessageRules();
    const errors: ValidationError[] = [];
    
    for (const rule of rules) {
      const regex = new RegExp(rule.pattern);
      if (!regex.test(message)) {
        errors.push({
          rule: rule.name,
          message: rule.message
        });
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  /**
   * Trigger a GitLab CI pipeline
   */
  public async triggerPipeline(name: string, params: TriggerParameters): Promise<CICDPipeline> {
    await this.initialize();
    
    if (!this.projectId) {
      throw new Error('GitLab project ID not configured');
    }
    
    if (!this.token) {
      throw new Error('GitLab token is required to trigger pipelines');
    }
    
    try {
      const response = await axios.post(
        `${this.baseUrl}/api/v4/projects/${encodeURIComponent(this.projectId)}/pipeline`,
        {
          ref: params.ref || 'main',
          variables: params.variables || {}
        },
        {
          headers: { 'PRIVATE-TOKEN': this.token }
        }
      );
      
      const pipeline = response.data;
      
      return {
        id: pipeline.id.toString(),
        name: `Pipeline #${pipeline.id}`,
        status: PipelineStatus.PENDING,
        url: `${this.baseUrl}/${this.projectId}/pipelines/${pipeline.id}`,
        branch: pipeline.ref,
        commit: pipeline.sha,
        triggeredBy: 'api',
        startedAt: pipeline.created_at,
        finishedAt: null
      };
    } catch (error) {
      throw new Error(`Failed to trigger GitLab CI pipeline: ${error.message}`);
    }
  }
}
```

### 5. Create CircleCI and Jenkins Adapters
Following similar patterns as the GitHub and GitLab adapters, create:

- `src/adapters/CircleCIAdapter.ts`
- `src/adapters/JenkinsCIAdapter.ts`

### 6. CICD Service Implementation
Create a service file at `src/services/CICDService.ts`:

```typescript
import { ConfigService } from './ConfigService';
import { GitService } from './GitService';
import { GitHubActionsAdapter } from '../adapters/GitHubActionsAdapter';
import { GitLabCIAdapter } from '../adapters/GitLabCIAdapter';
import { JenkinsCIAdapter } from '../adapters/JenkinsCIAdapter';
import { CircleCIAdapter } from '../adapters/CircleCIAdapter';
import { 
  CICDPipeline,
  PipelineStatus,
  CICDRule,
  ValidationResult,
  CICDAdapter,
  PipelineJob,
  TriggerParameters
} from '../types/CICD';

/**
 * Service for integrating with CI/CD systems
 */
export class CICDService {
  private activeAdapter: CICDAdapter | null = null;
  private cicdType: string | null = null;
  
  constructor(
    private configService: ConfigService,
    private gitService: GitService,
    private githubAdapter: GitHubActionsAdapter,
    private gitlabAdapter: GitLabCIAdapter,
    private jenkinsAdapter: JenkinsCIAdapter,
    private circleciAdapter: CircleCIAdapter
  ) {}
  
  /**
   * Detect the CI/CD system type based on repository URL and configuration
   */
  public async detectCICDSystem(): Promise<string | null> {
    // First check configuration
    const config = await this.configService.getCICDConfig();
    
    if (config?.type) {
      this.cicdType = config.type;
      return config.type;
    }
    
    // If not configured, try to detect from remote URL
    const remoteUrl = await this.gitService.getRemoteUrl();
    
    if (!remoteUrl) {
      return null;
    }
    
    if (remoteUrl.includes('github.com')) {
      this.cicdType = 'github-actions';
      return 'github-actions';
    }
    
    if (remoteUrl.includes('gitlab.com')) {
      this.cicdType = 'gitlab-ci';
      return 'gitlab-ci';
    }
    
    return null;
  }
  
  /**
   * Get the appropriate adapter for the current CI/CD system
   */
  private async getAdapter(): Promise<CICDAdapter> {
    if (!this.cicdType) {
      this.cicdType = await this.detectCICDSystem();
    }
    
    if (!this.cicdType) {
      throw new Error('No CI/CD system configured or detected');
    }
    
    switch (this.cicdType) {
      case 'github-actions':
        return this.githubAdapter;
      case 'gitlab-ci':
        return this.gitlabAdapter;
      case 'jenkins':
        return this.jenkinsAdapter;
      case 'circle-ci':
        return this.circleciAdapter;
      default:
        throw new Error(`Unsupported CI/CD system: ${this.cicdType}`);
    }
  }
  
  /**
   * Get the status of pipelines
   */
  public async getPipelineStatus(): Promise<CICDPipeline[]> {
    const adapter = await this.getAdapter();
    return adapter.getPipelineStatus();
  }
  
  /**
   * Get job details for a specific pipeline
   */
  public async getJobDetails(pipelineId: string): Promise<PipelineJob[]> {
    const adapter = await this.getAdapter();
    
    // Check if adapter has getJobDetails method
    if ('getJobDetails' in adapter && typeof adapter.getJobDetails === 'function') {
      return (adapter as any).getJobDetails(pipelineId);
    }
    
    throw new Error('Getting job details is not supported for this CI/CD system');
  }
  
  /**
   * Get commit message validation rules
   */
  public async getCommitMessageRules(): Promise<CICDRule[]> {
    const adapter = await this.getAdapter();
    return adapter.getCommitMessageRules();
  }
  
  /**
   * Validate a commit message against CI/CD rules
   */
  public async validateCommitMessage(message: string): Promise<ValidationResult> {
    const adapter = await this.getAdapter();
    return adapter.validateCommitMessage(message);
  }
  
  /**
   * Trigger a pipeline
   */
  public async triggerPipeline(
    name: string, 
    params: TriggerParameters = {}
  ): Promise<CICDPipeline> {
    const adapter = await this.getAdapter();
    return adapter.triggerPipeline(name, params);
  }
  
  /**
   * Get a human-readable status name
   */
  public getStatusName(status: PipelineStatus): string {
    switch (status) {
      case PipelineStatus.PENDING:
        return 'Pending';
      case PipelineStatus.RUNNING:
        return 'Running';
      case PipelineStatus.SUCCESS:
        return 'Success';
      case PipelineStatus.FAILURE:
        return 'Failed';
      case PipelineStatus.CANCELED:
        return 'Canceled';
      case PipelineStatus.SKIPPED:
        return 'Skipped';
      default:
        return 'Unknown';
    }
  }
  
  /**
   * Get a color for the status (for UI)
   */
  public getStatusColor(status: PipelineStatus): string {
    switch (status) {
      case PipelineStatus.PENDING:
        return 'yellow';
      case PipelineStatus.RUNNING:
        return 'blue';
      case PipelineStatus.SUCCESS:
        return 'green';
      case PipelineStatus.FAILURE:
        return 'red';
      case PipelineStatus.CANCELED:
        return 'gray';
      case PipelineStatus.SKIPPED:
        return 'gray';
      default:
        return 'white';
    }
  }
}
```

### 7. Create UI Component for Pipeline Status
Create a UI component file at `src/components/cicd/PipelineStatus.tsx`:

```typescript
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import { useCICDService } from '../../hooks/useCICDService';
import { CICDPipeline, PipelineStatus, PipelineJob } from '../../types/CICD';
import { Spinner } from '../feedback/Spinner';

interface PipelineStatusProps {
  onClose: () => void;
}

/**
 * Component for viewing CI/CD pipeline status
 */
export const PipelineStatus: React.FC<PipelineStatusProps> = ({ onClose }) => {
  const cicdService = useCICDService();
  const [pipelines, setPipelines] = useState<CICDPipeline[]>([]);
  const [selectedPipelineIndex, setSelectedPipelineIndex] = useState(0);
  const [jobs, setJobs] = useState<PipelineJob[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingJobs, setLoadingJobs] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [refreshInterval, setRefreshInterval] = useState<NodeJS.Timeout | null>(null);
  const [showJobs, setShowJobs] = useState(false);
  
  // Load pipelines
  const loadPipelines = async () => {
    try {
      setLoading(true);
      const pipelinesData = await cicdService.getPipelineStatus();
      setPipelines(pipelinesData);
      setError(null);
      
      // Load jobs for the first pipeline if available
      if (pipelinesData.length > 0) {
        await loadJobs(pipelinesData[0].id);
      }
    } catch (err) {
      setError(`Failed to load pipelines: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Load jobs for a specific pipeline
  const loadJobs = async (pipelineId: string) => {
    try {
      setLoadingJobs(true);
      const jobsData = await cicdService.getJobDetails(pipelineId);
      setJobs(jobsData);
    } catch (err) {
      setJobs([]);
      // Silently fail as not all CI/CD systems support job details
    } finally {
      setLoadingJobs(false);
    }
  };
  
  // Initial load
  useEffect(() => {
    loadPipelines();
    
    // Set up refresh interval
    const interval = setInterval(() => {
      loadPipelines();
    }, 30000); // Refresh every 30 seconds
    
    setRefreshInterval(interval);
    
    return () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    };
  }, []);
  
  // Handle user input
  useInput((input, key) => {
    if (key.escape || input === 'q') {
      onClose();
      return;
    }
    
    if (key.upArrow || input === 'k') {
      setSelectedPipelineIndex(prev => (prev > 0 ? prev - 1 : prev));
      if (pipelines[selectedPipelineIndex - 1]) {
        loadJobs(pipelines[selectedPipelineIndex - 1].id);
      }
    }
    
    if (key.downArrow || input === 'j') {
      setSelectedPipelineIndex(prev => 
        (prev < pipelines.length - 1 ? prev + 1 : prev)
      );
      if (pipelines[selectedPipelineIndex + 1]) {
        loadJobs(pipelines[selectedPipelineIndex + 1].id);
      }
    }
    
    if (key.return || input === ' ') {
      setShowJobs(!showJobs);
    }
    
    if (input === 'r') {
      loadPipelines();
    }
  });
  
  if (loading && pipelines.length === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Loading pipelines..." />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color="red">{error}</Text>
        <Text>Press any key to close</Text>
      </Box>
    );
  }
  
  if (pipelines.length === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text>No pipelines found.</Text>
        <Text>Press any key to close</Text>
      </Box>
    );
  }
  
  return (
    <Box flexDirection="column" padding={1}>
      <Box marginBottom={1}>
        <Text bold>Pipeline Status</Text>
        <Text dimColor> - Press R to refresh, Space to show/hide jobs, Q to quit</Text>
      </Box>
      
      {/* Pipeline List */}
      {pipelines.map((pipeline, index) => (
        <Box 
          key={pipeline.id} 
          flexDirection="row" 
          padding={1}
          backgroundColor={index === selectedPipelineIndex ? 'blue' : undefined}
        >
          <Box width={20}>
            <Text>{pipeline.name}</Text>
          </Box>
          <Box width={15}>
            <Text color={cicdService.getStatusColor(pipeline.status)}>
              {cicdService.getStatusName(pipeline.status)}
            </Text>
          </Box>
          <Box width={20}>
            <Text dimColor>{pipeline.branch}</Text>
          </Box>
          <Box>
            <Text dimColor>{new Date(pipeline.startedAt || '').toLocaleString()}</Text>
          </Box>
        </Box>
      ))}
      
      {/* Selected Pipeline Jobs */}
      {showJobs && selectedPipelineIndex >= 0 && pipelines[selectedPipelineIndex] && (
        <Box flexDirection="column" marginTop={1} borderStyle="single" padding={1}>
          <Text bold>Jobs for {pipelines[selectedPipelineIndex].name}</Text>
          
          {loadingJobs ? (
            <Spinner text="Loading jobs..." />
          ) : jobs.length === 0 ? (
            <Text>No job details available</Text>
          ) : (
            jobs.map(job => (
              <Box key={job.id} flexDirection="row" marginTop={1}>
                <Box width={25}>
                  <Text>{job.name}</Text>
                </Box>
                <Box width={15}>
                  <Text color={cicdService.getStatusColor(job.status)}>
                    {cicdService.getStatusName(job.status)}
                  </Text>
                </Box>
                <Box>
                  <Text dimColor>
                    {job.duration ? `${Math.floor(job.duration / 60)}m ${job.duration % 60}s` : 'N/A'}
                  </Text>
                </Box>
              </Box>
            ))
          )}
        </Box>
      )}
    </Box>
  );
};
```

### 8. Create CICD Hook
Create a custom hook at `src/hooks/useCICDService.ts`:

```typescript
import { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import { CICDService } from '../services/CICDService';

/**
 * Hook to access the CICDService instance
 */
export function useCICDService(): CICDService {
  const { services } = useContext(AppContext);
  
  if (!services.cicdService) {
    throw new Error('CICDService not available in context');
  }
  
  return services.cicdService;
}
```

### 9. Create CICD Command
Create a command file at `src/commands/cicd.ts`:

```typescript
import { Command } from '../types/Command';
import { render } from 'ink';
import React from 'react';
import { PipelineStatus } from '../components/cicd/PipelineStatus';
import { createAppContext } from '../context/createAppContext';

/**
 * Command for managing CI/CD integrations
 */
export const cicdCommand: Command = {
  name: 'cicd',
  description: 'Manage CI/CD integrations and view pipeline status',
  options: [
    {
      name: 'status',
      description: 'Show pipeline status',
      alias: 's',
      type: 'boolean'
    },
    {
      name: 'validate',
      description: 'Validate a commit message against CI/CD rules',
      alias: 'v',
      type: 'string'
    },
    {
      name: 'trigger',
      description: 'Trigger a CI/CD pipeline',
      alias: 't',
      type: 'string'
    },
    {
      name: 'branch',
      description: 'Branch for triggering pipeline',
      alias: 'b',
      type: 'string'
    }
  ],
  
  async execute(args, options): Promise<void> {
    const context = await createAppContext();
    const { cicdService } = context.services;
    
    // Validate commit message
    if (options.validate) {
      try {
        const validationResult = await cicdService.validateCommitMessage(options.validate);
        
        if (validationResult.valid) {
          console.log('✅ Commit message is valid according to CI/CD rules');
        } else {
          console.log('❌ Commit message has validation errors:');
          validationResult.errors.forEach(error => {
            console.log(`  - [${error.rule}] ${error.message}`);
          });
        }
      } catch (error) {
        console.error('❌ Failed to validate commit message:', error.message);
      }
      return;
    }
    
    // Trigger pipeline
    if (options.trigger) {
      try {
        const pipeline = await cicdService.triggerPipeline(options.trigger, {
          ref: options.branch
        });
        
        console.log(`✅ Pipeline triggered successfully: ${pipeline.name}`);
        console.log(`Status: ${cicdService.getStatusName(pipeline.status)}`);
        console.log(`URL: ${pipeline.url}`);
      } catch (error) {
        console.error('❌ Failed to trigger pipeline:', error.message);
      }
      return;
    }
    
    // Default: show status
    const { waitUntilExit } = render(
      React.createElement(
        PipelineStatus, 
        { onClose: () => process.exit(0) }
      )
    );
    
    await waitUntilExit();
  }
};
```

### 10. Update Commit Component to Validate Against CI Rules
Update the existing commit component to validate against CI/CD rules:

```typescript
// In the commit component where validation is needed
import { useCICDService } from '../../hooks/useCICDService';

// Add to the component state
const cicdService = useCICDService();
const [commitValid, setCommitValid] = useState(true);
const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);

// Add validation function
const validateCommitMessage = async (message: string) => {
  try {
    const result = await cicdService.validateCommitMessage(message);
    setCommitValid(result.valid);
    setValidationErrors(result.errors);
    return result.valid;
  } catch (error) {
    // Silently fail if CI/CD not configured
    setCommitValid(true);
    setValidationErrors([]);
    return true;
  }
};

// Update existing validation function to include CI/CD rules
const validateAndSubmit = async () => {
  // Other validation logic...
  
  // Validate against CI/CD rules
  const ciValid = await validateCommitMessage(fullCommitMessage);
  
  if (!ciValid) {
    // Show warning but allow override
    // ...
  }
  
  // Continue with submission
};

// Add validation errors to UI
{validationErrors.length > 0 && (
  <Box flexDirection="column" marginTop={1}>
    <Text color="yellow">⚠️ CI/CD Validation Warnings:</Text>
    {validationErrors.map((error, index) => (
      <Text key={index} color="yellow">
        - {error.message}
      </Text>
    ))}
  </Box>
)}
```

### 11. Update Core Exports
Update `src/index.ts` to include the CI/CD service:

```typescript
// Add to imports
import { CICDService } from './services/CICDService';
import { GitHubActionsAdapter } from './adapters/GitHubActionsAdapter';
import { GitLabCIAdapter } from './adapters/GitLabCIAdapter';
import { JenkinsCIAdapter } from './adapters/JenkinsCIAdapter';
import { CircleCIAdapter } from './adapters/CircleCIAdapter';
import { cicdCommand } from './commands/cicd';

// Add to commandRegistry
commandRegistry.register(cicdCommand);

// Add to service initialization
const githubAdapter = new GitHubActionsAdapter(configService);
const gitlabAdapter = new GitLabCIAdapter(configService);
const jenkinsAdapter = new JenkinsCIAdapter(configService);
const circleCIAdapter = new CircleCIAdapter(configService);

const cicdService = new CICDService(
  configService, 
  gitService,
  githubAdapter,
  gitlabAdapter,
  jenkinsAdapter,
  circleCIAdapter
);

// Add to context
context.services.cicdService = cicdService;
```

### 12. Update App Context Type
Update `src/context/AppContext.ts`:

```typescript
import { CICDService } from '../services/CICDService';

// Add to Services interface
export interface Services {
  // ... existing services
  cicdService: CICDService;
}
```

## Definition of Done
- CI/CD service implemented with adapter pattern supporting GitHub Actions, GitLab CI, Jenkins, and CircleCI
- Pipeline status visualization with job details
- Commit message validation against CI/CD rules
- Pipeline triggering capability
- Integration with existing commit workflow
- Documentation updated for CI/CD integration features

## Potential Blockers
- API rate limits for CI/CD systems
- Authentication complexity for different CI/CD platforms
- Differences in API structure between CI/CD systems
- Limited access to certain CI/CD systems from the CLI
- Network connectivity issues affecting API calls

## Next Steps
- Implement repository hosting integration (5.2.3)
- Create documentation generation (5.3.1)