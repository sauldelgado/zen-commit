# 4.2.3 Extended Notes Implementation

## Overview
This step implements an extended notes system that allows developers to attach detailed explanations and context to their commits. These notes go beyond the standard commit message, providing space for technical explanations, design decisions, future considerations, and references without cluttering the commit message itself. The system will store these notes alongside commit history and provide ways to view and manage them.

## Dependencies
- Local History Storage (4.1.1)
- Metadata Tagging System (4.2.1)
- Configuration Schema Definition (3.3.2)

## Prerequisites
- Working Local History Storage (4.1.1)
- Completed Metadata Tagging System (4.2.1)
- Completed Configuration Schema Definition (3.3.2)

## Implementation Order
1. Define extended notes data model
2. Create notes editor component
3. Implement notes storage service
4. Add notes viewing component
5. Integrate with commit flow

## Development Guidelines
- Provide a simple yet powerful text editor for notes
- Ensure notes are stored efficiently and linked to specific commits
- Design the system to work with or without Git hooks
- Support basic Markdown formatting in notes
- Maintain separation between commit messages and extended notes

## Tasks

### 1. Create Test File for Extended Notes Service
```typescript
// __tests__/services/extendedNotesService.test.ts
import { ExtendedNotesService } from '../../src/services/extendedNotesService';
import { CommitHistoryManager } from '../../src/services/historyManager';
import { ConfigurationManager } from '../../src/services/configurationManager';
import { Note } from '../../src/models/note';

// Mock the dependencies
jest.mock('../../src/services/historyManager');
jest.mock('../../src/services/configurationManager');

describe('ExtendedNotesService', () => {
  let notesService: ExtendedNotesService;
  let mockHistoryManager: jest.Mocked<CommitHistoryManager>;
  let mockConfigManager: jest.Mocked<ConfigurationManager>;
  
  const testNotes: Note[] = [
    {
      id: 'note1',
      commitId: 'commit1',
      content: 'This is a technical note about the implementation',
      createdAt: Date.now() - 86400000,
      updatedAt: Date.now() - 86400000,
      type: 'technical'
    },
    {
      id: 'note2',
      commitId: 'commit2',
      content: 'Design decision: We chose this approach because...',
      createdAt: Date.now() - 43200000,
      updatedAt: Date.now() - 43200000,
      type: 'design'
    }
  ];
  
  beforeEach(() => {
    mockHistoryManager = new CommitHistoryManager() as jest.Mocked<CommitHistoryManager>;
    mockConfigManager = new ConfigurationManager() as jest.Mocked<ConfigurationManager>;
    
    mockConfigManager.getConfiguration.mockResolvedValue({
      extendedNotes: {
        enabled: true,
        noteTypes: [
          { id: 'technical', label: 'Technical', color: 'blue' },
          { id: 'design', label: 'Design Decision', color: 'green' },
          { id: 'todo', label: 'TODO', color: 'yellow' },
          { id: 'context', label: 'Context', color: 'cyan' }
        ]
      }
    });
    
    mockHistoryManager.getMetadata.mockImplementation(async (commitId) => {
      if (commitId === 'commit1') {
        return { notes: ['note1'] };
      } else if (commitId === 'commit2') {
        return { notes: ['note2'] };
      }
      return {};
    });
    
    mockHistoryManager.addMetadata.mockResolvedValue(true);
    
    notesService = new ExtendedNotesService(mockHistoryManager, mockConfigManager);
    
    // Mock the file operations for notes storage
    jest.spyOn(notesService as any, 'readNote').mockImplementation(async (noteId) => {
      const note = testNotes.find(n => n.id === noteId);
      return note || null;
    });
    
    jest.spyOn(notesService as any, 'writeNote').mockResolvedValue(true);
    jest.spyOn(notesService as any, 'listNoteIds').mockResolvedValue(
      testNotes.map(note => note.id)
    );
  });
  
  test('should initialize with note types from configuration', async () => {
    await notesService.initialize();
    
    expect(notesService.isEnabled()).toBe(true);
    
    const types = notesService.getNoteTypes();
    expect(types).toHaveLength(4);
    expect(types[0].id).toBe('technical');
  });
  
  test('should create a note for a commit', async () => {
    await notesService.initialize();
    
    const newNote = {
      content: 'This is a new note',
      type: 'technical'
    };
    
    const note = await notesService.createNote('commit3', newNote);
    
    expect(note).toBeDefined();
    expect(note.commitId).toBe('commit3');
    expect(note.content).toBe(newNote.content);
    expect(note.type).toBe(newNote.type);
    expect(mockHistoryManager.addMetadata).toHaveBeenCalled();
  });
  
  test('should get notes for a commit', async () => {
    await notesService.initialize();
    
    const notes = await notesService.getNotesForCommit('commit1');
    
    expect(notes).toHaveLength(1);
    expect(notes[0].id).toBe('note1');
    expect(notes[0].commitId).toBe('commit1');
  });
  
  test('should update a note', async () => {
    await notesService.initialize();
    
    const updatedContent = 'Updated note content';
    const note = await notesService.updateNote('note1', { content: updatedContent });
    
    expect(note).toBeDefined();
    expect(note.content).toBe(updatedContent);
    expect(note.updatedAt).not.toBe(note.createdAt);
  });
  
  test('should delete a note', async () => {
    await notesService.initialize();
    
    const spy = jest.spyOn(notesService as any, 'deleteNote').mockResolvedValue(true);
    
    const result = await notesService.deleteNote('note1');
    
    expect(result).toBe(true);
    expect(spy).toHaveBeenCalledWith('note1');
  });
  
  test('should get all notes', async () => {
    await notesService.initialize();
    
    const notes = await notesService.getAllNotes();
    
    expect(notes).toHaveLength(2);
  });
  
  test('should search notes by content', async () => {
    await notesService.initialize();
    
    const notes = await notesService.searchNotes('design');
    
    expect(notes).toHaveLength(1);
    expect(notes[0].id).toBe('note2');
  });
  
  test('should filter notes by type', async () => {
    await notesService.initialize();
    
    const notes = await notesService.getNotesOfType('technical');
    
    expect(notes).toHaveLength(1);
    expect(notes[0].type).toBe('technical');
  });
  
  test('should disable notes if configuration disables it', async () => {
    mockConfigManager.getConfiguration.mockResolvedValue({
      extendedNotes: {
        enabled: false
      }
    });
    
    await notesService.initialize();
    
    expect(notesService.isEnabled()).toBe(false);
  });
});
```

### 2. Create Test File for Notes Editor Component
```typescript
// __tests__/components/notesEditor.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { NotesEditor } from '../../src/components/notesEditor';
import { ExtendedNotesService } from '../../src/services/extendedNotesService';
import { Note, NoteType } from '../../src/models/note';

// Mock the extended notes service
jest.mock('../../src/services/extendedNotesService');

describe('NotesEditor', () => {
  let mockNotesService: jest.Mocked<ExtendedNotesService>;
  
  const testNoteTypes: NoteType[] = [
    { id: 'technical', label: 'Technical', color: 'blue' },
    { id: 'design', label: 'Design Decision', color: 'green' },
    { id: 'todo', label: 'TODO', color: 'yellow' }
  ];
  
  const testNote: Note = {
    id: 'note1',
    commitId: 'commit1',
    content: 'This is a test note',
    createdAt: Date.now() - 86400000,
    updatedAt: Date.now() - 86400000,
    type: 'technical'
  };
  
  beforeEach(() => {
    mockNotesService = new ExtendedNotesService() as jest.Mocked<ExtendedNotesService>;
    
    mockNotesService.isEnabled.mockReturnValue(true);
    mockNotesService.getNoteTypes.mockReturnValue(testNoteTypes);
    mockNotesService.createNote.mockImplementation(async (commitId, note) => ({
      id: 'new-note-id',
      commitId,
      content: note.content,
      type: note.type,
      createdAt: Date.now(),
      updatedAt: Date.now()
    }));
    mockNotesService.updateNote.mockImplementation(async (noteId, updates) => ({
      ...testNote,
      ...updates,
      updatedAt: Date.now()
    }));
  });
  
  test('should render notes editor', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { lastFrame } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    expect(lastFrame()).toContain('Extended Notes');
    expect(lastFrame()).toContain('Type:');
  });
  
  test('should render editor with existing note', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { lastFrame } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        note={testNote}
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    expect(lastFrame()).toContain('Edit Note');
    expect(lastFrame()).toContain(testNote.content);
  });
  
  test('should save new note when submitted', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { stdin } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    // Type content and submit
    stdin.write('New note content\n');
    
    expect(mockNotesService.createNote).toHaveBeenCalledWith(
      'commit1',
      expect.objectContaining({
        content: 'New note content',
        type: expect.any(String)
      })
    );
    
    expect(onSave).toHaveBeenCalled();
  });
  
  test('should update existing note when submitted', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { stdin } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        note={testNote}
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    // Type updated content and submit
    stdin.write('Updated content\n');
    
    expect(mockNotesService.updateNote).toHaveBeenCalledWith(
      testNote.id,
      expect.objectContaining({
        content: 'Updated content'
      })
    );
    
    expect(onSave).toHaveBeenCalled();
  });
  
  test('should cancel editing when escape is pressed', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { stdin } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    // Press escape
    stdin.write('\u001B');
    
    expect(onCancel).toHaveBeenCalled();
    expect(onSave).not.toHaveBeenCalled();
  });
  
  test('should switch between note types', () => {
    const onSave = jest.fn();
    const onCancel = jest.fn();
    
    const { stdin, lastFrame } = render(
      <NotesEditor
        notesService={mockNotesService}
        commitId="commit1"
        onSave={onSave}
        onCancel={onCancel}
      />
    );
    
    // Tab to switch to type selection
    stdin.write('\t');
    
    // Check that type selection is active
    expect(lastFrame()).toContain('◉ Technical');
    
    // Select design type
    stdin.write('\n');
    
    // Tab back to content and submit
    stdin.write('\t');
    stdin.write('Note with design type\n');
    
    expect(mockNotesService.createNote).toHaveBeenCalledWith(
      'commit1',
      expect.objectContaining({
        content: 'Note with design type',
        type: 'design'
      })
    );
  });
});
```

### 3. Create Test File for Notes Viewer Component
```typescript
// __tests__/components/notesViewer.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { NotesViewer } from '../../src/components/notesViewer';
import { ExtendedNotesService } from '../../src/services/extendedNotesService';
import { Note } from '../../src/models/note';

// Mock the extended notes service
jest.mock('../../src/services/extendedNotesService');

describe('NotesViewer', () => {
  let mockNotesService: jest.Mocked<ExtendedNotesService>;
  
  const testNotes: Note[] = [
    {
      id: 'note1',
      commitId: 'commit1',
      content: 'This is a technical note about the implementation',
      createdAt: Date.now() - 86400000,
      updatedAt: Date.now() - 86400000,
      type: 'technical'
    },
    {
      id: 'note2',
      commitId: 'commit1',
      content: 'Design decision: We chose this approach because...',
      createdAt: Date.now() - 43200000,
      updatedAt: Date.now() - 43200000,
      type: 'design'
    }
  ];
  
  beforeEach(() => {
    mockNotesService = new ExtendedNotesService() as jest.Mocked<ExtendedNotesService>;
    
    mockNotesService.isEnabled.mockReturnValue(true);
    mockNotesService.getNotesForCommit.mockResolvedValue(testNotes);
    mockNotesService.getNoteTypes.mockReturnValue([
      { id: 'technical', label: 'Technical', color: 'blue' },
      { id: 'design', label: 'Design Decision', color: 'green' }
    ]);
    mockNotesService.deleteNote.mockResolvedValue(true);
  });
  
  test('should render notes for a commit', () => {
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    const { lastFrame } = render(
      <NotesViewer
        notesService={mockNotesService}
        commitId="commit1"
        onEdit={onEdit}
        onDelete={onDelete}
      />
    );
    
    // Initially show loading
    expect(lastFrame()).toContain('Loading notes');
    
    // After loading
    setTimeout(() => {
      expect(lastFrame()).toContain('Extended Notes for Commit');
      expect(lastFrame()).toContain('Technical');
      expect(lastFrame()).toContain('This is a technical note');
    }, 0);
  });
  
  test('should handle empty notes list', () => {
    mockNotesService.getNotesForCommit.mockResolvedValue([]);
    
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    const { lastFrame } = render(
      <NotesViewer
        notesService={mockNotesService}
        commitId="commit1"
        onEdit={onEdit}
        onDelete={onDelete}
      />
    );
    
    // After loading empty list
    setTimeout(() => {
      expect(lastFrame()).toContain('No notes available');
    }, 0);
  });
  
  test('should call onEdit when edit is selected', () => {
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    const { lastFrame, stdin } = render(
      <NotesViewer
        notesService={mockNotesService}
        commitId="commit1"
        onEdit={onEdit}
        onDelete={onDelete}
      />
    );
    
    // Wait for loading to complete
    setTimeout(() => {
      // Press e to edit
      stdin.write('e');
      
      expect(onEdit).toHaveBeenCalledWith(testNotes[0]);
    }, 0);
  });
  
  test('should call onDelete when delete is selected', () => {
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    const { lastFrame, stdin } = render(
      <NotesViewer
        notesService={mockNotesService}
        commitId="commit1"
        onEdit={onEdit}
        onDelete={onDelete}
      />
    );
    
    // Wait for loading to complete
    setTimeout(() => {
      // Press d to delete
      stdin.write('d');
      
      expect(onDelete).toHaveBeenCalledWith(testNotes[0]);
    }, 0);
  });
  
  test('should refresh notes after action', () => {
    const onEdit = jest.fn();
    const onDelete = jest.fn().mockImplementation(() => {
      // Simulate deleting a note
      mockNotesService.getNotesForCommit.mockResolvedValue([testNotes[1]]);
    });
    
    const { lastFrame, stdin } = render(
      <NotesViewer
        notesService={mockNotesService}
        commitId="commit1"
        onEdit={onEdit}
        onDelete={onDelete}
      />
    );
    
    // Wait for loading to complete
    setTimeout(() => {
      // Press d to delete
      stdin.write('d');
      
      // Wait for refresh
      setTimeout(() => {
        // Should only have one note now
        expect(lastFrame()).not.toContain('This is a technical note');
        expect(lastFrame()).toContain('Design decision');
      }, 0);
    }, 0);
  });
});
```

### 4. Define Note Data Model
```typescript
// src/models/note.ts
/**
 * Note type definition
 */
export interface NoteType {
  /** Unique identifier for the note type */
  id: string;
  /** Human-readable label for the note type */
  label: string;
  /** Color associated with this note type */
  color: string;
  /** Optional description of the note type */
  description?: string;
}

/**
 * Extended note for a commit
 */
export interface Note {
  /** Unique identifier for the note */
  id: string;
  /** Associated commit identifier */
  commitId: string;
  /** Note content */
  content: string;
  /** Creation timestamp */
  createdAt: number;
  /** Last update timestamp */
  updatedAt: number;
  /** Note type identifier */
  type: string;
}

/**
 * Input for creating a new note
 */
export interface NoteInput {
  /** Note content */
  content: string;
  /** Note type identifier */
  type: string;
}

/**
 * Input for updating an existing note
 */
export interface NoteUpdate {
  /** Updated note content */
  content?: string;
  /** Updated note type */
  type?: string;
}
```

### 5. Implement Extended Notes Service
```typescript
// src/services/extendedNotesService.ts
import * as path from 'path';
import * as fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import { CommitHistoryManager } from './historyManager';
import { ConfigurationManager } from './configurationManager';
import { Note, NoteType, NoteInput, NoteUpdate } from '../models/note';

/**
 * Service for managing extended notes for commits
 */
export class ExtendedNotesService {
  private enabled: boolean = true;
  private noteTypes: NoteType[] = [];
  private notesDir: string = path.join(process.cwd(), '.zen-commit', 'notes');
  private initialized: boolean = false;
  
  constructor(
    private historyManager: CommitHistoryManager,
    private configManager: ConfigurationManager
  ) {}
  
  /**
   * Initialize the service by loading configuration
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }
    
    const config = await this.configManager.getConfiguration();
    
    if (config.extendedNotes) {
      this.enabled = config.extendedNotes.enabled !== false;
      this.noteTypes = config.extendedNotes.noteTypes || [];
    }
    
    // Ensure notes directory exists
    await this.ensureNotesDirectory();
    
    this.initialized = true;
  }
  
  /**
   * Check if extended notes are enabled
   */
  isEnabled(): boolean {
    return this.enabled;
  }
  
  /**
   * Get all available note types
   */
  getNoteTypes(): NoteType[] {
    return this.noteTypes;
  }
  
  /**
   * Get a specific note type by ID
   * @param id Note type identifier
   */
  getNoteType(id: string): NoteType | undefined {
    return this.noteTypes.find(type => type.id === id);
  }
  
  /**
   * Create a new note for a commit
   * @param commitId Commit identifier
   * @param note Note input data
   */
  async createNote(commitId: string, note: NoteInput): Promise<Note> {
    if (!this.enabled) {
      throw new Error('Extended notes are disabled');
    }
    
    // Generate a unique ID for the note
    const id = uuidv4();
    const now = Date.now();
    
    // Create the note object
    const newNote: Note = {
      id,
      commitId,
      content: note.content,
      type: note.type,
      createdAt: now,
      updatedAt: now
    };
    
    // Write the note to disk
    await this.writeNote(id, newNote);
    
    // Update commit metadata to reference this note
    const metadata = await this.historyManager.getMetadata(commitId) || {};
    const notes = metadata.notes || [];
    notes.push(id);
    
    await this.historyManager.addMetadata(commitId, {
      ...metadata,
      notes
    });
    
    return newNote;
  }
  
  /**
   * Update an existing note
   * @param noteId Note identifier
   * @param updates Updates to apply
   */
  async updateNote(noteId: string, updates: NoteUpdate): Promise<Note> {
    if (!this.enabled) {
      throw new Error('Extended notes are disabled');
    }
    
    // Read the existing note
    const note = await this.readNote(noteId);
    if (!note) {
      throw new Error(`Note not found: ${noteId}`);
    }
    
    // Apply updates
    const updatedNote: Note = {
      ...note,
      content: updates.content !== undefined ? updates.content : note.content,
      type: updates.type !== undefined ? updates.type : note.type,
      updatedAt: Date.now()
    };
    
    // Write the updated note
    await this.writeNote(noteId, updatedNote);
    
    return updatedNote;
  }
  
  /**
   * Delete a note
   * @param noteId Note identifier
   */
  async deleteNote(noteId: string): Promise<boolean> {
    if (!this.enabled) {
      throw new Error('Extended notes are disabled');
    }
    
    // Read the note to get the commit ID
    const note = await this.readNote(noteId);
    if (!note) {
      return false;
    }
    
    // Update commit metadata to remove this note reference
    const metadata = await this.historyManager.getMetadata(note.commitId) || {};
    const notes = (metadata.notes || []).filter(id => id !== noteId);
    
    await this.historyManager.addMetadata(note.commitId, {
      ...metadata,
      notes
    });
    
    // Delete the note file
    const notePath = path.join(this.notesDir, `${noteId}.json`);
    try {
      await fs.unlink(notePath);
      return true;
    } catch (error) {
      console.error(`Failed to delete note file: ${notePath}`, error);
      return false;
    }
  }
  
  /**
   * Get all notes for a specific commit
   * @param commitId Commit identifier
   */
  async getNotesForCommit(commitId: string): Promise<Note[]> {
    if (!this.enabled) {
      return [];
    }
    
    // Get commit metadata
    const metadata = await this.historyManager.getMetadata(commitId) || {};
    const noteIds = metadata.notes || [];
    
    // Read all notes
    const notes: Note[] = [];
    for (const noteId of noteIds) {
      const note = await this.readNote(noteId);
      if (note) {
        notes.push(note);
      }
    }
    
    // Sort by creation date (newest first)
    return notes.sort((a, b) => b.createdAt - a.createdAt);
  }
  
  /**
   * Get a specific note by ID
   * @param noteId Note identifier
   */
  async getNote(noteId: string): Promise<Note | null> {
    if (!this.enabled) {
      return null;
    }
    
    return this.readNote(noteId);
  }
  
  /**
   * Get all notes
   */
  async getAllNotes(): Promise<Note[]> {
    if (!this.enabled) {
      return [];
    }
    
    const noteIds = await this.listNoteIds();
    const notes: Note[] = [];
    
    for (const noteId of noteIds) {
      const note = await this.readNote(noteId);
      if (note) {
        notes.push(note);
      }
    }
    
    // Sort by creation date (newest first)
    return notes.sort((a, b) => b.createdAt - a.createdAt);
  }
  
  /**
   * Search notes by content
   * @param searchTerm Search term
   */
  async searchNotes(searchTerm: string): Promise<Note[]> {
    if (!this.enabled) {
      return [];
    }
    
    const allNotes = await this.getAllNotes();
    
    // Filter notes by content
    return allNotes.filter(note => 
      note.content.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
  
  /**
   * Get notes of a specific type
   * @param typeId Note type identifier
   */
  async getNotesOfType(typeId: string): Promise<Note[]> {
    if (!this.enabled) {
      return [];
    }
    
    const allNotes = await this.getAllNotes();
    
    // Filter notes by type
    return allNotes.filter(note => note.type === typeId);
  }
  
  /**
   * Ensure the notes directory exists
   */
  private async ensureNotesDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.notesDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create notes directory:', error);
    }
  }
  
  /**
   * Read a note from disk
   * @param noteId Note identifier
   */
  private async readNote(noteId: string): Promise<Note | null> {
    const notePath = path.join(this.notesDir, `${noteId}.json`);
    
    try {
      const data = await fs.readFile(notePath, 'utf-8');
      return JSON.parse(data) as Note;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        console.error(`Failed to read note: ${notePath}`, error);
      }
      return null;
    }
  }
  
  /**
   * Write a note to disk
   * @param noteId Note identifier
   * @param note Note data
   */
  private async writeNote(noteId: string, note: Note): Promise<boolean> {
    const notePath = path.join(this.notesDir, `${noteId}.json`);
    
    try {
      await fs.writeFile(notePath, JSON.stringify(note, null, 2));
      return true;
    } catch (error) {
      console.error(`Failed to write note: ${notePath}`, error);
      return false;
    }
  }
  
  /**
   * List all note IDs in the notes directory
   */
  private async listNoteIds(): Promise<string[]> {
    try {
      const files = await fs.readdir(this.notesDir);
      return files
        .filter(file => file.endsWith('.json'))
        .map(file => file.replace('.json', ''));
    } catch (error) {
      console.error('Failed to list notes:', error);
      return [];
    }
  }
}
```

### 6. Implement Notes Editor Component
```typescript
// src/components/notesEditor.tsx
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import TextInput from 'ink-text-input';
import RadioInput from 'ink-radio-input';
import { ExtendedNotesService } from '../services/extendedNotesService';
import { Note, NoteType } from '../models/note';

interface NotesEditorProps {
  notesService: ExtendedNotesService;
  commitId: string;
  note?: Note;
  onSave: (note: Note) => void;
  onCancel: () => void;
}

/**
 * Component for creating and editing extended notes
 */
export const NotesEditor: React.FC<NotesEditorProps> = ({
  notesService,
  commitId,
  note,
  onSave,
  onCancel
}) => {
  const [content, setContent] = useState(note?.content || '');
  const [selectedType, setSelectedType] = useState(note?.type || '');
  const [focusField, setFocusField] = useState<'content' | 'type'>('content');
  const [saving, setSaving] = useState(false);
  const noteTypes = notesService.getNoteTypes();
  
  // Set initial type if none selected
  useEffect(() => {
    if (!selectedType && noteTypes.length > 0) {
      setSelectedType(noteTypes[0].id);
    }
  }, [selectedType, noteTypes]);
  
  // Handle keyboard input
  useInput((input, key) => {
    // Tab to switch focus between fields
    if (key.tab) {
      setFocusField(focusField === 'content' ? 'type' : 'content');
    }
    
    // Escape to cancel
    if (key.escape) {
      onCancel();
    }
    
    // Ctrl+S to save
    if (key.ctrl && input === 's') {
      handleSave();
    }
  });
  
  // Handle content submission
  const handleContentSubmit = () => {
    if (focusField === 'content') {
      handleSave();
    }
  };
  
  // Handle note type selection
  const handleTypeSelect = (value: string) => {
    setSelectedType(value);
  };
  
  // Save the note
  const handleSave = async () => {
    if (saving || !content.trim() || !selectedType) {
      return;
    }
    
    setSaving(true);
    
    try {
      let savedNote;
      
      if (note) {
        // Update existing note
        savedNote = await notesService.updateNote(note.id, {
          content,
          type: selectedType
        });
      } else {
        // Create new note
        savedNote = await notesService.createNote(commitId, {
          content,
          type: selectedType
        });
      }
      
      onSave(savedNote);
    } catch (error) {
      console.error('Failed to save note:', error);
      // Could show error UI here
    } finally {
      setSaving(false);
    }
  };
  
  // Find the selected note type
  const selectedNoteType = noteTypes.find(type => type.id === selectedType);
  
  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>{note ? 'Edit Note' : 'Extended Notes'}</Text>
        {selectedNoteType && (
          <Text color={selectedNoteType.color}> ({selectedNoteType.label})</Text>
        )}
      </Box>
      
      {focusField === 'content' ? (
        <Box flexDirection="column" marginBottom={1}>
          <Text bold>Content:</Text>
          <TextInput
            value={content}
            onChange={setContent}
            onSubmit={handleContentSubmit}
            placeholder="Enter your detailed notes here..."
          />
        </Box>
      ) : (
        <Box flexDirection="column" marginBottom={1}>
          <Text bold dimColor>Content: {content.substring(0, 30)}{content.length > 30 ? '...' : ''}</Text>
        </Box>
      )}
      
      {focusField === 'type' ? (
        <Box flexDirection="column">
          <Text bold>Type:</Text>
          <RadioInput
            value={selectedType}
            onChange={handleTypeSelect}
            options={noteTypes.map(type => ({
              label: type.label,
              value: type.id
            }))}
          />
        </Box>
      ) : (
        <Box>
          <Text bold>Type: </Text>
          <Text color={selectedNoteType?.color || 'white'}>
            {selectedNoteType?.label || 'None selected'}
          </Text>
        </Box>
      )}
      
      <Box marginTop={2}>
        <Text dimColor>Tab: Switch fields • Esc: Cancel • Enter/Ctrl+S: Save</Text>
      </Box>
      
      {saving && (
        <Box marginTop={1}>
          <Text>Saving...</Text>
        </Box>
      )}
    </Box>
  );
};
```

### 7. Implement Notes Viewer Component
```typescript
// src/components/notesViewer.tsx
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import SelectInput from 'ink-select-input';
import { ExtendedNotesService } from '../services/extendedNotesService';
import { Note } from '../models/note';

interface NotesViewerProps {
  notesService: ExtendedNotesService;
  commitId: string;
  onEdit: (note: Note) => void;
  onDelete: (note: Note) => void;
  onAddNew?: () => void;
}

/**
 * Component for viewing notes attached to a commit
 */
export const NotesViewer: React.FC<NotesViewerProps> = ({
  notesService,
  commitId,
  onEdit,
  onDelete,
  onAddNew
}) => {
  const [notes, setNotes] = useState<Note[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedNote, setSelectedNote] = useState<Note | null>(null);
  
  // Load notes for the commit
  const loadNotes = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const commitNotes = await notesService.getNotesForCommit(commitId);
      setNotes(commitNotes);
      setSelectedNote(commitNotes.length > 0 ? commitNotes[0] : null);
    } catch (err) {
      setError('Failed to load notes');
      console.error('Error loading notes:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Load notes on mount and when commitId changes
  useEffect(() => {
    loadNotes();
  }, [commitId, notesService]);
  
  // Handle keyboard input
  useInput((input, key) => {
    if (!selectedNote) return;
    
    // Edit selected note
    if (input === 'e') {
      onEdit(selectedNote);
    }
    
    // Delete selected note
    if (input === 'd') {
      handleDelete(selectedNote);
    }
    
    // Add new note
    if (input === 'n' && onAddNew) {
      onAddNew();
    }
  });
  
  // Handle note selection
  const handleSelect = (item: { value: Note }) => {
    setSelectedNote(item.value);
  };
  
  // Handle note deletion
  const handleDelete = async (note: Note) => {
    onDelete(note);
    
    // Refresh notes after deletion
    await loadNotes();
  };
  
  // Format notes for display
  const items = notes.map(note => {
    const noteType = notesService.getNoteType(note.type);
    const truncatedContent = note.content.length > 50 
      ? `${note.content.substring(0, 50)}...` 
      : note.content;
    
    return {
      key: note.id,
      label: truncatedContent,
      value: note,
      meta: {
        type: noteType?.label || note.type,
        color: noteType?.color || 'white',
        date: new Date(note.updatedAt).toLocaleDateString()
      }
    };
  });
  
  // If loading, show loading state
  if (loading) {
    return (
      <Box>
        <Text>Loading notes...</Text>
      </Box>
    );
  }
  
  // If error, show error state
  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }
  
  // If no notes, show empty state
  if (notes.length === 0) {
    return (
      <Box flexDirection="column">
        <Text>No notes available for this commit.</Text>
        {onAddNew && (
          <Text dimColor marginTop={1}>Press 'n' to add a new note</Text>
        )}
      </Box>
    );
  }
  
  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Extended Notes for Commit</Text>
      </Box>
      
      <Box flexDirection="column" height={10}>
        <SelectInput
          items={items}
          onSelect={handleSelect}
          itemComponent={({ item, isSelected }) => (
            <Box flexDirection="column">
              <Box>
                <Text color={item.meta.color} bold={true}>
                  {item.meta.type}:
                </Text>
                <Text bold={isSelected}> {item.label}</Text>
              </Box>
              <Text dimColor>Last updated: {item.meta.date}</Text>
            </Box>
          )}
        />
      </Box>
      
      {selectedNote && (
        <Box flexDirection="column" marginTop={1} borderStyle="round" paddingX={1} paddingY={1}>
          <Text>{selectedNote.content}</Text>
        </Box>
      )}
      
      <Box marginTop={1}>
        <Text dimColor>e: Edit • d: Delete {onAddNew ? '• n: New Note' : ''}</Text>
      </Box>
    </Box>
  );
};
```

### 8. Create Notes Factory
```typescript
// src/factories/notesFactory.ts
import { ExtendedNotesService } from '../services/extendedNotesService';
import { createHistoryManager } from './historyFactory';
import { createConfigurationManager } from './configurationFactory';

/**
 * Creates a configured extended notes service
 */
export function createExtendedNotesService(): ExtendedNotesService {
  const historyManager = createHistoryManager();
  const configManager = createConfigurationManager();
  const notesService = new ExtendedNotesService(historyManager, configManager);
  
  // Initialize the service (this is async, but we return the service immediately)
  notesService.initialize().catch(err => {
    console.error('Failed to initialize extended notes service:', err);
  });
  
  return notesService;
}
```

### 9. Integrate with Commit Flow
```typescript
// src/components/commitDetails.tsx
import React, { useState } from 'react';
import { Box, Text, useInput } from 'ink';
import { GitOperationsService } from '../services/gitOperations';
import { ExtendedNotesService } from '../services/extendedNotesService';
import { NotesViewer } from './notesViewer';
import { NotesEditor } from './notesEditor';
import { createExtendedNotesService } from '../factories/notesFactory';
import { Note } from '../models/note';

interface CommitDetailsProps {
  commitId: string;
  gitService: GitOperationsService;
  onBack: () => void;
}

/**
 * Component for viewing commit details with extended notes
 */
export const CommitDetails: React.FC<CommitDetailsProps> = ({
  commitId,
  gitService,
  onBack
}) => {
  const [commit, setCommit] = useState<any | null>(null);
  const [loading, setLoading] = useState(true);
  const [mode, setMode] = useState<'details' | 'notes' | 'edit'>('details');
  const [noteToEdit, setNoteToEdit] = useState<Note | null>(null);
  const [notesService] = useState<ExtendedNotesService>(createExtendedNotesService());
  
  // Load commit details on mount
  React.useEffect(() => {
    const loadCommit = async () => {
      setLoading(true);
      try {
        const commitDetails = await gitService.getCommitDetails(commitId);
        setCommit(commitDetails);
      } catch (error) {
        console.error('Failed to load commit details:', error);
      } finally {
        setLoading(false);
      }
    };
    
    loadCommit();
  }, [commitId, gitService]);
  
  // Handle keyboard input
  useInput((input, key) => {
    if (mode === 'details') {
      // In details mode, 'n' switches to notes view
      if (input === 'n') {
        setMode('notes');
      }
      
      // 'b' or Escape goes back
      if (input === 'b' || key.escape) {
        onBack();
      }
    } else if (mode === 'notes') {
      // In notes mode, 'b' or Escape goes back to details
      if (input === 'b' || key.escape) {
        setMode('details');
      }
    }
  });
  
  // Handle note editing
  const handleEditNote = (note: Note) => {
    setNoteToEdit(note);
    setMode('edit');
  };
  
  // Handle note deletion
  const handleDeleteNote = async (note: Note) => {
    try {
      await notesService.deleteNote(note.id);
      // Stay in notes mode, the viewer will refresh
    } catch (error) {
      console.error('Failed to delete note:', error);
    }
  };
  
  // Handle adding a new note
  const handleAddNote = () => {
    setNoteToEdit(null);
    setMode('edit');
  };
  
  // Handle note save completion
  const handleNoteSaved = () => {
    setMode('notes');
  };
  
  // Handle canceling note editing
  const handleCancelEdit = () => {
    setMode('notes');
  };
  
  // If loading, show loading state
  if (loading) {
    return (
      <Box>
        <Text>Loading commit details...</Text>
      </Box>
    );
  }
  
  // If no commit found, show error state
  if (!commit) {
    return (
      <Box>
        <Text color="red">Commit not found: {commitId}</Text>
      </Box>
    );
  }
  
  // In edit mode, show note editor
  if (mode === 'edit') {
    return (
      <NotesEditor
        notesService={notesService}
        commitId={commitId}
        note={noteToEdit || undefined}
        onSave={handleNoteSaved}
        onCancel={handleCancelEdit}
      />
    );
  }
  
  // In notes mode, show notes viewer
  if (mode === 'notes') {
    return (
      <NotesViewer
        notesService={notesService}
        commitId={commitId}
        onEdit={handleEditNote}
        onDelete={handleDeleteNote}
        onAddNew={handleAddNote}
      />
    );
  }
  
  // In details mode, show commit details
  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Commit Details</Text>
      </Box>
      
      <Box flexDirection="column" marginLeft={2}>
        <Box>
          <Text bold>ID: </Text>
          <Text>{commit.hash}</Text>
        </Box>
        <Box>
          <Text bold>Author: </Text>
          <Text>{commit.author}</Text>
        </Box>
        <Box>
          <Text bold>Date: </Text>
          <Text>{new Date(commit.date).toLocaleString()}</Text>
        </Box>
        <Box flexDirection="column" marginTop={1}>
          <Text bold>Message:</Text>
          <Text>{commit.message}</Text>
        </Box>
      </Box>
      
      <Box marginTop={2}>
        <Text dimColor>n: View Notes • b: Back</Text>
      </Box>
    </Box>
  );
};
```

### 10. Update Configuration Schema
```typescript
// src/models/configuration.ts
import { NoteType } from './note';

export interface Configuration {
  // Existing configuration properties...
  
  /**
   * Extended notes configuration
   */
  extendedNotes?: {
    /** Whether extended notes are enabled */
    enabled: boolean;
    /** Available note types */
    noteTypes: NoteType[];
  };
}
```

### 11. Update Default Configuration
```typescript
// src/config/defaults.ts
export const defaultConfiguration = {
  // Existing default configuration...
  
  extendedNotes: {
    enabled: true,
    noteTypes: [
      {
        id: 'technical',
        label: 'Technical',
        color: 'blue',
        description: 'Implementation details, technical decisions, and constraints'
      },
      {
        id: 'design',
        label: 'Design Decision',
        color: 'green',
        description: 'Design patterns, architecture choices, and UI/UX decisions'
      },
      {
        id: 'todo',
        label: 'TODO',
        color: 'yellow',
        description: 'Pending tasks, future improvements, and follow-up items'
      },
      {
        id: 'context',
        label: 'Context',
        color: 'cyan',
        description: 'Background information, business context, and requirements'
      },
      {
        id: 'review',
        label: 'Review Notes',
        color: 'magenta',
        description: 'Notes for reviewers, explanations of complex changes'
      }
    ]
  }
};
```

### 12. Update Main Exports
```typescript
// src/services/index.ts
export * from './extendedNotesService';
// ... other exports
```

```typescript
// src/components/index.ts
export * from './notesEditor';
export * from './notesViewer';
// ... other exports
```

```typescript
// src/factories/index.ts
export * from './notesFactory';
// ... other exports
```

```typescript
// src/models/index.ts
export * from './note';
// ... other exports
```

## Definition of Done
- The extended notes system allows creating, editing, and deleting detailed notes
- Notes are associated with commits and stored persistently
- The UI provides a seamless experience for working with notes
- Notes support different types and categorization
- The system can be configured via the configuration system
- All test cases pass and achieve adequate coverage

## Potential Blockers
- Storage mechanism needs to work efficiently with Git workflow
- Ensuring notes don't interfere with normal Git operations
- Terminal UI limitations for long-form text editing

## Next Steps
- Startup Time Optimizations (4.3.1)
- Large Repository Handling (4.3.2)