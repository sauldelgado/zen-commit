# 5.3.1 Documentation Generation

## Overview
This step implements an automated documentation generation system that creates both API documentation and user guides based on the application's code and commit history. The generated documentation will provide insights into the project's structure, API, and commit patterns, helping developers understand the codebase and establishing best practices for commits.

## Dependencies
- Phase 3.3 - Configuration System
- Phase 4.1 - History Management
- Phase 5.1.1 - Analytics Dashboard

## Prerequisites
- Configuration file parser (3.3.1)
- Local history storage (4.1.1)
- Analytics dashboard implementation (5.1.1)

## Implementation Order
1. Define documentation schema and templates
2. Implement code documentation generator
3. Create commit pattern documentation
4. Develop project structure analyzer
5. Build Markdown generation system
6. Implement HTML export capability
7. Create documentation command interface

## Development Guidelines
- Use TypeScript JSDoc comments for API documentation
- Create templates for consistent documentation format
- Support multiple output formats (Markdown, HTML)
- Integrate with existing code analysis tools
- Generate documentation that highlights best practices
- Support customization of documentation templates

## Detailed Tasks

### 1. Test File Creation
Create a test file at `src/__tests__/services/DocumentationService.test.ts`:

```typescript
import { DocumentationService } from '../../services/DocumentationService';
import { ConfigService } from '../../services/ConfigService';
import { GitService } from '../../services/GitService';
import { HistoryService } from '../../services/HistoryService';
import { AnalyticsService } from '../../services/AnalyticsService';
import { 
  DocumentationOptions, 
  DocumentationType,
  DocumentationFormat
} from '../../types/Documentation';
import fs from 'fs';
import path from 'path';

jest.mock('../../services/ConfigService');
jest.mock('../../services/GitService');
jest.mock('../../services/HistoryService');
jest.mock('../../services/AnalyticsService');
jest.mock('fs');
jest.mock('path');

describe('DocumentationService', () => {
  let documentationService: DocumentationService;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockGitService: jest.Mocked<GitService>;
  let mockHistoryService: jest.Mocked<HistoryService>;
  let mockAnalyticsService: jest.Mocked<AnalyticsService>;
  
  beforeEach(() => {
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    mockGitService = new GitService() as jest.Mocked<GitService>;
    mockHistoryService = new HistoryService(
      mockConfigService, 
      mockGitService
    ) as jest.Mocked<HistoryService>;
    mockAnalyticsService = new AnalyticsService(
      mockHistoryService
    ) as jest.Mocked<AnalyticsService>;
    
    documentationService = new DocumentationService(
      mockConfigService,
      mockGitService,
      mockHistoryService,
      mockAnalyticsService
    );
    
    // Mock fs.existsSync
    (fs.existsSync as jest.Mock).mockReturnValue(true);
    
    // Mock fs.mkdirSync
    (fs.mkdirSync as jest.Mock).mockImplementation(() => {});
    
    // Mock fs.writeFileSync
    (fs.writeFileSync as jest.Mock).mockImplementation(() => {});
    
    // Mock path.resolve
    (path.resolve as jest.Mock).mockImplementation((...args) => args.join('/'));
  });
  
  describe('generateDocumentation', () => {
    it('should generate API documentation', async () => {
      const options: DocumentationOptions = {
        types: [DocumentationType.API],
        format: DocumentationFormat.MARKDOWN,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: false
      };
      
      // Mock implementation
      const mockSourceFiles = [
        {
          fileName: 'src/services/GitService.ts',
          classes: [
            {
              name: 'GitService',
              description: 'Service for interacting with Git',
              methods: [
                {
                  name: 'commit',
                  description: 'Creates a commit',
                  parameters: [
                    {
                      name: 'message',
                      type: 'string',
                      description: 'Commit message'
                    }
                  ],
                  returnType: 'Promise<boolean>',
                  returnDescription: 'True if commit was successful'
                }
              ]
            }
          ]
        }
      ];
      
      // Mock file system operations
      jest.spyOn(documentationService as any, 'parseSourceFiles').mockResolvedValue(mockSourceFiles);
      jest.spyOn(documentationService as any, 'generateMarkdownForAPI').mockReturnValue('# API Documentation');
      
      const result = await documentationService.generateDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toContain('./docs/api.md');
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        './docs/api.md',
        '# API Documentation',
        'utf-8'
      );
    });
    
    it('should generate commit pattern documentation', async () => {
      const options: DocumentationOptions = {
        types: [DocumentationType.COMMIT_PATTERNS],
        format: DocumentationFormat.MARKDOWN,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: true
      };
      
      // Mock history service
      mockHistoryService.getCommitHistory.mockResolvedValue([
        {
          hash: 'abc123',
          message: 'feat(auth): implement login functionality',
          author: 'User',
          date: new Date().toISOString()
        },
        {
          hash: 'def456',
          message: 'fix(auth): resolve login error',
          author: 'User',
          date: new Date().toISOString()
        }
      ]);
      
      // Mock analytics service
      mockAnalyticsService.analyzeCommitTypes.mockResolvedValue({
        types: {
          feat: 1,
          fix: 1
        },
        total: 2
      });
      
      // Mock file system operations
      jest.spyOn(documentationService as any, 'generateMarkdownForCommitPatterns').mockReturnValue(
        '# Commit Pattern Documentation'
      );
      
      const result = await documentationService.generateDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toContain('./docs/commit-patterns.md');
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        './docs/commit-patterns.md',
        '# Commit Pattern Documentation',
        'utf-8'
      );
    });
    
    it('should generate project structure documentation', async () => {
      const options: DocumentationOptions = {
        types: [DocumentationType.PROJECT_STRUCTURE],
        format: DocumentationFormat.MARKDOWN,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: false
      };
      
      // Mock file system operations
      jest.spyOn(documentationService as any, 'analyzeProjectStructure').mockResolvedValue({
        rootDir: './src',
        directories: [
          {
            name: 'services',
            files: ['GitService.ts', 'ConfigService.ts']
          },
          {
            name: 'components',
            files: ['CommitForm.tsx', 'App.tsx']
          }
        ]
      });
      
      jest.spyOn(documentationService as any, 'generateMarkdownForProjectStructure').mockReturnValue(
        '# Project Structure Documentation'
      );
      
      const result = await documentationService.generateDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toContain('./docs/project-structure.md');
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        './docs/project-structure.md',
        '# Project Structure Documentation',
        'utf-8'
      );
    });
    
    it('should generate user guide documentation', async () => {
      const options: DocumentationOptions = {
        types: [DocumentationType.USER_GUIDE],
        format: DocumentationFormat.MARKDOWN,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: false
      };
      
      // Mock config service
      mockConfigService.getCommitTypeDescriptions.mockResolvedValue([
        { type: 'feat', description: 'A new feature' },
        { type: 'fix', description: 'A bug fix' }
      ]);
      
      // Mock file system operations
      jest.spyOn(documentationService as any, 'generateMarkdownForUserGuide').mockReturnValue(
        '# User Guide'
      );
      
      const result = await documentationService.generateDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toContain('./docs/user-guide.md');
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        './docs/user-guide.md',
        '# User Guide',
        'utf-8'
      );
    });
    
    it('should generate HTML documentation', async () => {
      const options: DocumentationOptions = {
        types: [DocumentationType.API],
        format: DocumentationFormat.HTML,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: false
      };
      
      // Mock file system operations
      jest.spyOn(documentationService as any, 'parseSourceFiles').mockResolvedValue([]);
      jest.spyOn(documentationService as any, 'generateMarkdownForAPI').mockReturnValue('# API Documentation');
      jest.spyOn(documentationService as any, 'convertMarkdownToHtml').mockReturnValue('<h1>API Documentation</h1>');
      
      const result = await documentationService.generateDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toContain('./docs/api.html');
      expect(fs.writeFileSync).toHaveBeenCalledWith(
        './docs/api.html',
        '<h1>API Documentation</h1>',
        'utf-8'
      );
    });
  });
  
  describe('generateAllDocumentation', () => {
    it('should generate all documentation types', async () => {
      const options: DocumentationOptions = {
        types: [
          DocumentationType.API,
          DocumentationType.COMMIT_PATTERNS,
          DocumentationType.PROJECT_STRUCTURE,
          DocumentationType.USER_GUIDE
        ],
        format: DocumentationFormat.MARKDOWN,
        outputDir: './docs',
        projectName: 'Test Project',
        includeCommitPatterns: true
      };
      
      // Mock implementations
      jest.spyOn(documentationService, 'generateDocumentation').mockResolvedValue({
        success: true,
        outputFiles: ['./docs/api.md', './docs/commit-patterns.md', './docs/project-structure.md', './docs/user-guide.md']
      });
      
      const result = await documentationService.generateAllDocumentation(options);
      
      expect(result.success).toBe(true);
      expect(result.outputFiles).toHaveLength(4);
    });
  });
});
```

### 2. Documentation Types
Create a file for documentation types at `src/types/Documentation.ts`:

```typescript
/**
 * Types of documentation that can be generated
 */
export enum DocumentationType {
  API = 'api',
  COMMIT_PATTERNS = 'commit-patterns',
  PROJECT_STRUCTURE = 'project-structure',
  USER_GUIDE = 'user-guide'
}

/**
 * Output formats for documentation
 */
export enum DocumentationFormat {
  MARKDOWN = 'markdown',
  HTML = 'html'
}

/**
 * Options for documentation generation
 */
export interface DocumentationOptions {
  types: DocumentationType[];
  format: DocumentationFormat;
  outputDir: string;
  projectName: string;
  includeCommitPatterns?: boolean;
  customTemplateDir?: string;
}

/**
 * Result of documentation generation
 */
export interface DocumentationResult {
  success: boolean;
  outputFiles: string[];
  error?: string;
}

/**
 * Structure for parsed source file
 */
export interface ParsedSourceFile {
  fileName: string;
  classes: ParsedClass[];
  interfaces: ParsedInterface[];
  functions: ParsedFunction[];
  types: ParsedType[];
}

/**
 * Structure for parsed class
 */
export interface ParsedClass {
  name: string;
  description: string;
  methods: ParsedMethod[];
  properties: ParsedProperty[];
}

/**
 * Structure for parsed interface
 */
export interface ParsedInterface {
  name: string;
  description: string;
  properties: ParsedProperty[];
  methods: ParsedMethod[];
}

/**
 * Structure for parsed function
 */
export interface ParsedFunction {
  name: string;
  description: string;
  parameters: ParsedParameter[];
  returnType: string;
  returnDescription: string;
}

/**
 * Structure for parsed method
 */
export interface ParsedMethod {
  name: string;
  description: string;
  parameters: ParsedParameter[];
  returnType: string;
  returnDescription: string;
}

/**
 * Structure for parsed property
 */
export interface ParsedProperty {
  name: string;
  type: string;
  description: string;
}

/**
 * Structure for parsed parameter
 */
export interface ParsedParameter {
  name: string;
  type: string;
  description: string;
  optional?: boolean;
}

/**
 * Structure for parsed type
 */
export interface ParsedType {
  name: string;
  description: string;
  type: string;
}

/**
 * Structure for project directory analysis
 */
export interface ProjectStructure {
  rootDir: string;
  directories: ProjectDirectory[];
}

/**
 * Structure for project directory
 */
export interface ProjectDirectory {
  name: string;
  files: string[];
  subdirectories?: ProjectDirectory[];
}

/**
 * Structure for commit type analysis
 */
export interface CommitPatternAnalysis {
  types: Record<string, number>;
  scopes: Record<string, number>;
  examples: Record<string, string[]>;
  total: number;
}
```

### 3. Documentation Service Implementation
Create a service file at `src/services/DocumentationService.ts`:

```typescript
import { ConfigService } from './ConfigService';
import { GitService } from './GitService';
import { HistoryService } from './HistoryService';
import { AnalyticsService } from './AnalyticsService';
import {
  DocumentationOptions,
  DocumentationType,
  DocumentationFormat,
  DocumentationResult,
  ParsedSourceFile,
  ProjectStructure,
  CommitPatternAnalysis,
  ParsedClass,
  ParsedInterface,
  ParsedFunction
} from '../types/Documentation';
import fs from 'fs';
import path from 'path';
import glob from 'glob';
import { promisify } from 'util';
import * as ts from 'typescript';
import marked from 'marked';

const globPromise = promisify(glob);

/**
 * Service for generating documentation
 */
export class DocumentationService {
  private defaultTemplates: Record<string, string> = {
    api: `# {{projectName}} API Documentation

This document provides information about the API of {{projectName}}.

{{content}}
`,
    commitPatterns: `# {{projectName}} Commit Pattern Guide

This document describes the commit patterns used in {{projectName}}.

## Commit Types

{{commitTypes}}

## Common Scopes

{{commitScopes}}

## Examples

{{commitExamples}}
`,
    projectStructure: `# {{projectName}} Project Structure

This document describes the structure of the {{projectName}} project.

{{content}}
`,
    userGuide: `# {{projectName}} User Guide

This guide provides information on how to use {{projectName}}.

## Getting Started

{{gettingStarted}}

## Commands

{{commands}}

## Commit Types

{{commitTypes}}

## Configuration

{{configuration}}
`
  };

  constructor(
    private configService: ConfigService,
    private gitService: GitService,
    private historyService: HistoryService,
    private analyticsService: AnalyticsService
  ) {}

  /**
   * Generate documentation based on options
   */
  public async generateDocumentation(options: DocumentationOptions): Promise<DocumentationResult> {
    try {
      // Create output directory if it doesn't exist
      if (!fs.existsSync(options.outputDir)) {
        fs.mkdirSync(options.outputDir, { recursive: true });
      }

      const outputFiles: string[] = [];

      // Generate each requested documentation type
      for (const type of options.types) {
        let content = '';

        switch (type) {
          case DocumentationType.API:
            content = await this.generateAPIDocumentation(options);
            break;
          case DocumentationType.COMMIT_PATTERNS:
            content = await this.generateCommitPatternDocumentation(options);
            break;
          case DocumentationType.PROJECT_STRUCTURE:
            content = await this.generateProjectStructureDocumentation(options);
            break;
          case DocumentationType.USER_GUIDE:
            content = await this.generateUserGuideDocumentation(options);
            break;
        }

        // Convert to HTML if requested
        if (options.format === DocumentationFormat.HTML) {
          content = this.convertMarkdownToHtml(content, options.projectName, type);
        }

        // Determine file extension
        const extension = options.format === DocumentationFormat.HTML ? 'html' : 'md';
        const outputFile = path.resolve(options.outputDir, `${type}.${extension}`);

        // Write the file
        fs.writeFileSync(outputFile, content, 'utf-8');
        outputFiles.push(outputFile);
      }

      return {
        success: true,
        outputFiles
      };
    } catch (error) {
      return {
        success: false,
        outputFiles: [],
        error: error.message
      };
    }
  }

  /**
   * Generate all documentation types
   */
  public async generateAllDocumentation(options: DocumentationOptions): Promise<DocumentationResult> {
    const fullOptions: DocumentationOptions = {
      ...options,
      types: [
        DocumentationType.API,
        DocumentationType.COMMIT_PATTERNS,
        DocumentationType.PROJECT_STRUCTURE,
        DocumentationType.USER_GUIDE
      ]
    };

    return this.generateDocumentation(fullOptions);
  }

  /**
   * Generate API documentation
   */
  private async generateAPIDocumentation(options: DocumentationOptions): Promise<string> {
    // Parse TypeScript source files
    const sourceFiles = await this.parseSourceFiles();

    // Generate markdown for API
    const apiMarkdown = this.generateMarkdownForAPI(sourceFiles, options.projectName);

    // Apply template
    return this.applyTemplate('api', {
      projectName: options.projectName,
      content: apiMarkdown
    });
  }

  /**
   * Generate commit pattern documentation
   */
  private async generateCommitPatternDocumentation(options: DocumentationOptions): Promise<string> {
    // Get commit history
    const commits = await this.historyService.getCommitHistory();

    // Analyze commit patterns
    const analysis = await this.analyticsService.analyzeCommitTypes();

    // Get commit type descriptions from config
    const commitTypeDescriptions = await this.configService.getCommitTypeDescriptions();

    // Convert to pattern analysis format
    const patternAnalysis: CommitPatternAnalysis = {
      types: analysis.types,
      scopes: {},
      examples: {},
      total: analysis.total
    };

    // Extract scopes and examples
    for (const commit of commits) {
      // Parse commit message to extract scope
      const match = commit.message.match(/^(\w+)(?:\(([^)]+)\))?:/);
      if (match) {
        const type = match[1];
        const scope = match[2];

        // Count scopes
        if (scope) {
          patternAnalysis.scopes[scope] = (patternAnalysis.scopes[scope] || 0) + 1;
        }

        // Store examples
        if (!patternAnalysis.examples[type]) {
          patternAnalysis.examples[type] = [];
        }

        if (patternAnalysis.examples[type].length < 3) {
          patternAnalysis.examples[type].push(commit.message);
        }
      }
    }

    // Generate markdown for commit patterns
    const commitPatternMarkdown = this.generateMarkdownForCommitPatterns(
      patternAnalysis,
      commitTypeDescriptions
    );

    // Apply template
    return this.applyTemplate('commitPatterns', {
      projectName: options.projectName,
      commitTypes: this.generateCommitTypesSection(patternAnalysis, commitTypeDescriptions),
      commitScopes: this.generateCommitScopesSection(patternAnalysis),
      commitExamples: this.generateCommitExamplesSection(patternAnalysis)
    });
  }

  /**
   * Generate project structure documentation
   */
  private async generateProjectStructureDocumentation(options: DocumentationOptions): Promise<string> {
    // Analyze project structure
    const structure = await this.analyzeProjectStructure();

    // Generate markdown for project structure
    const structureMarkdown = this.generateMarkdownForProjectStructure(structure);

    // Apply template
    return this.applyTemplate('projectStructure', {
      projectName: options.projectName,
      content: structureMarkdown
    });
  }

  /**
   * Generate user guide documentation
   */
  private async generateUserGuideDocumentation(options: DocumentationOptions): Promise<string> {
    // Get commit type descriptions from config
    const commitTypeDescriptions = await this.configService.getCommitTypeDescriptions();

    // Get command descriptions from config
    const commands = await this.configService.getCommands();

    // Generate markdown for user guide
    const userGuideMarkdown = this.generateMarkdownForUserGuide(
      commitTypeDescriptions,
      commands,
      options.projectName
    );

    // Apply template
    return this.applyTemplate('userGuide', {
      projectName: options.projectName,
      gettingStarted: this.generateGettingStartedSection(options.projectName),
      commands: this.generateCommandsSection(commands),
      commitTypes: this.generateCommitTypesDescriptionSection(commitTypeDescriptions),
      configuration: this.generateConfigurationSection()
    });
  }

  /**
   * Parse TypeScript source files to extract API information
   */
  private async parseSourceFiles(): Promise<ParsedSourceFile[]> {
    // Find all TypeScript files in the project
    const files = await globPromise('src/**/*.ts');

    const result: ParsedSourceFile[] = [];

    for (const file of files) {
      // Skip test files
      if (file.includes('__tests__') || file.includes('.test.ts') || file.includes('.spec.ts')) {
        continue;
      }

      const sourceFile = ts.createSourceFile(
        file,
        fs.readFileSync(file, 'utf-8'),
        ts.ScriptTarget.Latest,
        true
      );

      const parsedFile: ParsedSourceFile = {
        fileName: file,
        classes: [],
        interfaces: [],
        functions: [],
        types: []
      };

      // Process the file to extract classes, interfaces, functions, etc.
      this.processSourceFile(sourceFile, parsedFile);

      result.push(parsedFile);
    }

    return result;
  }

  /**
   * Process a TypeScript source file to extract API information
   */
  private processSourceFile(sourceFile: ts.SourceFile, parsedFile: ParsedSourceFile): void {
    // Helper function to get JSDoc comment
    const getJSDocComment = (node: ts.Node): string => {
      const comments = ts.getJSDocCommentsAndTags(node) as ts.JSDoc[];
      if (comments && comments.length > 0) {
        return comments[0].comment || '';
      }
      return '';
    };

    // Process each node in the source file
    const visit = (node: ts.Node) => {
      // Process classes
      if (ts.isClassDeclaration(node) && node.name) {
        const className = node.name.text;
        const classDescription = getJSDocComment(node);

        const parsedClass: ParsedClass = {
          name: className,
          description: classDescription,
          methods: [],
          properties: []
        };

        // Process class members
        node.members.forEach(member => {
          // Process methods
          if (ts.isMethodDeclaration(member) && member.name) {
            const methodName = member.name.getText(sourceFile);
            const methodDescription = getJSDocComment(member);

            parsedClass.methods.push({
              name: methodName,
              description: methodDescription,
              parameters: this.extractParameters(member),
              returnType: this.extractReturnType(member),
              returnDescription: this.extractReturnDescription(member)
            });
          }

          // Process properties
          if (ts.isPropertyDeclaration(member) && member.name) {
            const propertyName = member.name.getText(sourceFile);
            const propertyDescription = getJSDocComment(member);

            parsedClass.properties.push({
              name: propertyName,
              type: member.type ? member.type.getText(sourceFile) : 'any',
              description: propertyDescription
            });
          }
        });

        parsedFile.classes.push(parsedClass);
      }

      // Process interfaces
      if (ts.isInterfaceDeclaration(node) && node.name) {
        const interfaceName = node.name.text;
        const interfaceDescription = getJSDocComment(node);

        const parsedInterface: ParsedInterface = {
          name: interfaceName,
          description: interfaceDescription,
          properties: [],
          methods: []
        };

        // Process interface members
        node.members.forEach(member => {
          // Process properties
          if (ts.isPropertySignature(member) && member.name) {
            const propertyName = member.name.getText(sourceFile);
            const propertyDescription = getJSDocComment(member);

            parsedInterface.properties.push({
              name: propertyName,
              type: member.type ? member.type.getText(sourceFile) : 'any',
              description: propertyDescription
            });
          }

          // Process methods
          if (ts.isMethodSignature(member) && member.name) {
            const methodName = member.name.getText(sourceFile);
            const methodDescription = getJSDocComment(member);

            parsedInterface.methods.push({
              name: methodName,
              description: methodDescription,
              parameters: this.extractParameters(member),
              returnType: this.extractReturnType(member),
              returnDescription: this.extractReturnDescription(member)
            });
          }
        });

        parsedFile.interfaces.push(parsedInterface);
      }

      // Process functions
      if (ts.isFunctionDeclaration(node) && node.name) {
        const functionName = node.name.text;
        const functionDescription = getJSDocComment(node);

        const parsedFunction: ParsedFunction = {
          name: functionName,
          description: functionDescription,
          parameters: this.extractParameters(node),
          returnType: this.extractReturnType(node),
          returnDescription: this.extractReturnDescription(node)
        };

        parsedFile.functions.push(parsedFunction);
      }

      // Process type aliases
      if (ts.isTypeAliasDeclaration(node) && node.name) {
        const typeName = node.name.text;
        const typeDescription = getJSDocComment(node);

        parsedFile.types.push({
          name: typeName,
          description: typeDescription,
          type: node.type.getText(sourceFile)
        });
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
  }

  /**
   * Extract parameters from a function or method declaration
   */
  private extractParameters(node: ts.FunctionLikeDeclaration | ts.MethodSignature): any[] {
    const parameters = [];

    node.parameters.forEach(param => {
      const paramName = param.name.getText();
      const paramType = param.type ? param.type.getText() : 'any';
      const optional = param.questionToken !== undefined;

      // Extract parameter description from JSDoc
      const paramDoc = this.extractParameterJSDoc(node, paramName);

      parameters.push({
        name: paramName,
        type: paramType,
        description: paramDoc,
        optional
      });
    });

    return parameters;
  }

  /**
   * Extract parameter description from JSDoc
   */
  private extractParameterJSDoc(node: ts.Node, paramName: string): string {
    const jsDocTags = ts.getJSDocParameterTags(node);
    const paramTag = jsDocTags.find(tag => tag.name && tag.name.getText() === paramName);
    return paramTag && paramTag.comment ? paramTag.comment : '';
  }

  /**
   * Extract return type from a function or method declaration
   */
  private extractReturnType(node: ts.FunctionLikeDeclaration | ts.MethodSignature): string {
    if (node.type) {
      return node.type.getText();
    }
    return 'void';
  }

  /**
   * Extract return description from JSDoc
   */
  private extractReturnDescription(node: ts.Node): string {
    const jsDocTags = ts.getJSDocReturnTag(node);
    return jsDocTags && jsDocTags.comment ? jsDocTags.comment : '';
  }

  /**
   * Analyze project structure
   */
  private async analyzeProjectStructure(): Promise<ProjectStructure> {
    const rootDir = './src';
    const structure: ProjectStructure = {
      rootDir,
      directories: []
    };

    // Function to recursively analyze directories
    const analyzeDirectory = async (dir: string, parentDir: ProjectDirectory | null): Promise<ProjectDirectory> => {
      const directoryName = path.basename(dir);
      const files = await globPromise(`${dir}/*.*`);
      const subdirs = await globPromise(`${dir}/*/`, { mark: true });

      const directory: ProjectDirectory = {
        name: directoryName,
        files: files.map(file => path.basename(file)),
        subdirectories: []
      };

      // Analyze subdirectories
      for (const subdir of subdirs) {
        const subdirectory = await analyzeDirectory(subdir.slice(0, -1), directory);
        directory.subdirectories.push(subdirectory);
      }

      return directory;
    };

    // Get top-level directories
    const topDirs = await globPromise(`${rootDir}/*/`, { mark: true });
    for (const dir of topDirs) {
      const directory = await analyzeDirectory(dir.slice(0, -1), null);
      structure.directories.push(directory);
    }

    return structure;
  }

  /**
   * Generate markdown for API documentation
   */
  private generateMarkdownForAPI(sourceFiles: ParsedSourceFile[], projectName: string): string {
    let markdown = '';

    // Generate table of contents
    markdown += '## Table of Contents\n\n';
    markdown += '- [Classes](#classes)\n';
    markdown += '- [Interfaces](#interfaces)\n';
    markdown += '- [Functions](#functions)\n';
    markdown += '- [Types](#types)\n\n';

    // Generate classes section
    markdown += '## Classes\n\n';
    for (const file of sourceFiles) {
      for (const cls of file.classes) {
        markdown += `### ${cls.name}\n\n`;
        markdown += `${cls.description}\n\n`;
        markdown += `**File:** \`${file.fileName}\`\n\n`;

        // Properties
        if (cls.properties.length > 0) {
          markdown += '#### Properties\n\n';
          markdown += '| Name | Type | Description |\n';
          markdown += '| ---- | ---- | ----------- |\n';
          for (const prop of cls.properties) {
            markdown += `| ${prop.name} | \`${prop.type}\` | ${prop.description} |\n`;
          }
          markdown += '\n';
        }

        // Methods
        if (cls.methods.length > 0) {
          markdown += '#### Methods\n\n';
          for (const method of cls.methods) {
            markdown += `##### ${method.name}\n\n`;
            markdown += `${method.description}\n\n`;

            // Parameters
            if (method.parameters.length > 0) {
              markdown += 'Parameters:\n\n';
              markdown += '| Name | Type | Description |\n';
              markdown += '| ---- | ---- | ----------- |\n';
              for (const param of method.parameters) {
                markdown += `| ${param.name}${param.optional ? ' (optional)' : ''} | \`${param.type}\` | ${param.description} |\n`;
              }
              markdown += '\n';
            }

            // Return type
            markdown += `Returns: \`${method.returnType}\``;
            if (method.returnDescription) {
              markdown += ` - ${method.returnDescription}`;
            }
            markdown += '\n\n';
          }
        }
      }
    }

    // Generate interfaces section
    markdown += '## Interfaces\n\n';
    for (const file of sourceFiles) {
      for (const intf of file.interfaces) {
        markdown += `### ${intf.name}\n\n`;
        markdown += `${intf.description}\n\n`;
        markdown += `**File:** \`${file.fileName}\`\n\n`;

        // Properties
        if (intf.properties.length > 0) {
          markdown += '#### Properties\n\n';
          markdown += '| Name | Type | Description |\n';
          markdown += '| ---- | ---- | ----------- |\n';
          for (const prop of intf.properties) {
            markdown += `| ${prop.name} | \`${prop.type}\` | ${prop.description} |\n`;
          }
          markdown += '\n';
        }

        // Methods
        if (intf.methods.length > 0) {
          markdown += '#### Methods\n\n';
          for (const method of intf.methods) {
            markdown += `##### ${method.name}\n\n`;
            markdown += `${method.description}\n\n`;

            // Parameters
            if (method.parameters.length > 0) {
              markdown += 'Parameters:\n\n';
              markdown += '| Name | Type | Description |\n';
              markdown += '| ---- | ---- | ----------- |\n';
              for (const param of method.parameters) {
                markdown += `| ${param.name}${param.optional ? ' (optional)' : ''} | \`${param.type}\` | ${param.description} |\n`;
              }
              markdown += '\n';
            }

            // Return type
            markdown += `Returns: \`${method.returnType}\``;
            if (method.returnDescription) {
              markdown += ` - ${method.returnDescription}`;
            }
            markdown += '\n\n';
          }
        }
      }
    }

    // Generate functions section
    markdown += '## Functions\n\n';
    for (const file of sourceFiles) {
      for (const func of file.functions) {
        markdown += `### ${func.name}\n\n`;
        markdown += `${func.description}\n\n`;
        markdown += `**File:** \`${file.fileName}\`\n\n`;

        // Parameters
        if (func.parameters.length > 0) {
          markdown += 'Parameters:\n\n';
          markdown += '| Name | Type | Description |\n';
          markdown += '| ---- | ---- | ----------- |\n';
          for (const param of func.parameters) {
            markdown += `| ${param.name}${param.optional ? ' (optional)' : ''} | \`${param.type}\` | ${param.description} |\n`;
          }
          markdown += '\n';
        }

        // Return type
        markdown += `Returns: \`${func.returnType}\``;
        if (func.returnDescription) {
          markdown += ` - ${func.returnDescription}`;
        }
        markdown += '\n\n';
      }
    }

    // Generate types section
    markdown += '## Types\n\n';
    for (const file of sourceFiles) {
      for (const type of file.types) {
        markdown += `### ${type.name}\n\n`;
        markdown += `${type.description}\n\n`;
        markdown += `**File:** \`${file.fileName}\`\n\n`;
        markdown += '```typescript\n';
        markdown += `type ${type.name} = ${type.type};\n`;
        markdown += '```\n\n';
      }
    }

    return markdown;
  }

  /**
   * Generate markdown for commit patterns
   */
  private generateMarkdownForCommitPatterns(
    analysis: CommitPatternAnalysis,
    commitTypeDescriptions: any[]
  ): string {
    let markdown = '';

    // Generate commit types section
    markdown += this.generateCommitTypesSection(analysis, commitTypeDescriptions);

    // Generate commit scopes section
    markdown += this.generateCommitScopesSection(analysis);

    // Generate commit examples section
    markdown += this.generateCommitExamplesSection(analysis);

    return markdown;
  }

  /**
   * Generate commit types section
   */
  private generateCommitTypesSection(
    analysis: CommitPatternAnalysis,
    commitTypeDescriptions: any[]
  ): string {
    let markdown = '## Commit Types\n\n';
    markdown += '| Type | Description | Frequency |\n';
    markdown += '| ---- | ----------- | --------- |\n';

    // Sort commit types by frequency
    const sortedTypes = Object.entries(analysis.types)
      .sort((a, b) => b[1] - a[1]);

    for (const [type, count] of sortedTypes) {
      const percentage = ((count / analysis.total) * 100).toFixed(1);
      const description = commitTypeDescriptions.find(t => t.type === type)?.description || 'No description';
      markdown += `| ${type} | ${description} | ${count} (${percentage}%) |\n`;
    }

    markdown += '\n';
    return markdown;
  }

  /**
   * Generate commit scopes section
   */
  private generateCommitScopesSection(analysis: CommitPatternAnalysis): string {
    let markdown = '## Common Scopes\n\n';

    if (Object.keys(analysis.scopes).length === 0) {
      markdown += 'No common scopes found in the commit history.\n\n';
      return markdown;
    }

    markdown += '| Scope | Frequency |\n';
    markdown += '| ----- | --------- |\n';

    // Sort scopes by frequency
    const sortedScopes = Object.entries(analysis.scopes)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10); // Show top 10 scopes

    for (const [scope, count] of sortedScopes) {
      const percentage = ((count / analysis.total) * 100).toFixed(1);
      markdown += `| ${scope} | ${count} (${percentage}%) |\n`;
    }

    markdown += '\n';
    return markdown;
  }

  /**
   * Generate commit examples section
   */
  private generateCommitExamplesSection(analysis: CommitPatternAnalysis): string {
    let markdown = '## Example Commits\n\n';

    if (Object.keys(analysis.examples).length === 0) {
      markdown += 'No example commits found in the commit history.\n\n';
      return markdown;
    }

    // Sort types by frequency
    const sortedTypes = Object.keys(analysis.types)
      .sort((a, b) => analysis.types[b] - analysis.types[a]);

    for (const type of sortedTypes) {
      if (analysis.examples[type] && analysis.examples[type].length > 0) {
        markdown += `### Type: ${type}\n\n`;
        for (const example of analysis.examples[type]) {
          markdown += `- \`${example}\`\n`;
        }
        markdown += '\n';
      }
    }

    return markdown;
  }

  /**
   * Generate markdown for project structure
   */
  private generateMarkdownForProjectStructure(structure: ProjectStructure): string {
    let markdown = '';

    // Generate project structure section
    markdown += '## Project Structure\n\n';
    markdown += '```\n';
    markdown += `${structure.rootDir}/\n`;

    // Function to recursively generate directory structure
    const generateDirectoryStructure = (directory: ProjectDirectory, indent: string): string => {
      let result = '';

      // Add files
      for (const file of directory.files) {
        result += `${indent}├── ${file}\n`;
      }

      // Add subdirectories
      if (directory.subdirectories) {
        for (let i = 0; i < directory.subdirectories.length; i++) {
          const subdir = directory.subdirectories[i];
          const isLast = i === directory.subdirectories.length - 1;
          result += `${indent}${isLast ? '└── ' : '├── '}${subdir.name}/\n`;
          result += generateDirectoryStructure(subdir, `${indent}${isLast ? '    ' : '│   '}`);
        }
      }

      return result;
    };

    // Generate structure for each top-level directory
    for (let i = 0; i < structure.directories.length; i++) {
      const directory = structure.directories[i];
      const isLast = i === structure.directories.length - 1;
      markdown += `├── ${directory.name}/\n`;
      markdown += generateDirectoryStructure(directory, isLast ? '    ' : '│   ');
    }

    markdown += '```\n\n';

    // Generate directory descriptions
    markdown += '## Directory Descriptions\n\n';

    for (const directory of structure.directories) {
      markdown += `### ${directory.name}/\n\n`;
      
      switch (directory.name) {
        case 'components':
          markdown += 'Contains React components used in the UI.\n\n';
          break;
        case 'services':
          markdown += 'Contains service classes that handle business logic.\n\n';
          break;
        case 'hooks':
          markdown += 'Contains React hooks for shared functionality.\n\n';
          break;
        case 'utils':
          markdown += 'Contains utility functions and helpers.\n\n';
          break;
        case 'types':
          markdown += 'Contains TypeScript type definitions.\n\n';
          break;
        case 'context':
          markdown += 'Contains React context providers.\n\n';
          break;
        case 'commands':
          markdown += 'Contains command implementations.\n\n';
          break;
        default:
          markdown += 'Contains application files.\n\n';
      }

      // List important files in this directory
      if (directory.files.length > 0) {
        markdown += 'Key files:\n\n';
        for (const file of directory.files) {
          markdown += `- **${file}**`;
          
          // Add descriptions for common file patterns
          if (file === 'index.ts') {
            markdown += ': Export file that re-exports from other files in the directory.';
          } else if (file.endsWith('Service.ts')) {
            markdown += ': Service class that provides functionality related to ' + file.replace('Service.ts', '').toLowerCase() + '.';
          } else if (file.endsWith('Provider.tsx')) {
            markdown += ': React context provider for ' + file.replace('Provider.tsx', '').toLowerCase() + ' state.';
          } else if (file.endsWith('Hook.ts') || file.match(/^use[A-Z]/)) {
            markdown += ': React hook for ' + file.replace('Hook.ts', '').replace(/^use/, '').toLowerCase() + ' functionality.';
          }
          
          markdown += '\n';
        }
        markdown += '\n';
      }
    }

    return markdown;
  }

  /**
   * Generate markdown for user guide
   */
  private generateMarkdownForUserGuide(
    commitTypeDescriptions: any[],
    commands: any[],
    projectName: string
  ): string {
    let markdown = '';

    // Generate getting started section
    markdown += this.generateGettingStartedSection(projectName);

    // Generate commands section
    markdown += this.generateCommandsSection(commands);

    // Generate commit types section
    markdown += this.generateCommitTypesDescriptionSection(commitTypeDescriptions);

    // Generate configuration section
    markdown += this.generateConfigurationSection();

    return markdown;
  }

  /**
   * Generate getting started section for user guide
   */
  private generateGettingStartedSection(projectName: string): string {
    return `## Getting Started

${projectName} is a tool for managing git commits with a standardized format. It helps you create consistent commit messages that follow the Conventional Commits specification.

### Installation

\`\`\`
npm install -g ${projectName.toLowerCase()}
\`\`\`

### Basic Usage

To create a commit:

\`\`\`
${projectName.toLowerCase()} commit
\`\`\`

This will open an interactive interface for creating a formatted commit message.

`;
  }

  /**
   * Generate commands section for user guide
   */
  private generateCommandsSection(commands: any[]): string {
    let markdown = '## Commands\n\n';

    if (!commands || commands.length === 0) {
      markdown += 'No commands available.\n\n';
      return markdown;
    }

    for (const command of commands) {
      markdown += `### ${command.name}\n\n`;
      markdown += `${command.description}\n\n`;

      if (command.options && command.options.length > 0) {
        markdown += 'Options:\n\n';
        markdown += '| Option | Alias | Description |\n';
        markdown += '| ------ | ----- | ----------- |\n';

        for (const option of command.options) {
          markdown += `| --${option.name} | -${option.alias || ''} | ${option.description} |\n`;
        }

        markdown += '\n';
      }

      markdown += `Usage: \`${command.name} [options]\`\n\n`;
    }

    return markdown;
  }

  /**
   * Generate commit types description section for user guide
   */
  private generateCommitTypesDescriptionSection(commitTypeDescriptions: any[]): string {
    let markdown = '## Commit Types\n\n';

    if (!commitTypeDescriptions || commitTypeDescriptions.length === 0) {
      markdown += 'No commit types defined.\n\n';
      return markdown;
    }

    markdown += '| Type | Description | Example |\n';
    markdown += '| ---- | ----------- | ------- |\n';

    for (const type of commitTypeDescriptions) {
      markdown += `| ${type.type} | ${type.description} | \`${type.type}: ${type.example || 'example message'}\` |\n`;
    }

    markdown += '\n';
    return markdown;
  }

  /**
   * Generate configuration section for user guide
   */
  private generateConfigurationSection(): string {
    return `## Configuration

You can configure the application by creating a \`.zenconfig.json\` file in your home directory or in your project root.

### Global Configuration

The global configuration file is located at \`~/.zenconfig.json\`.

### Project Configuration

Project-specific configuration takes precedence over global configuration. Create a \`.zenconfig.json\` file in your project root.

### Configuration Options

\`\`\`json
{
  "commitTypes": [
    { "type": "feat", "description": "A new feature" },
    { "type": "fix", "description": "A bug fix" },
    { "type": "docs", "description": "Documentation only changes" },
    { "type": "style", "description": "Changes that do not affect the meaning of the code" },
    { "type": "refactor", "description": "A code change that neither fixes a bug nor adds a feature" },
    { "type": "perf", "description": "A code change that improves performance" },
    { "type": "test", "description": "Adding missing tests or correcting existing tests" },
    { "type": "build", "description": "Changes that affect the build system or external dependencies" },
    { "type": "ci", "description": "Changes to our CI configuration files and scripts" },
    { "type": "chore", "description": "Other changes that don't modify src or test files" }
  ],
  "templates": [
    {
      "name": "Default",
      "pattern": "<type>(<scope>): <description>\\n\\n<body>\\n\\n<footer>"
    }
  ]
}
\`\`\`

`;
  }

  /**
   * Apply template to content
   */
  private applyTemplate(templateName: string, data: Record<string, string>): string {
    let template = this.defaultTemplates[templateName];

    // Replace template variables
    Object.entries(data).forEach(([key, value]) => {
      template = template.replace(new RegExp(`{{${key}}}`, 'g'), value);
    });

    return template;
  }

  /**
   * Convert markdown to HTML
   */
  private convertMarkdownToHtml(markdown: string, projectName: string, documentationType: DocumentationType): string {
    const htmlContent = marked(markdown);

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${projectName} - ${this.getDocumentationTitle(documentationType)}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }
    a {
      color: #0366d6;
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }
    pre, code {
      font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
      background-color: #f6f8fa;
      border-radius: 3px;
    }
    pre {
      padding: 16px;
      overflow: auto;
    }
    code {
      padding: 0.2em 0.4em;
    }
    pre code {
      padding: 0;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid #dfe2e5;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background-color: #f6f8fa;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.25;
    }
    h1 {
      border-bottom: 1px solid #eaecef;
      padding-bottom: 0.3em;
    }
    h2 {
      border-bottom: 1px solid #eaecef;
      padding-bottom: 0.3em;
    }
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 0;
      border-bottom: 1px solid #eaecef;
      margin-bottom: 2rem;
    }
    .footer {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #eaecef;
      text-align: center;
      color: #586069;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${projectName}</h1>
    <span>${this.getDocumentationTitle(documentationType)}</span>
  </div>
  <div class="content">
    ${htmlContent}
  </div>
  <div class="footer">
    <p>Generated by ${projectName} Documentation Generator on ${new Date().toLocaleDateString()}</p>
  </div>
</body>
</html>`;
  }

  /**
   * Get documentation title based on type
   */
  private getDocumentationTitle(type: DocumentationType): string {
    switch (type) {
      case DocumentationType.API:
        return 'API Documentation';
      case DocumentationType.COMMIT_PATTERNS:
        return 'Commit Pattern Guide';
      case DocumentationType.PROJECT_STRUCTURE:
        return 'Project Structure';
      case DocumentationType.USER_GUIDE:
        return 'User Guide';
      default:
        return 'Documentation';
    }
  }
}
```

### 4. Create UI Component for Documentation Generation
Create a UI component file at `src/components/documentation/DocumentationGenerator.tsx`:

```typescript
import React, { useState } from 'react';
import { Box, Text } from 'ink';
import { useDocumentationService } from '../../hooks/useDocumentationService';
import TextInput from '../inputs/TextInput';
import CheckboxInput from '../inputs/CheckboxInput';
import SelectInput from '../inputs/SelectInput';
import { 
  DocumentationType, 
  DocumentationFormat,
  DocumentationOptions 
} from '../../types/Documentation';
import { Spinner } from '../feedback/Spinner';

interface DocumentationGeneratorProps {
  onComplete: () => void;
}

/**
 * Component for generating documentation
 */
export const DocumentationGenerator: React.FC<DocumentationGeneratorProps> = ({
  onComplete
}) => {
  const documentationService = useDocumentationService();
  
  const [projectName, setProjectName] = useState('Zen Commit');
  const [outputDir, setOutputDir] = useState('./docs');
  const [selectedTypes, setSelectedTypes] = useState<DocumentationType[]>([]);
  const [format, setFormat] = useState<DocumentationFormat>(DocumentationFormat.MARKDOWN);
  const [includeCommitPatterns, setIncludeCommitPatterns] = useState(true);
  
  const [step, setStep] = useState(0);
  const [generating, setGenerating] = useState(false);
  const [result, setResult] = useState<{ success: boolean; message: string; files: string[] } | null>(null);
  
  // Handle type selection
  const handleTypeSelect = (type: DocumentationType) => {
    if (selectedTypes.includes(type)) {
      setSelectedTypes(selectedTypes.filter(t => t !== type));
    } else {
      setSelectedTypes([...selectedTypes, type]);
    }
  };
  
  // Handle generation
  const handleGenerate = async () => {
    try {
      setGenerating(true);
      
      // Use all types if none selected
      const types = selectedTypes.length > 0
        ? selectedTypes
        : [
            DocumentationType.API,
            DocumentationType.COMMIT_PATTERNS,
            DocumentationType.PROJECT_STRUCTURE,
            DocumentationType.USER_GUIDE
          ];
      
      const options: DocumentationOptions = {
        types,
        format,
        outputDir,
        projectName,
        includeCommitPatterns
      };
      
      const generateResult = await documentationService.generateDocumentation(options);
      
      setResult({
        success: generateResult.success,
        message: generateResult.success 
          ? 'Documentation generated successfully' 
          : `Error: ${generateResult.error}`,
        files: generateResult.outputFiles
      });
    } catch (error) {
      setResult({
        success: false,
        message: `Error: ${error.message}`,
        files: []
      });
    } finally {
      setGenerating(false);
    }
  };
  
  // Handle next step
  const handleNext = () => {
    if (step < 4) {
      setStep(step + 1);
    } else {
      handleGenerate();
    }
  };
  
  // Render project name input
  if (step === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Documentation Generator - Project Name</Text>
        <Box marginY={1}>
          <Text>Enter the name of your project:</Text>
        </Box>
        <TextInput 
          value={projectName}
          onChange={setProjectName}
          placeholder="Project Name"
          onSubmit={handleNext}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Render output directory input
  if (step === 1) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Documentation Generator - Output Directory</Text>
        <Box marginY={1}>
          <Text>Enter the output directory for documentation:</Text>
        </Box>
        <TextInput 
          value={outputDir}
          onChange={setOutputDir}
          placeholder="./docs"
          onSubmit={handleNext}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Render documentation type selection
  if (step === 2) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Documentation Generator - Documentation Types</Text>
        <Box marginY={1}>
          <Text>Select the types of documentation to generate:</Text>
        </Box>
        <Box flexDirection="column" marginLeft={2}>
          <CheckboxInput
            label="API Documentation"
            checked={selectedTypes.includes(DocumentationType.API)}
            onChange={() => handleTypeSelect(DocumentationType.API)}
          />
          <CheckboxInput
            label="Commit Pattern Guide"
            checked={selectedTypes.includes(DocumentationType.COMMIT_PATTERNS)}
            onChange={() => handleTypeSelect(DocumentationType.COMMIT_PATTERNS)}
          />
          <CheckboxInput
            label="Project Structure"
            checked={selectedTypes.includes(DocumentationType.PROJECT_STRUCTURE)}
            onChange={() => handleTypeSelect(DocumentationType.PROJECT_STRUCTURE)}
          />
          <CheckboxInput
            label="User Guide"
            checked={selectedTypes.includes(DocumentationType.USER_GUIDE)}
            onChange={() => handleTypeSelect(DocumentationType.USER_GUIDE)}
          />
        </Box>
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Render format selection
  if (step === 3) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Documentation Generator - Output Format</Text>
        <Box marginY={1}>
          <Text>Select the output format:</Text>
        </Box>
        <SelectInput
          items={[
            { label: 'Markdown', value: DocumentationFormat.MARKDOWN },
            { label: 'HTML', value: DocumentationFormat.HTML }
          ]}
          onSelect={item => {
            setFormat(item.value as DocumentationFormat);
            handleNext();
          }}
          onCancel={() => setStep(2)}
        />
      </Box>
    );
  }
  
  // Render commit pattern inclusion
  if (step === 4) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Documentation Generator - Commit Patterns</Text>
        <Box marginY={1}>
          <Text>Include commit pattern analysis?</Text>
        </Box>
        <Box flexDirection="column" marginLeft={2}>
          <CheckboxInput
            label="Include commit pattern analysis"
            checked={includeCommitPatterns}
            onChange={() => setIncludeCommitPatterns(!includeCommitPatterns)}
          />
        </Box>
        <Box marginTop={2}>
          <Text>Press Enter to generate documentation</Text>
        </Box>
      </Box>
    );
  }
  
  // Render generation status
  if (generating) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Generating documentation..." />
      </Box>
    );
  }
  
  // Render result
  if (result) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold color={result.success ? 'green' : 'red'}>
          {result.message}
        </Text>
        
        {result.success && result.files.length > 0 && (
          <>
            <Box marginY={1}>
              <Text>Files generated:</Text>
            </Box>
            <Box flexDirection="column" marginLeft={2}>
              {result.files.map((file, index) => (
                <Text key={index}>{file}</Text>
              ))}
            </Box>
          </>
        )}
        
        <Box marginTop={2}>
          <Text>Press Enter to close</Text>
        </Box>
      </Box>
    );
  }
  
  return null;
};
```

### 5. Create Documentation Hook
Create a custom hook at `src/hooks/useDocumentationService.ts`:

```typescript
import { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import { DocumentationService } from '../services/DocumentationService';

/**
 * Hook to access the DocumentationService instance
 */
export function useDocumentationService(): DocumentationService {
  const { services } = useContext(AppContext);
  
  if (!services.documentationService) {
    throw new Error('DocumentationService not available in context');
  }
  
  return services.documentationService;
}
```

### 6. Create Documentation Command
Create a command file at `src/commands/docs.ts`:

```typescript
import { Command } from '../types/Command';
import { render } from 'ink';
import React from 'react';
import { DocumentationGenerator } from '../components/documentation/DocumentationGenerator';
import { createAppContext } from '../context/createAppContext';
import { 
  DocumentationType, 
  DocumentationFormat,
  DocumentationOptions 
} from '../types/Documentation';

/**
 * Command for generating documentation
 */
export const docsCommand: Command = {
  name: 'docs',
  description: 'Generate documentation for the project',
  options: [
    {
      name: 'output',
      description: 'Output directory',
      alias: 'o',
      type: 'string'
    },
    {
      name: 'format',
      description: 'Output format (markdown, html)',
      alias: 'f',
      type: 'string'
    },
    {
      name: 'type',
      description: 'Documentation type (api, commit-patterns, project-structure, user-guide)',
      alias: 't',
      type: 'string'
    },
    {
      name: 'project-name',
      description: 'Project name',
      alias: 'p',
      type: 'string'
    },
    {
      name: 'all',
      description: 'Generate all documentation types',
      alias: 'a',
      type: 'boolean'
    },
    {
      name: 'no-commit-patterns',
      description: 'Do not include commit pattern analysis',
      type: 'boolean'
    }
  ],
  
  async execute(args, options): Promise<void> {
    const context = await createAppContext();
    const { documentationService } = context.services;
    
    // Check if we should run in interactive mode
    const isInteractive = !options.output && !options.type && !options.all;
    
    if (isInteractive) {
      // Run in interactive mode
      const { waitUntilExit } = render(
        React.createElement(
          DocumentationGenerator,
          { onComplete: () => process.exit(0) }
        )
      );
      
      await waitUntilExit();
    } else {
      // Run in command line mode
      const docOptions: DocumentationOptions = {
        types: [],
        format: DocumentationFormat.MARKDOWN,
        outputDir: options.output || './docs',
        projectName: options['project-name'] || 'Zen Commit',
        includeCommitPatterns: !options['no-commit-patterns']
      };
      
      // Set documentation format
      if (options.format) {
        if (options.format.toLowerCase() === 'html') {
          docOptions.format = DocumentationFormat.HTML;
        }
      }
      
      // Set documentation types
      if (options.all) {
        docOptions.types = [
          DocumentationType.API,
          DocumentationType.COMMIT_PATTERNS,
          DocumentationType.PROJECT_STRUCTURE,
          DocumentationType.USER_GUIDE
        ];
      } else if (options.type) {
        const types = options.type.split(',').map(t => t.trim().toLowerCase());
        
        if (types.includes('api')) {
          docOptions.types.push(DocumentationType.API);
        }
        if (types.includes('commit-patterns')) {
          docOptions.types.push(DocumentationType.COMMIT_PATTERNS);
        }
        if (types.includes('project-structure')) {
          docOptions.types.push(DocumentationType.PROJECT_STRUCTURE);
        }
        if (types.includes('user-guide')) {
          docOptions.types.push(DocumentationType.USER_GUIDE);
        }
      } else {
        // Default to API documentation
        docOptions.types = [DocumentationType.API];
      }
      
      // Generate documentation
      console.log('Generating documentation...');
      
      const result = await documentationService.generateDocumentation(docOptions);
      
      if (result.success) {
        console.log('Documentation generated successfully');
        console.log('Files generated:');
        result.outputFiles.forEach(file => {
          console.log(`  ${file}`);
        });
      } else {
        console.error(`Error generating documentation: ${result.error}`);
      }
    }
  }
};
```

### 7. Update Core Exports
Update `src/index.ts` to include the documentation service:

```typescript
// Add to imports
import { DocumentationService } from './services/DocumentationService';
import { docsCommand } from './commands/docs';

// Add to commandRegistry
commandRegistry.register(docsCommand);

// Add to service initialization
const documentationService = new DocumentationService(
  configService,
  gitService,
  historyService,
  analyticsService
);

// Add to context
context.services.documentationService = documentationService;
```

### 8. Update App Context Type
Update `src/context/AppContext.ts`:

```typescript
import { DocumentationService } from '../services/DocumentationService';

// Add to Services interface
export interface Services {
  // ... existing services
  documentationService: DocumentationService;
}
```

### 9. Update Configuration Service
Update `src/services/ConfigService.ts` to include documentation-related methods:

```typescript
/**
 * Get commit type descriptions
 */
public async getCommitTypeDescriptions(): Promise<any[]> {
  await this.loadConfig();
  return this.config.commitTypes || [
    { type: 'feat', description: 'A new feature' },
    { type: 'fix', description: 'A bug fix' },
    { type: 'docs', description: 'Documentation only changes' },
    { type: 'style', description: 'Changes that do not affect the meaning of the code' },
    { type: 'refactor', description: 'A code change that neither fixes a bug nor adds a feature' },
    { type: 'perf', description: 'A code change that improves performance' },
    { type: 'test', description: 'Adding missing tests or correcting existing tests' },
    { type: 'build', description: 'Changes that affect the build system or external dependencies' },
    { type: 'ci', description: 'Changes to our CI configuration files and scripts' },
    { type: 'chore', description: 'Other changes that don\'t modify src or test files' }
  ];
}

/**
 * Get command descriptions
 */
public async getCommands(): Promise<any[]> {
  // Return available commands
  return [
    {
      name: 'commit',
      description: 'Create a new commit with a formatted message',
      options: [
        { name: 'template', alias: 't', description: 'Use a specific template for the commit message' }
      ]
    },
    {
      name: 'history',
      description: 'Show commit history',
      options: [
        { name: 'limit', alias: 'l', description: 'Limit the number of commits to show' }
      ]
    },
    {
      name: 'analytics',
      description: 'Show analytics dashboard',
      options: [
        { name: 'export', alias: 'e', description: 'Export analytics to a file' }
      ]
    },
    {
      name: 'docs',
      description: 'Generate documentation',
      options: [
        { name: 'output', alias: 'o', description: 'Output directory' },
        { name: 'format', alias: 'f', description: 'Output format (markdown, html)' },
        { name: 'type', alias: 't', description: 'Documentation type (api, commit-patterns, project-structure, user-guide)' },
        { name: 'all', alias: 'a', description: 'Generate all documentation types' }
      ]
    }
  ];
}
```

## Definition of Done
- Documentation service implemented with support for API, commit patterns, project structure, and user guide documentation
- TypeScript parser for extracting API information from source code
- Markdown and HTML output formats supported
- Command-line interface for generating documentation
- Interactive UI for configuring documentation generation
- Integration with existing commit history and analytics functionality

## Potential Blockers
- Complex TypeScript structures that are difficult to parse
- Large codebases may require optimization for documentation generation
- Custom JSDoc formats may not be properly extracted
- HTML styling might need additional customization for certain projects

## Next Steps
- Implement plugin architecture (5.3.2)
- Create extension marketplace (5.3.3)