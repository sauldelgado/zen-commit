# 5.3.3 Extension Marketplace

## Overview
This step implements an extension marketplace that allows users to discover, install, and manage plugins for the application. The marketplace will provide a central repository for sharing plugins, with features for browsing, searching, rating, and submitting new extensions.

## Dependencies
- Phase 5.3.2 - Plugin Architecture

## Prerequisites
- Plugin architecture (5.3.2)

## Implementation Order
1. Define marketplace API interface
2. Implement marketplace service
3. Create extension repository
4. Develop marketplace UI
5. Build plugin submission workflow
6. Implement plugin rating system
7. Create search and filtering functionality

## Development Guidelines
- Use a RESTful API for marketplace interactions
- Implement proper versioning for extensions
- Support user authentication for submissions and ratings
- Cache marketplace data to optimize performance
- Validate extensions for security and quality
- Provide clear categorization for extensions

## Detailed Tasks

### 1. Test File Creation
Create a test file at `src/__tests__/services/MarketplaceService.test.ts`:

```typescript
import { MarketplaceService } from '../../services/MarketplaceService';
import { PluginService } from '../../services/PluginService';
import { ConfigService } from '../../services/ConfigService';
import { UserPreferencesService } from '../../services/UserPreferencesService';
import { 
  Extension, 
  ExtensionCategory,
  ExtensionSortOption,
  ExtensionFilter
} from '../../types/Marketplace';

jest.mock('../../services/PluginService');
jest.mock('../../services/ConfigService');
jest.mock('../../services/UserPreferencesService');
jest.mock('axios');

describe('MarketplaceService', () => {
  let marketplaceService: MarketplaceService;
  let mockPluginService: jest.Mocked<PluginService>;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockUserPreferencesService: jest.Mocked<UserPreferencesService>;
  
  beforeEach(() => {
    mockPluginService = new PluginService(
      {} as any,
      {} as any
    ) as jest.Mocked<PluginService>;
    
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    
    mockUserPreferencesService = new UserPreferencesService(
      mockConfigService
    ) as jest.Mocked<UserPreferencesService>;
    
    marketplaceService = new MarketplaceService(
      mockPluginService,
      mockConfigService,
      mockUserPreferencesService
    );
    
    // Mock axios responses
    const axios = require('axios');
    
    // Mock successful marketplace response
    axios.get.mockImplementation((url) => {
      if (url.includes('/extensions')) {
        return Promise.resolve({
          data: [
            {
              id: 'extension1',
              name: 'Extension 1',
              description: 'Description for Extension 1',
              version: '1.0.0',
              author: 'Author 1',
              downloads: 100,
              rating: 4.5,
              ratingCount: 10,
              category: ExtensionCategory.INTEGRATION,
              publishedDate: '2023-01-01',
              lastUpdated: '2023-01-15',
              repository: 'https://github.com/author1/extension1',
              packageName: 'zencommit-plugin-extension1',
              tags: ['integration', 'github']
            },
            {
              id: 'extension2',
              name: 'Extension 2',
              description: 'Description for Extension 2',
              version: '2.0.0',
              author: 'Author 2',
              downloads: 200,
              rating: 3.5,
              ratingCount: 5,
              category: ExtensionCategory.TEMPLATE,
              publishedDate: '2023-02-01',
              lastUpdated: '2023-02-15',
              repository: 'https://github.com/author2/extension2',
              packageName: 'zencommit-plugin-extension2',
              tags: ['template', 'commit']
            }
          ]
        });
      } else if (url.includes('/extensions/extension1')) {
        return Promise.resolve({
          data: {
            id: 'extension1',
            name: 'Extension 1',
            description: 'Description for Extension 1',
            version: '1.0.0',
            author: 'Author 1',
            downloads: 100,
            rating: 4.5,
            ratingCount: 10,
            category: ExtensionCategory.INTEGRATION,
            publishedDate: '2023-01-01',
            lastUpdated: '2023-01-15',
            repository: 'https://github.com/author1/extension1',
            packageName: 'zencommit-plugin-extension1',
            tags: ['integration', 'github'],
            longDescription: 'Long description for Extension 1',
            readme: '# Extension 1\n\nA great extension for integration.',
            screenshots: ['screenshot1.png', 'screenshot2.png'],
            versions: [
              { version: '1.0.0', date: '2023-01-01' },
              { version: '0.9.0', date: '2022-12-01' }
            ]
          }
        });
      }
      
      return Promise.reject(new Error('Not found'));
    });
    
    // Mock POST for ratings
    axios.post.mockImplementation((url) => {
      if (url.includes('/extensions/extension1/rate')) {
        return Promise.resolve({
          data: {
            success: true,
            rating: 4.2,
            ratingCount: 11
          }
        });
      }
      
      return Promise.reject(new Error('Not found'));
    });
  });
  
  describe('getExtensions', () => {
    it('should fetch extensions from the marketplace', async () => {
      const extensions = await marketplaceService.getExtensions();
      
      expect(extensions).toHaveLength(2);
      expect(extensions[0].id).toBe('extension1');
      expect(extensions[1].id).toBe('extension2');
    });
    
    it('should sort extensions by downloads', async () => {
      const extensions = await marketplaceService.getExtensions({
        sort: ExtensionSortOption.DOWNLOADS
      });
      
      expect(extensions).toHaveLength(2);
      expect(extensions[0].id).toBe('extension2'); // 200 downloads
      expect(extensions[1].id).toBe('extension1'); // 100 downloads
    });
    
    it('should filter extensions by category', async () => {
      const axios = require('axios');
      
      // Override the mock for filtering
      axios.get.mockImplementationOnce((url) => {
        return Promise.resolve({
          data: [
            {
              id: 'extension1',
              name: 'Extension 1',
              description: 'Description for Extension 1',
              version: '1.0.0',
              author: 'Author 1',
              downloads: 100,
              rating: 4.5,
              ratingCount: 10,
              category: ExtensionCategory.INTEGRATION,
              publishedDate: '2023-01-01',
              lastUpdated: '2023-01-15',
              repository: 'https://github.com/author1/extension1',
              packageName: 'zencommit-plugin-extension1',
              tags: ['integration', 'github']
            }
          ]
        });
      });
      
      const extensions = await marketplaceService.getExtensions({
        filter: {
          category: ExtensionCategory.INTEGRATION
        }
      });
      
      expect(extensions).toHaveLength(1);
      expect(extensions[0].category).toBe(ExtensionCategory.INTEGRATION);
    });
    
    it('should search extensions by query', async () => {
      const axios = require('axios');
      
      // Override the mock for searching
      axios.get.mockImplementationOnce((url) => {
        return Promise.resolve({
          data: [
            {
              id: 'extension1',
              name: 'Extension 1',
              description: 'Description for Extension 1',
              version: '1.0.0',
              author: 'Author 1',
              downloads: 100,
              rating: 4.5,
              ratingCount: 10,
              category: ExtensionCategory.INTEGRATION,
              publishedDate: '2023-01-01',
              lastUpdated: '2023-01-15',
              repository: 'https://github.com/author1/extension1',
              packageName: 'zencommit-plugin-extension1',
              tags: ['integration', 'github']
            }
          ]
        });
      });
      
      const extensions = await marketplaceService.getExtensions({
        search: 'integration'
      });
      
      expect(extensions).toHaveLength(1);
      expect(extensions[0].id).toBe('extension1');
    });
  });
  
  describe('getExtensionDetails', () => {
    it('should fetch detailed information for a specific extension', async () => {
      const extension = await marketplaceService.getExtensionDetails('extension1');
      
      expect(extension).toBeDefined();
      expect(extension.id).toBe('extension1');
      expect(extension.name).toBe('Extension 1');
      expect(extension.longDescription).toBe('Long description for Extension 1');
      expect(extension.readme).toBeDefined();
      expect(extension.screenshots).toHaveLength(2);
      expect(extension.versions).toHaveLength(2);
    });
    
    it('should throw an error if the extension does not exist', async () => {
      await expect(marketplaceService.getExtensionDetails('nonexistent'))
        .rejects.toThrow('Extension not found');
    });
  });
  
  describe('installExtension', () => {
    it('should install an extension from the marketplace', async () => {
      mockPluginService.installPlugin.mockResolvedValue(true);
      
      const result = await marketplaceService.installExtension('extension1');
      
      expect(result.success).toBe(true);
      expect(mockPluginService.installPlugin).toHaveBeenCalledWith('zencommit-plugin-extension1');
    });
    
    it('should handle installation failures', async () => {
      mockPluginService.installPlugin.mockResolvedValue(false);
      
      const result = await marketplaceService.installExtension('extension1');
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to install extension');
    });
  });
  
  describe('uninstallExtension', () => {
    it('should uninstall an extension', async () => {
      mockPluginService.uninstallPlugin.mockResolvedValue(true);
      
      const result = await marketplaceService.uninstallExtension('extension1');
      
      expect(result.success).toBe(true);
      expect(mockPluginService.uninstallPlugin).toHaveBeenCalledWith('extension1');
    });
  });
  
  describe('rateExtension', () => {
    it('should submit a rating for an extension', async () => {
      const result = await marketplaceService.rateExtension('extension1', 4);
      
      expect(result.success).toBe(true);
      expect(result.rating).toBe(4.2);
      expect(result.ratingCount).toBe(11);
    });
  });
  
  describe('submitExtension', () => {
    it('should submit a new extension to the marketplace', async () => {
      const axios = require('axios');
      
      // Mock successful submission
      axios.post.mockImplementationOnce((url) => {
        if (url.includes('/extensions/submit')) {
          return Promise.resolve({
            data: {
              success: true,
              id: 'new-extension'
            }
          });
        }
      });
      
      const extension: Partial<Extension> = {
        name: 'New Extension',
        description: 'A new extension',
        category: ExtensionCategory.INTEGRATION,
        repository: 'https://github.com/author/new-extension',
        packageName: 'zencommit-plugin-new-extension'
      };
      
      const result = await marketplaceService.submitExtension(extension);
      
      expect(result.success).toBe(true);
      expect(result.id).toBe('new-extension');
    });
  });
  
  describe('getInstalledExtensions', () => {
    it('should get installed extensions', async () => {
      // Mock installed plugins
      mockPluginService.getPlugins.mockReturnValue([
        {
          metadata: {
            id: 'extension1',
            name: 'Extension 1',
            version: '1.0.0',
            description: 'Description for Extension 1',
            author: 'Author 1',
            type: 'npm'
          },
          lifecycle: {} as any,
          hooks: {},
          commands: []
        }
      ]);
      
      const extensions = await marketplaceService.getInstalledExtensions();
      
      expect(extensions).toHaveLength(1);
      expect(extensions[0].id).toBe('extension1');
    });
  });
});
```

### 2. Marketplace Types
Create a file for marketplace types at `src/types/Marketplace.ts`:

```typescript
/**
 * Extension categories
 */
export enum ExtensionCategory {
  INTEGRATION = 'integration',
  TEMPLATE = 'template',
  FORMATTER = 'formatter',
  VALIDATOR = 'validator',
  UTILITY = 'utility',
  THEME = 'theme',
  OTHER = 'other'
}

/**
 * Extension version information
 */
export interface ExtensionVersion {
  version: string;
  date: string;
  notes?: string;
}

/**
 * Extension interface representing an item in the marketplace
 */
export interface Extension {
  id: string;
  name: string;
  description: string;
  version: string;
  author: string;
  downloads: number;
  rating: number;
  ratingCount: number;
  category: ExtensionCategory;
  publishedDate: string;
  lastUpdated: string;
  repository: string;
  packageName: string;
  tags: string[];
  longDescription?: string;
  readme?: string;
  screenshots?: string[];
  versions?: ExtensionVersion[];
  installed?: boolean;
}

/**
 * Extension sort options
 */
export enum ExtensionSortOption {
  DOWNLOADS = 'downloads',
  RATING = 'rating',
  NEWEST = 'newest',
  UPDATED = 'updated',
  NAME = 'name'
}

/**
 * Extension filter options
 */
export interface ExtensionFilter {
  category?: ExtensionCategory;
  author?: string;
  tags?: string[];
  installed?: boolean;
}

/**
 * Extension query options
 */
export interface ExtensionQueryOptions {
  search?: string;
  sort?: ExtensionSortOption;
  filter?: ExtensionFilter;
  page?: number;
  pageSize?: number;
}

/**
 * Extension installation result
 */
export interface ExtensionInstallResult {
  success: boolean;
  error?: string;
}

/**
 * Extension uninstallation result
 */
export interface ExtensionUninstallResult {
  success: boolean;
  error?: string;
}

/**
 * Extension rating result
 */
export interface ExtensionRatingResult {
  success: boolean;
  rating: number;
  ratingCount: number;
  error?: string;
}

/**
 * Extension submission result
 */
export interface ExtensionSubmissionResult {
  success: boolean;
  id?: string;
  error?: string;
}

/**
 * Marketplace API endpoints
 */
export const MARKETPLACE_API = {
  BASE_URL: 'https://api.zencommit.io',
  EXTENSIONS: '/extensions',
  EXTENSION_DETAILS: '/extensions/:id',
  INSTALL: '/extensions/:id/install',
  RATE: '/extensions/:id/rate',
  SUBMIT: '/extensions/submit'
};
```

### 3. Marketplace Service Implementation
Create a service file at `src/services/MarketplaceService.ts`:

```typescript
import { PluginService } from './PluginService';
import { ConfigService } from './ConfigService';
import { UserPreferencesService } from './UserPreferencesService';
import {
  Extension,
  ExtensionCategory,
  ExtensionQueryOptions,
  ExtensionInstallResult,
  ExtensionUninstallResult,
  ExtensionRatingResult,
  ExtensionSubmissionResult,
  MARKETPLACE_API
} from '../types/Marketplace';
import axios from 'axios';

/**
 * Service for interacting with the extension marketplace
 */
export class MarketplaceService {
  private cacheTimeout: number = 30 * 60 * 1000; // 30 minutes
  private extensionsCache: { data: Extension[]; timestamp: number } | null = null;
  
  constructor(
    private pluginService: PluginService,
    private configService: ConfigService,
    private userPreferencesService: UserPreferencesService
  ) {}
  
  /**
   * Get extensions from the marketplace
   */
  public async getExtensions(options: ExtensionQueryOptions = {}): Promise<Extension[]> {
    try {
      // Check if cache is valid
      if (this.extensionsCache && 
          (Date.now() - this.extensionsCache.timestamp) < this.cacheTimeout) {
        return this.processExtensions(this.extensionsCache.data, options);
      }
      
      // Build query parameters
      const params: Record<string, string> = {};
      
      if (options.search) {
        params.search = options.search;
      }
      
      if (options.sort) {
        params.sort = options.sort;
      }
      
      if (options.filter?.category) {
        params.category = options.filter.category;
      }
      
      if (options.filter?.author) {
        params.author = options.filter.author;
      }
      
      if (options.filter?.tags) {
        params.tags = options.filter.tags.join(',');
      }
      
      if (options.page) {
        params.page = options.page.toString();
      }
      
      if (options.pageSize) {
        params.pageSize = options.pageSize.toString();
      }
      
      // Fetch extensions from API
      const response = await axios.get(`${MARKETPLACE_API.BASE_URL}${MARKETPLACE_API.EXTENSIONS}`, {
        params
      });
      
      const extensions = response.data as Extension[];
      
      // Update cache
      this.extensionsCache = {
        data: extensions,
        timestamp: Date.now()
      };
      
      return this.processExtensions(extensions, options);
    } catch (error) {
      console.error('Failed to fetch extensions:', error);
      return [];
    }
  }
  
  /**
   * Get detailed information for a specific extension
   */
  public async getExtensionDetails(id: string): Promise<Extension> {
    try {
      const url = `${MARKETPLACE_API.BASE_URL}${MARKETPLACE_API.EXTENSION_DETAILS.replace(':id', id)}`;
      const response = await axios.get(url);
      
      if (!response.data) {
        throw new Error('Extension not found');
      }
      
      const extension = response.data as Extension;
      
      // Mark as installed if applicable
      const installedPlugins = this.pluginService.getPlugins();
      extension.installed = installedPlugins.some(plugin => plugin.metadata.id === id);
      
      return extension;
    } catch (error) {
      throw new Error('Extension not found');
    }
  }
  
  /**
   * Install an extension from the marketplace
   */
  public async installExtension(id: string): Promise<ExtensionInstallResult> {
    try {
      // Get extension details
      const extension = await this.getExtensionDetails(id);
      
      // Install plugin
      const success = await this.pluginService.installPlugin(extension.packageName);
      
      if (!success) {
        return {
          success: false,
          error: 'Failed to install extension'
        };
      }
      
      // Track installation
      await this.trackExtensionInstall(id);
      
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Uninstall an extension
   */
  public async uninstallExtension(id: string): Promise<ExtensionUninstallResult> {
    try {
      const success = await this.pluginService.uninstallPlugin(id);
      
      if (!success) {
        return {
          success: false,
          error: 'Failed to uninstall extension'
        };
      }
      
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Rate an extension
   */
  public async rateExtension(id: string, rating: number): Promise<ExtensionRatingResult> {
    try {
      if (rating < 1 || rating > 5) {
        throw new Error('Rating must be between 1 and 5');
      }
      
      const url = `${MARKETPLACE_API.BASE_URL}${MARKETPLACE_API.RATE.replace(':id', id)}`;
      const response = await axios.post(url, {
        rating
      });
      
      return {
        success: true,
        rating: response.data.rating,
        ratingCount: response.data.ratingCount
      };
    } catch (error) {
      return {
        success: false,
        rating: 0,
        ratingCount: 0,
        error: error.message
      };
    }
  }
  
  /**
   * Submit a new extension to the marketplace
   */
  public async submitExtension(extension: Partial<Extension>): Promise<ExtensionSubmissionResult> {
    try {
      // Validate required fields
      if (!extension.name || !extension.description || !extension.category || 
          !extension.repository || !extension.packageName) {
        throw new Error('Missing required fields');
      }
      
      const url = `${MARKETPLACE_API.BASE_URL}${MARKETPLACE_API.SUBMIT}`;
      const response = await axios.post(url, extension);
      
      return {
        success: true,
        id: response.data.id
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * Get installed extensions
   */
  public async getInstalledExtensions(): Promise<Extension[]> {
    // Get installed plugins
    const plugins = this.pluginService.getPlugins();
    
    // Convert to Extension format
    const extensions: Extension[] = plugins.map(plugin => ({
      id: plugin.metadata.id,
      name: plugin.metadata.name,
      description: plugin.metadata.description,
      version: plugin.metadata.version,
      author: plugin.metadata.author,
      downloads: 0,
      rating: 0,
      ratingCount: 0,
      category: ExtensionCategory.OTHER, // Default category
      publishedDate: '',
      lastUpdated: '',
      repository: '',
      packageName: plugin.metadata.id,
      tags: [],
      installed: true
    }));
    
    return extensions;
  }
  
  /**
   * Process extensions based on query options
   */
  private processExtensions(extensions: Extension[], options: ExtensionQueryOptions): Extension[] {
    let result = [...extensions];
    
    // Mark installed extensions
    const installedPlugins = this.pluginService.getPlugins();
    result.forEach(extension => {
      extension.installed = installedPlugins.some(plugin => plugin.metadata.id === extension.id);
    });
    
    // Filter installed extensions if requested
    if (options.filter?.installed !== undefined) {
      result = result.filter(extension => extension.installed === options.filter!.installed);
    }
    
    // Sort extensions
    if (options.sort) {
      result = this.sortExtensions(result, options.sort);
    }
    
    return result;
  }
  
  /**
   * Sort extensions based on sort option
   */
  private sortExtensions(extensions: Extension[], sortOption: string): Extension[] {
    switch (sortOption) {
      case 'downloads':
        return extensions.sort((a, b) => b.downloads - a.downloads);
      case 'rating':
        return extensions.sort((a, b) => b.rating - a.rating);
      case 'newest':
        return extensions.sort((a, b) => {
          return new Date(b.publishedDate).getTime() - new Date(a.publishedDate).getTime();
        });
      case 'updated':
        return extensions.sort((a, b) => {
          return new Date(b.lastUpdated).getTime() - new Date(a.lastUpdated).getTime();
        });
      case 'name':
        return extensions.sort((a, b) => a.name.localeCompare(b.name));
      default:
        return extensions;
    }
  }
  
  /**
   * Track extension installation for analytics
   */
  private async trackExtensionInstall(id: string): Promise<void> {
    try {
      await axios.post(`${MARKETPLACE_API.BASE_URL}/analytics/install`, {
        extensionId: id
      });
    } catch (error) {
      // Silently fail tracking
      console.error('Failed to track extension installation:', error);
    }
  }
}
```

### 4. Create UI Component for Marketplace
Create a UI component file at `src/components/marketplace/Marketplace.tsx`:

```typescript
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import { useMarketplaceService } from '../../hooks/useMarketplaceService';
import { 
  Extension, 
  ExtensionCategory, 
  ExtensionSortOption,
  ExtensionQueryOptions 
} from '../../types/Marketplace';
import { Spinner } from '../feedback/Spinner';
import SelectInput from '../inputs/SelectInput';
import TextInput from '../inputs/TextInput';

interface MarketplaceProps {
  onClose: () => void;
}

type ViewMode = 'list' | 'detail' | 'search' | 'filter' | 'install' | 'rate';

/**
 * Component for browsing and managing extensions in the marketplace
 */
export const Marketplace: React.FC<MarketplaceProps> = ({ onClose }) => {
  const marketplaceService = useMarketplaceService();
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [extensions, setExtensions] = useState<Extension[]>([]);
  const [selectedExtensionIndex, setSelectedExtensionIndex] = useState(0);
  const [selectedExtension, setSelectedExtension] = useState<Extension | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [queryOptions, setQueryOptions] = useState<ExtensionQueryOptions>({
    sort: ExtensionSortOption.DOWNLOADS
  });
  const [ratingValue, setRatingValue] = useState(5);
  const [actionMessage, setActionMessage] = useState<string | null>(null);
  
  // Load extensions
  const loadExtensions = async () => {
    try {
      setLoading(true);
      const loadedExtensions = await marketplaceService.getExtensions(queryOptions);
      setExtensions(loadedExtensions);
      
      if (loadedExtensions.length > 0 && selectedExtensionIndex < loadedExtensions.length) {
        setSelectedExtension(loadedExtensions[selectedExtensionIndex]);
      }
      
      setError(null);
    } catch (err) {
      setError(`Failed to load extensions: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };
  
  // Initial load
  useEffect(() => {
    loadExtensions();
  }, [queryOptions]);
  
  // Handle extension installation
  const installExtension = async (extension: Extension) => {
    try {
      setActionMessage(`Installing ${extension.name}...`);
      
      const result = await marketplaceService.installExtension(extension.id);
      
      if (result.success) {
        setActionMessage(`Successfully installed ${extension.name}`);
        
        // Refresh extensions
        await loadExtensions();
      } else {
        setActionMessage(`Failed to install ${extension.name}: ${result.error}`);
      }
    } catch (err) {
      setActionMessage(`Failed to install extension: ${err.message}`);
    } finally {
      setTimeout(() => {
        setActionMessage(null);
      }, 3000);
    }
  };
  
  // Handle extension uninstallation
  const uninstallExtension = async (extension: Extension) => {
    try {
      setActionMessage(`Uninstalling ${extension.name}...`);
      
      const result = await marketplaceService.uninstallExtension(extension.id);
      
      if (result.success) {
        setActionMessage(`Successfully uninstalled ${extension.name}`);
        
        // Refresh extensions
        await loadExtensions();
      } else {
        setActionMessage(`Failed to uninstall ${extension.name}: ${result.error}`);
      }
    } catch (err) {
      setActionMessage(`Failed to uninstall extension: ${err.message}`);
    } finally {
      setTimeout(() => {
        setActionMessage(null);
      }, 3000);
    }
  };
  
  // Handle extension rating
  const rateExtension = async (extension: Extension, rating: number) => {
    try {
      setActionMessage(`Rating ${extension.name}...`);
      
      const result = await marketplaceService.rateExtension(extension.id, rating);
      
      if (result.success) {
        setActionMessage(`Successfully rated ${extension.name}`);
        
        // Refresh extensions
        await loadExtensions();
        
        // Refresh extension details
        if (selectedExtension && selectedExtension.id === extension.id) {
          const updatedExtension = await marketplaceService.getExtensionDetails(extension.id);
          setSelectedExtension(updatedExtension);
        }
      } else {
        setActionMessage(`Failed to rate ${extension.name}: ${result.error}`);
      }
    } catch (err) {
      setActionMessage(`Failed to rate extension: ${err.message}`);
    } finally {
      setTimeout(() => {
        setActionMessage(null);
      }, 3000);
    }
  };
  
  // Handle search submission
  const handleSearch = () => {
    setQueryOptions({
      ...queryOptions,
      search: searchQuery
    });
    setViewMode('list');
  };
  
  // Handle sort selection
  const handleSortChange = (sortOption: ExtensionSortOption) => {
    setQueryOptions({
      ...queryOptions,
      sort: sortOption
    });
    setViewMode('list');
  };
  
  // Handle filter selection
  const handleFilterChange = (category: ExtensionCategory) => {
    setQueryOptions({
      ...queryOptions,
      filter: {
        ...queryOptions.filter,
        category
      }
    });
    setViewMode('list');
  };
  
  // Handle user input
  useInput((input, key) => {
    if (viewMode === 'list') {
      if (key.escape || input === 'q') {
        onClose();
        return;
      }
      
      if (key.upArrow || input === 'k') {
        setSelectedExtensionIndex(prev => (prev > 0 ? prev - 1 : prev));
        if (extensions[selectedExtensionIndex - 1]) {
          setSelectedExtension(extensions[selectedExtensionIndex - 1]);
        }
      }
      
      if (key.downArrow || input === 'j') {
        setSelectedExtensionIndex(prev => 
          (prev < extensions.length - 1 ? prev + 1 : prev)
        );
        if (extensions[selectedExtensionIndex + 1]) {
          setSelectedExtension(extensions[selectedExtensionIndex + 1]);
        }
      }
      
      if (key.return && extensions.length > 0) {
        setSelectedExtension(extensions[selectedExtensionIndex]);
        setViewMode('detail');
      }
      
      if (input === 's') {
        setViewMode('search');
      }
      
      if (input === 'f') {
        setViewMode('filter');
      }
      
      if (input === 'r') {
        loadExtensions();
      }
    } else if (viewMode === 'detail') {
      if (key.escape) {
        setViewMode('list');
      }
      
      if (selectedExtension) {
        if (input === 'i' && !selectedExtension.installed) {
          installExtension(selectedExtension);
        }
        
        if (input === 'u' && selectedExtension.installed) {
          uninstallExtension(selectedExtension);
        }
        
        if (input === 'r') {
          setViewMode('rate');
        }
      }
    } else if (viewMode === 'search' || viewMode === 'filter' || viewMode === 'rate') {
      if (key.escape) {
        setViewMode('list');
      }
    }
  });
  
  if (loading && extensions.length === 0) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Loading extensions..." />
      </Box>
    );
  }
  
  if (error) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color="red">{error}</Text>
        <Text>Press any key to retry</Text>
      </Box>
    );
  }
  
  // Extension List View
  if (viewMode === 'list') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Extension Marketplace</Text>
          <Text dimColor> - Press S to search, F to filter, R to refresh, Q to quit</Text>
        </Box>
        
        {extensions.length === 0 ? (
          <Text>No extensions found.</Text>
        ) : (
          <>
            {extensions.map((extension, index) => (
              <Box 
                key={extension.id} 
                flexDirection="row" 
                padding={1}
                backgroundColor={index === selectedExtensionIndex ? 'blue' : undefined}
              >
                <Box width={3}>
                  <Text>{extension.installed ? '✓' : '☐'}</Text>
                </Box>
                <Box width={25}>
                  <Text>{extension.name}</Text>
                </Box>
                <Box width={12}>
                  <Text dimColor>v{extension.version}</Text>
                </Box>
                <Box width={10}>
                  <Text dimColor>★ {extension.rating.toFixed(1)}</Text>
                </Box>
                <Box width={10}>
                  <Text dimColor>↓ {extension.downloads}</Text>
                </Box>
                <Box>
                  <Text dimColor>{extension.description}</Text>
                </Box>
              </Box>
            ))}
          </>
        )}
        
        {actionMessage && (
          <Box marginTop={1}>
            <Text color="yellow">{actionMessage}</Text>
          </Box>
        )}
      </Box>
    );
  }
  
  // Extension Detail View
  if (viewMode === 'detail' && selectedExtension) {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>{selectedExtension.name} v{selectedExtension.version}</Text>
          <Text dimColor>
            {' - Press ESC to go back'}
            {!selectedExtension.installed && ', I to install'}
            {selectedExtension.installed && ', U to uninstall'}
            {', R to rate'}
          </Text>
        </Box>
        
        <Box marginY={1}>
          <Text>{selectedExtension.description}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Author: </Text>
          <Text>{selectedExtension.author}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Category: </Text>
          <Text>{selectedExtension.category}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Rating: </Text>
          <Text>★ {selectedExtension.rating.toFixed(1)} ({selectedExtension.ratingCount} ratings)</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Downloads: </Text>
          <Text>{selectedExtension.downloads}</Text>
        </Box>
        
        <Box marginY={1}>
          <Text bold>Last Updated: </Text>
          <Text>{new Date(selectedExtension.lastUpdated).toLocaleDateString()}</Text>
        </Box>
        
        {selectedExtension.tags && selectedExtension.tags.length > 0 && (
          <Box marginY={1}>
            <Text bold>Tags: </Text>
            <Text>{selectedExtension.tags.join(', ')}</Text>
          </Box>
        )}
        
        {selectedExtension.longDescription && (
          <Box marginY={1} flexDirection="column">
            <Text bold>Description:</Text>
            <Box marginLeft={2} marginTop={1}>
              <Text>{selectedExtension.longDescription}</Text>
            </Box>
          </Box>
        )}
        
        {actionMessage && (
          <Box marginTop={1}>
            <Text color="yellow">{actionMessage}</Text>
          </Box>
        )}
      </Box>
    );
  }
  
  // Search View
  if (viewMode === 'search') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Search Extensions</Text>
          <Text dimColor> - Press ESC to cancel</Text>
        </Box>
        
        <Box marginY={1}>
          <Text>Enter search query:</Text>
        </Box>
        
        <TextInput 
          value={searchQuery} 
          onChange={setSearchQuery} 
          placeholder="Search..."
          onSubmit={handleSearch}
        />
        
        <Box marginTop={2}>
          <Text>Press Enter to search</Text>
        </Box>
      </Box>
    );
  }
  
  // Filter View
  if (viewMode === 'filter') {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Filter Extensions</Text>
          <Text dimColor> - Press ESC to cancel</Text>
        </Box>
        
        <Box marginY={1}>
          <Text>Select category:</Text>
        </Box>
        
        <SelectInput
          items={[
            { label: 'All Categories', value: undefined },
            ...Object.values(ExtensionCategory).map(category => ({
              label: category.charAt(0).toUpperCase() + category.slice(1),
              value: category
            }))
          ]}
          onSelect={item => handleFilterChange(item.value)}
          onCancel={() => setViewMode('list')}
        />
        
        <Box marginY={1}>
          <Text>Select sort order:</Text>
        </Box>
        
        <SelectInput
          items={[
            { label: 'Downloads', value: ExtensionSortOption.DOWNLOADS },
            { label: 'Rating', value: ExtensionSortOption.RATING },
            { label: 'Newest', value: ExtensionSortOption.NEWEST },
            { label: 'Last Updated', value: ExtensionSortOption.UPDATED },
            { label: 'Name', value: ExtensionSortOption.NAME }
          ]}
          onSelect={item => handleSortChange(item.value)}
          onCancel={() => setViewMode('list')}
        />
      </Box>
    );
  }
  
  // Rate View
  if (viewMode === 'rate' && selectedExtension) {
    return (
      <Box flexDirection="column" padding={1}>
        <Box marginBottom={1}>
          <Text bold>Rate {selectedExtension.name}</Text>
          <Text dimColor> - Press ESC to cancel</Text>
        </Box>
        
        <Box marginY={1}>
          <Text>Select rating (1-5):</Text>
        </Box>
        
        <SelectInput
          items={[
            { label: '★★★★★ (5) Excellent', value: 5 },
            { label: '★★★★☆ (4) Good', value: 4 },
            { label: '★★★☆☆ (3) Average', value: 3 },
            { label: '★★☆☆☆ (2) Poor', value: 2 },
            { label: '★☆☆☆☆ (1) Very Poor', value: 1 }
          ]}
          onSelect={item => {
            setRatingValue(item.value);
            rateExtension(selectedExtension, item.value);
            setViewMode('detail');
          }}
          onCancel={() => setViewMode('detail')}
        />
      </Box>
    );
  }
  
  return null;
};
```

### 5. Create Marketplace Hook
Create a custom hook at `src/hooks/useMarketplaceService.ts`:

```typescript
import { useContext } from 'react';
import { AppContext } from '../context/AppContext';
import { MarketplaceService } from '../services/MarketplaceService';

/**
 * Hook to access the MarketplaceService instance
 */
export function useMarketplaceService(): MarketplaceService {
  const { services } = useContext(AppContext);
  
  if (!services.marketplaceService) {
    throw new Error('MarketplaceService not available in context');
  }
  
  return services.marketplaceService;
}
```

### 6. Create Marketplace Command
Create a command file at `src/commands/marketplace.ts`:

```typescript
import { Command } from '../types/Command';
import { render } from 'ink';
import React from 'react';
import { Marketplace } from '../components/marketplace/Marketplace';
import { createAppContext } from '../context/createAppContext';
import { ExtensionCategory, ExtensionSortOption } from '../types/Marketplace';

/**
 * Command for accessing the extension marketplace
 */
export const marketplaceCommand: Command = {
  name: 'marketplace',
  description: 'Browse and install extensions from the marketplace',
  alias: 'market',
  options: [
    {
      name: 'list',
      description: 'List available extensions',
      alias: 'l',
      type: 'boolean'
    },
    {
      name: 'search',
      description: 'Search for extensions',
      alias: 's',
      type: 'string'
    },
    {
      name: 'category',
      description: 'Filter by category',
      alias: 'c',
      type: 'string'
    },
    {
      name: 'install',
      description: 'Install an extension',
      alias: 'i',
      type: 'string'
    },
    {
      name: 'uninstall',
      description: 'Uninstall an extension',
      alias: 'u',
      type: 'string'
    },
    {
      name: 'info',
      description: 'Get detailed information about an extension',
      type: 'string'
    }
  ],
  
  async execute(args, options): Promise<void> {
    const context = await createAppContext();
    const { marketplaceService } = context.services;
    
    // Install extension
    if (options.install) {
      console.log(`Installing extension: ${options.install}`);
      const result = await marketplaceService.installExtension(options.install);
      
      if (result.success) {
        console.log(`✅ Extension ${options.install} installed successfully`);
      } else {
        console.error(`❌ Failed to install extension: ${result.error}`);
      }
      return;
    }
    
    // Uninstall extension
    if (options.uninstall) {
      console.log(`Uninstalling extension: ${options.uninstall}`);
      const result = await marketplaceService.uninstallExtension(options.uninstall);
      
      if (result.success) {
        console.log(`✅ Extension ${options.uninstall} uninstalled successfully`);
      } else {
        console.error(`❌ Failed to uninstall extension: ${result.error}`);
      }
      return;
    }
    
    // Get extension info
    if (options.info) {
      try {
        const extension = await marketplaceService.getExtensionDetails(options.info);
        
        console.log(`Extension: ${extension.name} v${extension.version}`);
        console.log(`Description: ${extension.description}`);
        console.log(`Author: ${extension.author}`);
        console.log(`Category: ${extension.category}`);
        console.log(`Rating: ${extension.rating.toFixed(1)} (${extension.ratingCount} ratings)`);
        console.log(`Downloads: ${extension.downloads}`);
        console.log(`Published: ${new Date(extension.publishedDate).toLocaleDateString()}`);
        console.log(`Last Updated: ${new Date(extension.lastUpdated).toLocaleDateString()}`);
        console.log(`Repository: ${extension.repository}`);
        console.log(`Package: ${extension.packageName}`);
        console.log(`Tags: ${extension.tags.join(', ')}`);
        console.log(`Status: ${extension.installed ? 'Installed' : 'Not Installed'}`);
        
        if (extension.longDescription) {
          console.log(`\n${extension.longDescription}`);
        }
      } catch (error) {
        console.error(`❌ Extension not found: ${options.info}`);
      }
      return;
    }
    
    // List extensions
    if (options.list) {
      const queryOptions: any = {
        sort: ExtensionSortOption.DOWNLOADS
      };
      
      // Apply category filter
      if (options.category) {
        const category = options.category.toLowerCase();
        if (Object.values(ExtensionCategory).includes(category as ExtensionCategory)) {
          queryOptions.filter = {
            category: category as ExtensionCategory
          };
        } else {
          console.error(`❌ Invalid category: ${options.category}`);
          console.log(`Valid categories: ${Object.values(ExtensionCategory).join(', ')}`);
          return;
        }
      }
      
      // Apply search filter
      if (options.search) {
        queryOptions.search = options.search;
      }
      
      const extensions = await marketplaceService.getExtensions(queryOptions);
      
      console.log('Extensions:');
      
      if (extensions.length === 0) {
        console.log('No extensions found');
      } else {
        extensions.forEach(extension => {
          console.log(`- ${extension.name} v${extension.version} [${extension.installed ? 'Installed' : 'Not Installed'}]`);
          console.log(`  ${extension.description}`);
          console.log(`  Rating: ${extension.rating.toFixed(1)} | Downloads: ${extension.downloads} | Category: ${extension.category}`);
          console.log();
        });
      }
      return;
    }
    
    // Default: show marketplace UI
    const { waitUntilExit } = render(
      React.createElement(
        Marketplace, 
        { onClose: () => process.exit(0) }
      )
    );
    
    await waitUntilExit();
  }
};
```

### 7. Create Extension Submission Component
Create a UI component file at `src/components/marketplace/ExtensionSubmission.tsx`:

```typescript
import React, { useState } from 'react';
import { Box, Text } from 'ink';
import { useMarketplaceService } from '../../hooks/useMarketplaceService';
import { ExtensionCategory } from '../../types/Marketplace';
import TextInput from '../inputs/TextInput';
import SelectInput from '../inputs/SelectInput';
import { Spinner } from '../feedback/Spinner';

interface ExtensionSubmissionProps {
  onComplete: () => void;
}

type Step = 'name' | 'description' | 'category' | 'repository' | 'package' | 'tags' | 'submit';

/**
 * Component for submitting a new extension to the marketplace
 */
export const ExtensionSubmission: React.FC<ExtensionSubmissionProps> = ({
  onComplete
}) => {
  const marketplaceService = useMarketplaceService();
  
  const [step, setStep] = useState<Step>('name');
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [category, setCategory] = useState<ExtensionCategory>(ExtensionCategory.UTILITY);
  const [repository, setRepository] = useState('');
  const [packageName, setPackageName] = useState('');
  const [tags, setTags] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [result, setResult] = useState<{ success: boolean; message: string } | null>(null);
  
  // Handle submission
  const handleSubmit = async () => {
    try {
      setSubmitting(true);
      
      const result = await marketplaceService.submitExtension({
        name,
        description,
        category,
        repository,
        packageName,
        tags: tags.split(',').map(tag => tag.trim()).filter(tag => tag)
      });
      
      if (result.success) {
        setResult({
          success: true,
          message: `Extension submitted successfully with ID: ${result.id}`
        });
      } else {
        setResult({
          success: false,
          message: `Failed to submit extension: ${result.error}`
        });
      }
    } catch (error) {
      setResult({
        success: false,
        message: `Error: ${error.message}`
      });
    } finally {
      setSubmitting(false);
    }
  };
  
  // Move to next step
  const nextStep = () => {
    switch (step) {
      case 'name':
        setStep('description');
        break;
      case 'description':
        setStep('category');
        break;
      case 'category':
        setStep('repository');
        break;
      case 'repository':
        setStep('package');
        break;
      case 'package':
        setStep('tags');
        break;
      case 'tags':
        setStep('submit');
        break;
      case 'submit':
        handleSubmit();
        break;
    }
  };
  
  // Name step
  if (step === 'name') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Name</Text>
        <Box marginY={1}>
          <Text>Enter the name of your extension:</Text>
        </Box>
        <TextInput 
          value={name}
          onChange={setName}
          placeholder="Extension Name"
          onSubmit={nextStep}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Description step
  if (step === 'description') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Description</Text>
        <Box marginY={1}>
          <Text>Enter a short description:</Text>
        </Box>
        <TextInput 
          value={description}
          onChange={setDescription}
          placeholder="A short description of your extension"
          onSubmit={nextStep}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Category step
  if (step === 'category') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Category</Text>
        <Box marginY={1}>
          <Text>Select a category:</Text>
        </Box>
        <SelectInput
          items={Object.values(ExtensionCategory).map(cat => ({
            label: cat.charAt(0).toUpperCase() + cat.slice(1),
            value: cat
          }))}
          onSelect={item => {
            setCategory(item.value);
            nextStep();
          }}
        />
      </Box>
    );
  }
  
  // Repository step
  if (step === 'repository') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Repository</Text>
        <Box marginY={1}>
          <Text>Enter the repository URL:</Text>
        </Box>
        <TextInput 
          value={repository}
          onChange={setRepository}
          placeholder="https://github.com/username/repo"
          onSubmit={nextStep}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Package step
  if (step === 'package') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Package Name</Text>
        <Box marginY={1}>
          <Text>Enter the npm package name:</Text>
        </Box>
        <TextInput 
          value={packageName}
          onChange={setPackageName}
          placeholder="zencommit-plugin-name"
          onSubmit={nextStep}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Tags step
  if (step === 'tags') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Tags</Text>
        <Box marginY={1}>
          <Text>Enter tags, separated by commas:</Text>
        </Box>
        <TextInput 
          value={tags}
          onChange={setTags}
          placeholder="tag1, tag2, tag3"
          onSubmit={nextStep}
        />
        <Box marginTop={2}>
          <Text>Press Enter to continue</Text>
        </Box>
      </Box>
    );
  }
  
  // Submit step
  if (step === 'submit') {
    return (
      <Box flexDirection="column" padding={1}>
        <Text bold>Submit Extension - Review</Text>
        <Box marginY={1} flexDirection="column">
          <Text>Name: {name}</Text>
          <Text>Description: {description}</Text>
          <Text>Category: {category}</Text>
          <Text>Repository: {repository}</Text>
          <Text>Package: {packageName}</Text>
          <Text>Tags: {tags}</Text>
        </Box>
        <Box marginY={1}>
          <Text>Press Enter to submit or Escape to cancel</Text>
        </Box>
      </Box>
    );
  }
  
  // Submitting
  if (submitting) {
    return (
      <Box flexDirection="column" padding={1}>
        <Spinner text="Submitting extension..." />
      </Box>
    );
  }
  
  // Result
  if (result) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color={result.success ? 'green' : 'red'} bold>
          {result.message}
        </Text>
        <Box marginY={1}>
          <Text>Press Enter to close</Text>
        </Box>
      </Box>
    );
  }
  
  return null;
};
```

### 8. Update Core Exports
Update `src/index.ts` to include the marketplace service:

```typescript
// Add to imports
import { MarketplaceService } from './services/MarketplaceService';
import { marketplaceCommand } from './commands/marketplace';

// Add to commandRegistry
commandRegistry.register(marketplaceCommand);

// Add to service initialization
const marketplaceService = new MarketplaceService(
  pluginService,
  configService,
  userPreferencesService
);

// Add to context
context.services.marketplaceService = marketplaceService;
```

### 9. Update App Context Type
Update `src/context/AppContext.ts`:

```typescript
import { MarketplaceService } from '../services/MarketplaceService';

// Add to Services interface
export interface Services {
  // ... existing services
  marketplaceService: MarketplaceService;
}
```

### 10. Create Extension Repository Server
Create a simple server implementation to handle extension repository API calls.

Create a file at `server/marketplace-api.js`:

```javascript
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(bodyParser.json());

// Data storage
const dataDir = path.join(__dirname, 'data');
const extensionsFile = path.join(dataDir, 'extensions.json');
const usersFile = path.join(dataDir, 'users.json');

// Ensure data directory exists
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir, { recursive: true });
}

// Initialize extensions data if it doesn't exist
if (!fs.existsSync(extensionsFile)) {
  fs.writeFileSync(extensionsFile, JSON.stringify([], null, 2));
}

// Initialize users data if it doesn't exist
if (!fs.existsSync(usersFile)) {
  fs.writeFileSync(usersFile, JSON.stringify([], null, 2));
}

// Helper functions
function getExtensions() {
  const data = fs.readFileSync(extensionsFile, 'utf-8');
  return JSON.parse(data);
}

function saveExtensions(extensions) {
  fs.writeFileSync(extensionsFile, JSON.stringify(extensions, null, 2));
}

function getUsers() {
  const data = fs.readFileSync(usersFile, 'utf-8');
  return JSON.parse(data);
}

function saveUsers(users) {
  fs.writeFileSync(usersFile, JSON.stringify(users, null, 2));
}

// Routes

// Get all extensions
app.get('/extensions', (req, res) => {
  let extensions = getExtensions();
  
  // Filter by search query
  if (req.query.search) {
    const search = req.query.search.toLowerCase();
    extensions = extensions.filter(extension => 
      extension.name.toLowerCase().includes(search) ||
      extension.description.toLowerCase().includes(search) ||
      extension.tags.some(tag => tag.toLowerCase().includes(search))
    );
  }
  
  // Filter by category
  if (req.query.category) {
    extensions = extensions.filter(extension => 
      extension.category === req.query.category
    );
  }
  
  // Filter by author
  if (req.query.author) {
    extensions = extensions.filter(extension => 
      extension.author === req.query.author
    );
  }
  
  // Filter by tags
  if (req.query.tags) {
    const tags = req.query.tags.split(',');
    extensions = extensions.filter(extension => 
      tags.some(tag => extension.tags.includes(tag))
    );
  }
  
  // Sort by downloads, rating, etc.
  if (req.query.sort) {
    const sort = req.query.sort;
    
    if (sort === 'downloads') {
      extensions.sort((a, b) => b.downloads - a.downloads);
    } else if (sort === 'rating') {
      extensions.sort((a, b) => b.rating - a.rating);
    } else if (sort === 'newest') {
      extensions.sort((a, b) => new Date(b.publishedDate) - new Date(a.publishedDate));
    } else if (sort === 'updated') {
      extensions.sort((a, b) => new Date(b.lastUpdated) - new Date(a.lastUpdated));
    } else if (sort === 'name') {
      extensions.sort((a, b) => a.name.localeCompare(b.name));
    }
  }
  
  // Pagination
  const page = parseInt(req.query.page) || 1;
  const pageSize = parseInt(req.query.pageSize) || 10;
  const startIndex = (page - 1) * pageSize;
  const endIndex = startIndex + pageSize;
  
  res.json(extensions.slice(startIndex, endIndex));
});

// Get extension details
app.get('/extensions/:id', (req, res) => {
  const extensions = getExtensions();
  const extension = extensions.find(ext => ext.id === req.params.id);
  
  if (!extension) {
    return res.status(404).json({ error: 'Extension not found' });
  }
  
  res.json(extension);
});

// Rate an extension
app.post('/extensions/:id/rate', (req, res) => {
  const { rating } = req.body;
  
  if (!rating || rating < 1 || rating > 5) {
    return res.status(400).json({ error: 'Invalid rating' });
  }
  
  const extensions = getExtensions();
  const extension = extensions.find(ext => ext.id === req.params.id);
  
  if (!extension) {
    return res.status(404).json({ error: 'Extension not found' });
  }
  
  // Update rating
  const newRatingCount = extension.ratingCount + 1;
  const newRating = ((extension.rating * extension.ratingCount) + rating) / newRatingCount;
  
  extension.rating = newRating;
  extension.ratingCount = newRatingCount;
  
  saveExtensions(extensions);
  
  res.json({
    success: true,
    rating: newRating,
    ratingCount: newRatingCount
  });
});

// Submit a new extension
app.post('/extensions/submit', (req, res) => {
  const { name, description, category, repository, packageName, tags } = req.body;
  
  if (!name || !description || !category || !repository || !packageName) {
    return res.status(400).json({ error: 'Missing required fields' });
  }
  
  const extensions = getExtensions();
  
  // Check if package name is already used
  if (extensions.some(ext => ext.packageName === packageName)) {
    return res.status(400).json({ error: 'Package name already exists' });
  }
  
  const newId = `ext-${Date.now()}`;
  
  const newExtension = {
    id: newId,
    name,
    description,
    version: '1.0.0',
    author: 'Anonymous', // In a real app, this would come from auth
    downloads: 0,
    rating: 0,
    ratingCount: 0,
    category,
    publishedDate: new Date().toISOString(),
    lastUpdated: new Date().toISOString(),
    repository,
    packageName,
    tags: tags || []
  };
  
  extensions.push(newExtension);
  saveExtensions(extensions);
  
  res.json({
    success: true,
    id: newId
  });
});

// Track extension installation
app.post('/analytics/install', (req, res) => {
  const { extensionId } = req.body;
  
  if (!extensionId) {
    return res.status(400).json({ error: 'Missing extension ID' });
  }
  
  const extensions = getExtensions();
  const extension = extensions.find(ext => ext.id === extensionId);
  
  if (!extension) {
    return res.status(404).json({ error: 'Extension not found' });
  }
  
  // Increment download count
  extension.downloads += 1;
  saveExtensions(extensions);
  
  res.json({
    success: true
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`Marketplace API server running on port ${PORT}`);
});
```

### 11. Create Documentation
Create a documentation file at `docs/marketplace.md`:

```markdown
# Zen Commit Extension Marketplace

The Extension Marketplace allows you to discover, install, and manage plugins that extend Zen Commit's functionality. This document explains how to use the marketplace and how to submit your own extensions.

## Browsing the Marketplace

You can browse the marketplace using the following command:

```
zencommit marketplace
```

This will open an interactive UI where you can:

- Browse available extensions
- Search for extensions
- Filter extensions by category
- Sort extensions by popularity, rating, or release date
- View detailed information about extensions
- Install and uninstall extensions
- Rate extensions

## Command Line Usage

You can also use the marketplace from the command line:

```
# List available extensions
zencommit marketplace --list

# Search for extensions
zencommit marketplace --search "git"

# Filter by category
zencommit marketplace --list --category integration

# Get details about an extension
zencommit marketplace --info extension-id

# Install an extension
zencommit marketplace --install extension-id

# Uninstall an extension
zencommit marketplace --uninstall extension-id
```

## Extension Categories

Extensions are organized into the following categories:

- **integration**: Extensions that integrate with external services
- **template**: Extensions that provide commit message templates
- **formatter**: Extensions that format commit messages
- **validator**: Extensions that validate commit messages
- **utility**: Extensions that provide utility functions
- **theme**: Extensions that customize the appearance
- **other**: Extensions that don't fit into other categories

## Installing Extensions

When you install an extension from the marketplace, it is downloaded from npm and added to your project. Extensions are installed as npm packages with names starting with `zencommit-plugin-`.

By default, extensions are enabled automatically after installation. You can manage extensions using the `plugin` command:

```
# List installed extensions
zencommit plugin --list

# Enable/disable extensions
zencommit plugin --enable extension-id
zencommit plugin --disable extension-id
```

## Submitting Extensions

To submit your extension to the marketplace, you need to:

1. Create a plugin following the [Plugin Development Guide](./plugin-development.md)
2. Publish your plugin to npm with a name starting with `zencommit-plugin-`
3. Submit your extension to the marketplace:

```
# Open the submission form
zencommit marketplace --submit
```

Alternatively, you can submit via the API:

```bash
curl -X POST https://api.zencommit.io/extensions/submit \
  -H "Content-Type: application/json" \
  -d '{
    "name": "My Extension",
    "description": "A brief description",
    "category": "utility",
    "repository": "https://github.com/username/repo",
    "packageName": "zencommit-plugin-myextension",
    "tags": ["tag1", "tag2"]
  }'
```

## Extension Guidelines

When submitting an extension, please follow these guidelines:

1. **Security**: Your extension should not compromise the security of the user's system.
2. **Quality**: Your extension should be well-tested and include proper error handling.
3. **Documentation**: Include clear documentation on how to use your extension.
4. **Functionality**: Your extension should provide valuable functionality.
5. **Maintenance**: Be prepared to maintain your extension and fix bugs.

## Extension Review Process

Submitted extensions go through a review process before being published. The review checks for:

1. Code quality and security
2. Adherence to plugin architecture
3. Proper documentation
4. Uniqueness and usefulness

The review process typically takes 1-3 business days.

## Rating Extensions

You can rate extensions to help other users find quality plugins. Ratings are on a scale of 1-5 stars, with 5 being the highest.

To rate an extension:

1. Open the marketplace: `zencommit marketplace`
2. Select an extension and press `r` to rate
3. Choose a rating and submit

Your ratings help the community identify the most valuable extensions.
```

## Definition of Done
- Marketplace service implemented with API integration
- Extension discovery and search functionality
- Extension installation and management
- Extension rating system
- Extension submission workflow
- Marketplace UI for browsing and installing extensions
- Command-line interface for marketplace operations
- Documentation for using and submitting to the marketplace

## Potential Blockers
- API availability and reliability
- Authentication and security considerations
- Extension versioning and compatibility
- Extension quality assurance
- Performance considerations for large repositories

## Next Steps
- Gather user feedback to improve the marketplace
- Expand marketplace features with categories and collections
- Implement advanced search and filtering options
- Develop extension analytics and statistics