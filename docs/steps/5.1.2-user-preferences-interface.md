# 5.1.2 User Preferences Interface

## Overview
This step implements a user preferences interface that allows users to customize their experience with the application. The interface will include settings for commit message templates, UI appearance, default behaviors, and personalization options, all accessible through an intuitive terminal UI.

## Dependencies
- Configuration Schema Definition (3.3.2)
- Per-Project Settings Implementation (3.3.3)
- Base UI Component Library (1.2.3)

## Prerequisites
- Completed Configuration Schema Definition (3.3.2)
- Completed Per-Project Settings Implementation (3.3.3)
- Working Base UI Component Library (1.2.3)

## Implementation Order
1. Create preferences service
2. Implement settings UI components
3. Develop preferences command
4. Add settings validation logic
5. Implement settings persistence

## Development Guidelines
- Make settings intuitive and easy to understand
- Group related settings together
- Provide sensible defaults
- Implement validation for all settings
- Support both global and project-specific settings
- Allow importing and exporting preferences

## Tasks

### 1. Create Test File for User Preferences Service
```typescript
// __tests__/services/userPreferencesService.test.ts
import { UserPreferencesService } from '../../src/services/userPreferencesService';
import { ConfigurationManager } from '../../src/services/configurationManager';
import * as fs from 'fs/promises';
import * as path from 'path';

// Mock dependencies
jest.mock('../../src/services/configurationManager');
jest.mock('fs/promises');
jest.mock('path');

describe('UserPreferencesService', () => {
  let preferencesService: UserPreferencesService;
  let mockConfigManager: jest.Mocked<ConfigurationManager>;
  
  const defaultPreferences = {
    ui: {
      theme: 'default',
      colorScheme: 'dark',
      compactMode: false
    },
    commitTemplate: {
      defaultType: 'feat',
      enableScope: true,
      requireBody: false,
      charactersPerLine: 72
    },
    validation: {
      enforceConventionalCommits: true,
      maxHeaderLength: 50,
      warnOnLongBody: true
    },
    behavior: {
      confirmBeforeCommit: true,
      showHelpText: true,
      rememberLastTemplate: true
    }
  };
  
  beforeEach(() => {
    mockConfigManager = new ConfigurationManager() as jest.Mocked<ConfigurationManager>;
    
    // Mock configuration
    mockConfigManager.getConfiguration.mockResolvedValue({
      preferences: defaultPreferences
    });
    
    mockConfigManager.saveConfiguration.mockResolvedValue(true);
    mockConfigManager.getConfigPath.mockReturnValue('/mock/config/path.json');
    
    // Mock path.join
    (path.join as jest.Mock).mockImplementation((...args) => args.join('/'));
    
    preferencesService = new UserPreferencesService(mockConfigManager);
  });
  
  test('should get user preferences', async () => {
    const preferences = await preferencesService.getPreferences();
    
    expect(preferences).toEqual(defaultPreferences);
  });
  
  test('should update preferences', async () => {
    const updates = {
      ui: {
        theme: 'modern',
        colorScheme: 'light'
      }
    };
    
    await preferencesService.updatePreferences(updates);
    
    expect(mockConfigManager.saveConfiguration).toHaveBeenCalledWith(
      expect.objectContaining({
        preferences: {
          ...defaultPreferences,
          ui: {
            ...defaultPreferences.ui,
            theme: 'modern',
            colorScheme: 'light'
          }
        }
      })
    );
  });
  
  test('should reset preferences to defaults', async () => {
    await preferencesService.resetToDefaults();
    
    expect(mockConfigManager.saveConfiguration).toHaveBeenCalledWith(
      expect.objectContaining({
        preferences: preferencesService.getDefaultPreferences()
      })
    );
  });
  
  test('should export preferences to file', async () => {
    const exportPath = '/mock/export/preferences.json';
    
    await preferencesService.exportPreferences(exportPath);
    
    expect(fs.writeFile).toHaveBeenCalledWith(
      exportPath,
      expect.any(String),
      'utf-8'
    );
  });
  
  test('should import preferences from file', async () => {
    const importPath = '/mock/import/preferences.json';
    const importedPrefs = {
      ui: {
        theme: 'imported',
        colorScheme: 'custom'
      },
      commitTemplate: {
        defaultType: 'chore'
      }
    };
    
    // Mock reading the file
    (fs.readFile as jest.Mock).mockResolvedValue(JSON.stringify(importedPrefs));
    
    await preferencesService.importPreferences(importPath);
    
    // Should merge with existing defaults
    expect(mockConfigManager.saveConfiguration).toHaveBeenCalledWith(
      expect.objectContaining({
        preferences: {
          ...defaultPreferences,
          ui: {
            ...defaultPreferences.ui,
            theme: 'imported',
            colorScheme: 'custom'
          },
          commitTemplate: {
            ...defaultPreferences.commitTemplate,
            defaultType: 'chore'
          }
        }
      })
    );
  });
  
  test('should validate preferences', async () => {
    const validPrefs = {
      ui: {
        theme: 'modern',
        colorScheme: 'dark'
      }
    };
    
    const invalidPrefs = {
      ui: {
        theme: 'invalid-theme', // Not in allowed values
        colorScheme: 'dark'
      }
    };
    
    expect(await preferencesService.validatePreferences(validPrefs)).toBe(true);
    expect(await preferencesService.validatePreferences(invalidPrefs)).toBe(false);
  });
  
  test('should get specific preferences section', async () => {
    const uiPrefs = await preferencesService.getPreferenceSection('ui');
    const commitPrefs = await preferencesService.getPreferenceSection('commitTemplate');
    
    expect(uiPrefs).toEqual(defaultPreferences.ui);
    expect(commitPrefs).toEqual(defaultPreferences.commitTemplate);
  });
  
  test('should get preference schemas', () => {
    const schemas = preferencesService.getPreferenceSchemas();
    
    expect(schemas).toBeDefined();
    expect(schemas.ui).toBeDefined();
    expect(schemas.commitTemplate).toBeDefined();
    expect(schemas.validation).toBeDefined();
    expect(schemas.behavior).toBeDefined();
  });
  
  test('should handle per-project settings', async () => {
    // Mock project-specific config
    mockConfigManager.getProjectConfiguration.mockResolvedValue({
      preferences: {
        commitTemplate: {
          defaultType: 'fix',
          enableScope: false
        }
      }
    });
    
    // Get project preferences
    const projectPrefs = await preferencesService.getProjectPreferences();
    
    // Should include project-specific overrides
    expect(projectPrefs.commitTemplate.defaultType).toBe('fix');
    expect(projectPrefs.commitTemplate.enableScope).toBe(false);
    
    // Other preferences should fall back to global defaults
    expect(projectPrefs.ui.theme).toBe(defaultPreferences.ui.theme);
  });
});
```

### 2. Create Test File for Preferences Form Component
```typescript
// __tests__/components/preferencesForm.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { PreferencesForm } from '../../src/components/preferencesForm';
import { UserPreferencesService } from '../../src/services/userPreferencesService';

// Mock the preferences service
jest.mock('../../src/services/userPreferencesService');

describe('PreferencesForm', () => {
  let mockPreferencesService: jest.Mocked<UserPreferencesService>;
  
  const mockPreferences = {
    ui: {
      theme: 'default',
      colorScheme: 'dark',
      compactMode: false
    },
    commitTemplate: {
      defaultType: 'feat',
      enableScope: true,
      requireBody: false,
      charactersPerLine: 72
    },
    validation: {
      enforceConventionalCommits: true,
      maxHeaderLength: 50,
      warnOnLongBody: true
    },
    behavior: {
      confirmBeforeCommit: true,
      showHelpText: true,
      rememberLastTemplate: true
    }
  };
  
  beforeEach(() => {
    mockPreferencesService = new UserPreferencesService() as jest.Mocked<UserPreferencesService>;
    
    mockPreferencesService.getPreferences.mockResolvedValue(mockPreferences);
    mockPreferencesService.getProjectPreferences.mockResolvedValue(mockPreferences);
    mockPreferencesService.getPreferenceSchemas.mockReturnValue({
      ui: {
        type: 'object',
        properties: {
          theme: {
            type: 'string',
            enum: ['default', 'modern', 'minimal'],
            description: 'UI theme to use'
          },
          colorScheme: {
            type: 'string',
            enum: ['dark', 'light'],
            description: 'Color scheme for the UI'
          },
          compactMode: {
            type: 'boolean',
            description: 'Use compact UI mode'
          }
        }
      },
      commitTemplate: {
        type: 'object',
        properties: {
          defaultType: {
            type: 'string',
            enum: ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore'],
            description: 'Default commit type'
          },
          enableScope: {
            type: 'boolean',
            description: 'Enable commit scope'
          }
        }
      }
    });
    
    mockPreferencesService.updatePreferences.mockResolvedValue(true);
  });
  
  test('should render preferences form with sections', () => {
    const { lastFrame } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Should show loading initially
    expect(lastFrame()).toContain('Loading preferences');
    
    // After loading
    setTimeout(() => {
      expect(lastFrame()).toContain('User Preferences');
      expect(lastFrame()).toContain('UI Settings');
      expect(lastFrame()).toContain('Commit Template');
      expect(lastFrame()).toContain('Validation');
      expect(lastFrame()).toContain('Behavior');
    }, 0);
  });
  
  test('should navigate between sections', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Should start with UI section selected
      expect(lastFrame()).toContain('● UI Settings');
      expect(lastFrame()).toContain('○ Commit Template');
      
      // Navigate to Commit Template section
      stdin.write('\t');
      
      expect(lastFrame()).toContain('○ UI Settings');
      expect(lastFrame()).toContain('● Commit Template');
      
      // Navigate to inputs for the section
      stdin.write('\n');
      
      // Should show commit template fields
      expect(lastFrame()).toContain('Default Commit Type');
      expect(lastFrame()).toContain('Enable Scope');
    }, 0);
  });
  
  test('should update string preference', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Navigate to UI section and select
      stdin.write('\n');
      
      // Should show theme field
      expect(lastFrame()).toContain('Theme');
      
      // Select theme field
      stdin.write('\n');
      
      // Should show theme options
      expect(lastFrame()).toContain('default');
      expect(lastFrame()).toContain('modern');
      expect(lastFrame()).toContain('minimal');
      
      // Select 'modern' theme
      stdin.write('\n');
      
      // Should update preference
      expect(mockPreferencesService.updatePreferences).toHaveBeenCalledWith({
        ui: {
          theme: 'modern'
        }
      });
    }, 0);
  });
  
  test('should update boolean preference', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Navigate to UI section and select
      stdin.write('\n');
      
      // Navigate to compactMode field
      stdin.write('\t');
      stdin.write('\t');
      
      // Select compactMode field
      stdin.write('\n');
      
      // Should toggle value
      expect(mockPreferencesService.updatePreferences).toHaveBeenCalledWith({
        ui: {
          compactMode: true
        }
      });
    }, 0);
  });
  
  test('should update number preference', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Navigate to Commit Template section
      stdin.write('\t');
      stdin.write('\n');
      
      // Navigate to charactersPerLine field
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      
      // Select charactersPerLine field
      stdin.write('\n');
      
      // Should show input for number
      expect(lastFrame()).toContain('Enter value');
      
      // Type new value
      stdin.write('80');
      stdin.write('\n');
      
      // Should update preference
      expect(mockPreferencesService.updatePreferences).toHaveBeenCalledWith({
        commitTemplate: {
          charactersPerLine: 80
        }
      });
    }, 0);
  });
  
  test('should reset preferences to defaults', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Navigate to Reset button
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      
      // Select Reset button
      stdin.write('\n');
      
      // Should show confirmation
      expect(lastFrame()).toContain('Are you sure?');
      
      // Confirm reset
      stdin.write('\n');
      
      expect(mockPreferencesService.resetToDefaults).toHaveBeenCalled();
    }, 0);
  });
  
  test('should import and export preferences', () => {
    const { lastFrame, stdin } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Navigate to Export button
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      
      // Select Export button
      stdin.write('\n');
      
      // Should show file path input
      expect(lastFrame()).toContain('Enter export path');
      
      // Enter export path
      stdin.write('/path/to/export.json');
      stdin.write('\n');
      
      expect(mockPreferencesService.exportPreferences).toHaveBeenCalledWith('/path/to/export.json');
      
      // Navigate to Import button
      stdin.write('\t');
      
      // Select Import button
      stdin.write('\n');
      
      // Should show file path input
      expect(lastFrame()).toContain('Enter import path');
      
      // Enter import path
      stdin.write('/path/to/import.json');
      stdin.write('\n');
      
      expect(mockPreferencesService.importPreferences).toHaveBeenCalledWith('/path/to/import.json');
    }, 0);
  });
  
  test('should show project-specific preferences', () => {
    const { lastFrame } = render(
      <PreferencesForm
        preferencesService={mockPreferencesService}
        projectMode={true}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      expect(lastFrame()).toContain('Project Preferences');
      expect(lastFrame()).toContain('(overrides global settings)');
    }, 0);
  });
});
```

### 3. Create Test File for Settings Section Component
```typescript
// __tests__/components/settingsSection.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { SettingsSection } from '../../src/components/settingsSection';

describe('SettingsSection', () => {
  const mockSchema = {
    type: 'object',
    properties: {
      theme: {
        type: 'string',
        enum: ['default', 'modern', 'minimal'],
        description: 'UI theme to use'
      },
      colorScheme: {
        type: 'string',
        enum: ['dark', 'light'],
        description: 'Color scheme for the UI'
      },
      compactMode: {
        type: 'boolean',
        description: 'Use compact UI mode'
      },
      fontSize: {
        type: 'number',
        minimum: 8,
        maximum: 24,
        description: 'Font size in points'
      }
    }
  };
  
  const mockPreferences = {
    theme: 'default',
    colorScheme: 'dark',
    compactMode: false,
    fontSize: 12
  };
  
  test('should render section with settings', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
      />
    );
    
    expect(lastFrame()).toContain('UI Settings');
    expect(lastFrame()).toContain('Theme');
    expect(lastFrame()).toContain('Color Scheme');
    expect(lastFrame()).toContain('Compact Mode');
    expect(lastFrame()).toContain('Font Size');
    
    // Should show current values
    expect(lastFrame()).toContain('default');
    expect(lastFrame()).toContain('dark');
    expect(lastFrame()).toContain('false');
    expect(lastFrame()).toContain('12');
  });
  
  test('should highlight focused setting', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
      />
    );
    
    // Section title should be highlighted
    expect(lastFrame()).toContain('● UI Settings');
  });
  
  test('should handle edit mode for string enum', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
        editMode={true}
        focusedSetting="theme"
      />
    );
    
    // Should show options for enum
    expect(lastFrame()).toContain('default');
    expect(lastFrame()).toContain('modern');
    expect(lastFrame()).toContain('minimal');
  });
  
  test('should handle edit mode for boolean', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
        editMode={true}
        focusedSetting="compactMode"
      />
    );
    
    // Should show boolean options
    expect(lastFrame()).toContain('true');
    expect(lastFrame()).toContain('false');
  });
  
  test('should handle edit mode for number', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
        editMode={true}
        focusedSetting="fontSize"
      />
    );
    
    // Should show number input
    expect(lastFrame()).toContain('Enter value (8-24)');
  });
  
  test('should call onChange when value changes', () => {
    const onChange = jest.fn();
    
    const { stdin } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
        editMode={true}
        focusedSetting="theme"
      />
    );
    
    // Select 'modern' theme
    stdin.write('\t');
    stdin.write('\n');
    
    expect(onChange).toHaveBeenCalledWith('theme', 'modern');
  });
  
  test('should show setting descriptions', () => {
    const onChange = jest.fn();
    
    const { lastFrame } = render(
      <SettingsSection
        title="UI Settings"
        schema={mockSchema}
        preferences={mockPreferences}
        onChange={onChange}
        focused={true}
        showDescriptions={true}
      />
    );
    
    expect(lastFrame()).toContain('UI theme to use');
    expect(lastFrame()).toContain('Color scheme for the UI');
    expect(lastFrame()).toContain('Use compact UI mode');
    expect(lastFrame()).toContain('Font size in points');
  });
});
```

### 4. Implement User Preferences Service
```typescript
// src/services/userPreferencesService.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { ConfigurationManager } from './configurationManager';

/**
 * Type definition for user preferences
 */
export interface UserPreferences {
  ui: {
    theme: string;
    colorScheme: string;
    compactMode: boolean;
    showIcons?: boolean;
  };
  commitTemplate: {
    defaultType: string;
    enableScope: boolean;
    requireBody: boolean;
    charactersPerLine: number;
  };
  validation: {
    enforceConventionalCommits: boolean;
    maxHeaderLength: number;
    warnOnLongBody: boolean;
  };
  behavior: {
    confirmBeforeCommit: boolean;
    showHelpText: boolean;
    rememberLastTemplate: boolean;
  };
}

/**
 * Service for managing user preferences
 */
export class UserPreferencesService {
  private readonly defaultPreferences: UserPreferences = {
    ui: {
      theme: 'default',
      colorScheme: 'dark',
      compactMode: false,
      showIcons: true
    },
    commitTemplate: {
      defaultType: 'feat',
      enableScope: true,
      requireBody: false,
      charactersPerLine: 72
    },
    validation: {
      enforceConventionalCommits: true,
      maxHeaderLength: 50,
      warnOnLongBody: true
    },
    behavior: {
      confirmBeforeCommit: true,
      showHelpText: true,
      rememberLastTemplate: true
    }
  };
  
  private readonly schemas = {
    ui: {
      type: 'object',
      properties: {
        theme: {
          type: 'string',
          enum: ['default', 'modern', 'minimal'],
          description: 'UI theme to use'
        },
        colorScheme: {
          type: 'string',
          enum: ['dark', 'light'],
          description: 'Color scheme for the UI'
        },
        compactMode: {
          type: 'boolean',
          description: 'Use compact UI mode'
        },
        showIcons: {
          type: 'boolean',
          description: 'Show icons in the UI'
        }
      }
    },
    commitTemplate: {
      type: 'object',
      properties: {
        defaultType: {
          type: 'string',
          enum: ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore', 'perf', 'build', 'ci', 'revert'],
          description: 'Default commit type'
        },
        enableScope: {
          type: 'boolean',
          description: 'Enable commit scope'
        },
        requireBody: {
          type: 'boolean',
          description: 'Require commit body'
        },
        charactersPerLine: {
          type: 'number',
          minimum: 50,
          maximum: 120,
          description: 'Maximum characters per line'
        }
      }
    },
    validation: {
      type: 'object',
      properties: {
        enforceConventionalCommits: {
          type: 'boolean',
          description: 'Enforce conventional commits format'
        },
        maxHeaderLength: {
          type: 'number',
          minimum: 20,
          maximum: 100,
          description: 'Maximum length of commit header'
        },
        warnOnLongBody: {
          type: 'boolean',
          description: 'Warn when body is too long'
        }
      }
    },
    behavior: {
      type: 'object',
      properties: {
        confirmBeforeCommit: {
          type: 'boolean',
          description: 'Confirm before creating commit'
        },
        showHelpText: {
          type: 'boolean',
          description: 'Show help text in the UI'
        },
        rememberLastTemplate: {
          type: 'boolean',
          description: 'Remember last used template'
        }
      }
    }
  };
  
  constructor(private configManager: ConfigurationManager) {}
  
  /**
   * Get user preferences
   * @returns User preferences
   */
  async getPreferences(): Promise<UserPreferences> {
    const config = await this.configManager.getConfiguration();
    
    // Use defaults if no preferences are set
    if (!config.preferences) {
      return this.getDefaultPreferences();
    }
    
    // Merge with defaults to ensure all properties exist
    return this.mergeWithDefaults(config.preferences);
  }
  
  /**
   * Get project-specific preferences
   * @returns Project preferences merged with global defaults
   */
  async getProjectPreferences(): Promise<UserPreferences> {
    const globalPrefs = await this.getPreferences();
    const projectConfig = await this.configManager.getProjectConfiguration();
    
    // If no project preferences, return global preferences
    if (!projectConfig || !projectConfig.preferences) {
      return globalPrefs;
    }
    
    // Deep merge project preferences with global preferences
    return this.deepMerge(globalPrefs, projectConfig.preferences);
  }
  
  /**
   * Get default preferences
   */
  getDefaultPreferences(): UserPreferences {
    return JSON.parse(JSON.stringify(this.defaultPreferences));
  }
  
  /**
   * Get preference schemas for validation and UI generation
   */
  getPreferenceSchemas() {
    return this.schemas;
  }
  
  /**
   * Update user preferences
   * @param updates Partial preferences to update
   * @param projectMode Whether to update project-specific preferences
   * @returns Success status
   */
  async updatePreferences(
    updates: Partial<UserPreferences>,
    projectMode: boolean = false
  ): Promise<boolean> {
    // Validate updates
    if (!(await this.validatePreferences(updates))) {
      throw new Error('Invalid preference values');
    }
    
    if (projectMode) {
      // Update project-specific preferences
      const projectConfig = await this.configManager.getProjectConfiguration() || {};
      const currentPrefs = projectConfig.preferences || {};
      
      // Merge updates with current project preferences
      const newPrefs = this.deepMerge(currentPrefs, updates);
      
      // Save to project config
      return this.configManager.saveProjectConfiguration({
        ...projectConfig,
        preferences: newPrefs
      });
    } else {
      // Update global preferences
      const config = await this.configManager.getConfiguration();
      const currentPrefs = await this.getPreferences();
      
      // Merge updates with current preferences
      const newPrefs = this.deepMerge(currentPrefs, updates);
      
      // Save to global config
      return this.configManager.saveConfiguration({
        ...config,
        preferences: newPrefs
      });
    }
  }
  
  /**
   * Reset preferences to defaults
   * @param projectMode Whether to reset project-specific preferences
   * @returns Success status
   */
  async resetToDefaults(projectMode: boolean = false): Promise<boolean> {
    if (projectMode) {
      // For project mode, simply remove preferences from project config
      const projectConfig = await this.configManager.getProjectConfiguration() || {};
      
      if (projectConfig.preferences) {
        delete projectConfig.preferences;
        return this.configManager.saveProjectConfiguration(projectConfig);
      }
      
      return true;
    } else {
      // For global preferences, reset to defaults
      const config = await this.configManager.getConfiguration();
      
      return this.configManager.saveConfiguration({
        ...config,
        preferences: this.getDefaultPreferences()
      });
    }
  }
  
  /**
   * Export preferences to a file
   * @param exportPath File path to export to
   */
  async exportPreferences(exportPath: string): Promise<void> {
    const preferences = await this.getPreferences();
    
    // Create directory if it doesn't exist
    await fs.mkdir(path.dirname(exportPath), { recursive: true });
    
    // Write preferences to file
    await fs.writeFile(
      exportPath,
      JSON.stringify(preferences, null, 2),
      'utf-8'
    );
  }
  
  /**
   * Import preferences from a file
   * @param importPath File path to import from
   * @param projectMode Whether to import to project-specific preferences
   */
  async importPreferences(
    importPath: string,
    projectMode: boolean = false
  ): Promise<void> {
    // Read preferences from file
    const content = await fs.readFile(importPath, 'utf-8');
    const importedPrefs = JSON.parse(content);
    
    // Validate imported preferences
    if (!(await this.validatePreferences(importedPrefs))) {
      throw new Error('Invalid preferences file');
    }
    
    // Update preferences
    await this.updatePreferences(importedPrefs, projectMode);
  }
  
  /**
   * Validate preferences
   * @param preferences Preferences to validate
   * @returns Validation result
   */
  async validatePreferences(preferences: any): Promise<boolean> {
    // Check if preferences is an object
    if (!preferences || typeof preferences !== 'object') {
      return false;
    }
    
    // Validate each section
    for (const [section, sectionData] of Object.entries(preferences)) {
      // Check if section exists in schema
      const schema = this.schemas[section as keyof typeof this.schemas];
      if (!schema) {
        // Unknown section - skip validation
        continue;
      }
      
      // Validate section properties
      for (const [key, value] of Object.entries(sectionData as Record<string, any>)) {
        const propSchema = schema.properties[key];
        
        // Skip if property doesn't exist in schema
        if (!propSchema) {
          continue;
        }
        
        // Validate based on type
        if (propSchema.type === 'string' && typeof value !== 'string') {
          return false;
        }
        
        if (propSchema.type === 'number' && typeof value !== 'number') {
          return false;
        }
        
        if (propSchema.type === 'boolean' && typeof value !== 'boolean') {
          return false;
        }
        
        // Validate enum values
        if (propSchema.type === 'string' && propSchema.enum && !propSchema.enum.includes(value)) {
          return false;
        }
        
        // Validate number ranges
        if (propSchema.type === 'number') {
          if (propSchema.minimum !== undefined && value < propSchema.minimum) {
            return false;
          }
          
          if (propSchema.maximum !== undefined && value > propSchema.maximum) {
            return false;
          }
        }
      }
    }
    
    return true;
  }
  
  /**
   * Get a specific section of preferences
   * @param section Section name
   * @returns Preference section
   */
  async getPreferenceSection<T extends keyof UserPreferences>(
    section: T
  ): Promise<UserPreferences[T]> {
    const preferences = await this.getPreferences();
    return preferences[section];
  }
  
  /**
   * Apply preferences to an object (for UI components)
   * @param obj Object to apply preferences to
   * @returns Object with preferences applied
   */
  async applyPreferencesToObject<T>(obj: T): Promise<T> {
    const preferences = await this.getPreferences();
    
    // Create a new object with preferences applied
    const result = { ...obj } as any;
    
    // Apply UI preferences
    if (preferences.ui) {
      result.theme = preferences.ui.theme;
      result.colorScheme = preferences.ui.colorScheme;
      result.compact = preferences.ui.compactMode;
      result.showIcons = preferences.ui.showIcons;
    }
    
    return result as T;
  }
  
  /**
   * Deep merge objects
   * @param target Target object
   * @param source Source object
   * @returns Merged object
   */
  private deepMerge(target: any, source: any): any {
    const output = { ...target };
    
    if (isObject(target) && isObject(source)) {
      Object.keys(source).forEach(key => {
        if (isObject(source[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = this.deepMerge(target[key], source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    
    return output;
  }
  
  /**
   * Merge preferences with defaults
   * @param preferences Preferences to merge
   * @returns Merged preferences
   */
  private mergeWithDefaults(preferences: Partial<UserPreferences>): UserPreferences {
    return this.deepMerge(this.getDefaultPreferences(), preferences);
  }
}

/**
 * Check if value is an object
 * @param item Value to check
 */
function isObject(item: any): boolean {
  return item && typeof item === 'object' && !Array.isArray(item);
}
```

### 5. Implement Preferences Form Component
```typescript
// src/components/preferencesForm.tsx
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import TextInput from 'ink-text-input';
import SelectInput from 'ink-select-input';
import { UserPreferencesService } from '../services/userPreferencesService';
import { SettingsSection } from './settingsSection';

type FormMode = 'sections' | 'settings' | 'import' | 'export' | 'reset';

interface PreferencesFormProps {
  preferencesService: UserPreferencesService;
  projectMode?: boolean;
  onSave?: () => void;
  onClose?: () => void;
}

/**
 * Form for editing user preferences
 */
export const PreferencesForm: React.FC<PreferencesFormProps> = ({
  preferencesService,
  projectMode = false,
  onSave,
  onClose
}) => {
  const [preferences, setPreferences] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [mode, setMode] = useState<FormMode>('sections');
  const [focusedSection, setFocusedSection] = useState('ui');
  const [focusedSetting, setFocusedSetting] = useState('');
  const [filePath, setFilePath] = useState('');
  const [resetConfirm, setResetConfirm] = useState(false);
  const [message, setMessage] = useState('');
  
  // Get schemas for UI generation
  const schemas = preferencesService.getPreferenceSchemas();
  
  // Load preferences
  useEffect(() => {
    const loadPreferences = async () => {
      setLoading(true);
      try {
        const prefs = projectMode
          ? await preferencesService.getProjectPreferences()
          : await preferencesService.getPreferences();
        setPreferences(prefs);
      } catch (error) {
        setMessage(`Error loading preferences: ${error}`);
      } finally {
        setLoading(false);
      }
    };
    
    loadPreferences();
  }, [preferencesService, projectMode]);
  
  // Handle keyboard navigation
  useInput((input, key) => {
    if (key.escape) {
      // Go back or close
      if (mode === 'sections') {
        onClose?.();
      } else if (mode === 'settings') {
        setMode('sections');
        setFocusedSetting('');
      } else {
        setMode('sections');
        setFilePath('');
        setResetConfirm(false);
      }
    }
    
    // Handle section navigation in sections mode
    if (mode === 'sections') {
      if (key.tab) {
        // Cycle through sections
        if (focusedSection === 'ui') setFocusedSection('commitTemplate');
        else if (focusedSection === 'commitTemplate') setFocusedSection('validation');
        else if (focusedSection === 'validation') setFocusedSection('behavior');
        else if (focusedSection === 'behavior') setFocusedSection('actions');
        else setFocusedSection('ui');
      }
      
      if (key.return && focusedSection !== 'actions') {
        // Enter settings mode
        setMode('settings');
      }
    }
  });
  
  // Handle setting change
  const handleSettingChange = async (setting: string, value: any) => {
    if (!preferences) return;
    
    // Create updates object with nested path
    const [section, key] = setting.split('.');
    const updates = {
      [section]: {
        [key]: value
      }
    };
    
    try {
      // Update preferences
      await preferencesService.updatePreferences(updates, projectMode);
      
      // Update local state
      setPreferences({
        ...preferences,
        [section]: {
          ...preferences[section],
          [key]: value
        }
      });
      
      setMessage(`Updated ${key}`);
      
      // Notify parent
      onSave?.();
    } catch (error) {
      setMessage(`Error updating preference: ${error}`);
    }
  };
  
  // Handle action button click
  const handleAction = (action: string) => {
    if (action === 'reset') {
      setMode('reset');
    } else if (action === 'import') {
      setMode('import');
    } else if (action === 'export') {
      setMode('export');
    }
  };
  
  // Handle import submit
  const handleImport = async () => {
    setSaving(true);
    setMessage('');
    
    try {
      await preferencesService.importPreferences(filePath, projectMode);
      setMessage(`Imported preferences from ${filePath}`);
      
      // Reload preferences
      const prefs = projectMode
        ? await preferencesService.getProjectPreferences()
        : await preferencesService.getPreferences();
      setPreferences(prefs);
      
      // Reset form state
      setMode('sections');
      setFilePath('');
      
      // Notify parent
      onSave?.();
    } catch (error) {
      setMessage(`Error importing preferences: ${error}`);
    } finally {
      setSaving(false);
    }
  };
  
  // Handle export submit
  const handleExport = async () => {
    setSaving(true);
    setMessage('');
    
    try {
      await preferencesService.exportPreferences(filePath);
      setMessage(`Exported preferences to ${filePath}`);
      
      // Reset form state
      setMode('sections');
      setFilePath('');
    } catch (error) {
      setMessage(`Error exporting preferences: ${error}`);
    } finally {
      setSaving(false);
    }
  };
  
  // Handle reset confirm
  const handleReset = async () => {
    setSaving(true);
    setMessage('');
    
    try {
      await preferencesService.resetToDefaults(projectMode);
      setMessage('Preferences reset to defaults');
      
      // Reload preferences
      const prefs = projectMode
        ? await preferencesService.getProjectPreferences()
        : await preferencesService.getPreferences();
      setPreferences(prefs);
      
      // Reset form state
      setMode('sections');
      setResetConfirm(false);
      
      // Notify parent
      onSave?.();
    } catch (error) {
      setMessage(`Error resetting preferences: ${error}`);
    } finally {
      setSaving(false);
    }
  };
  
  // If loading, show loading state
  if (loading) {
    return (
      <Box justifyContent="center" padding={1}>
        <Text>Loading preferences...</Text>
      </Box>
    );
  }
  
  // If preferences not loaded, show error
  if (!preferences) {
    return (
      <Box justifyContent="center" padding={1}>
        <Text>Error loading preferences</Text>
      </Box>
    );
  }
  
  // Handle import mode
  if (mode === 'import') {
    return (
      <Box flexDirection="column" padding={1} borderStyle="round">
        <Text bold>Import Preferences</Text>
        <Box marginY={1}>
          <Text>Enter import path: </Text>
          <TextInput
            value={filePath}
            onChange={setFilePath}
            onSubmit={handleImport}
          />
        </Box>
        {saving && <Text>Importing...</Text>}
        {message && <Text color="yellow">{message}</Text>}
        <Text dimColor>Press Escape to cancel</Text>
      </Box>
    );
  }
  
  // Handle export mode
  if (mode === 'export') {
    return (
      <Box flexDirection="column" padding={1} borderStyle="round">
        <Text bold>Export Preferences</Text>
        <Box marginY={1}>
          <Text>Enter export path: </Text>
          <TextInput
            value={filePath}
            onChange={setFilePath}
            onSubmit={handleExport}
          />
        </Box>
        {saving && <Text>Exporting...</Text>}
        {message && <Text color="yellow">{message}</Text>}
        <Text dimColor>Press Escape to cancel</Text>
      </Box>
    );
  }
  
  // Handle reset confirmation
  if (mode === 'reset') {
    return (
      <Box flexDirection="column" padding={1} borderStyle="round">
        <Text bold>Reset Preferences</Text>
        <Box marginY={1}>
          <Text>Are you sure you want to reset all preferences to defaults?</Text>
        </Box>
        <Box marginY={1}>
          <SelectInput
            items={[
              { key: 'yes', label: 'Yes, reset preferences', value: 'yes' },
              { key: 'no', label: 'No, cancel', value: 'no' }
            ]}
            onSelect={item => {
              if (item.value === 'yes') {
                handleReset();
              } else {
                setMode('sections');
                setResetConfirm(false);
              }
            }}
          />
        </Box>
        {saving && <Text>Resetting...</Text>}
        {message && <Text color="yellow">{message}</Text>}
      </Box>
    );
  }
  
  // Handle settings mode
  if (mode === 'settings') {
    // Get the focused section schema and preferences
    const sectionSchema = schemas[focusedSection as keyof typeof schemas];
    const sectionPrefs = preferences[focusedSection as keyof typeof preferences];
    
    return (
      <Box flexDirection="column" padding={1} borderStyle="round">
        <Text bold>{projectMode ? 'Project Preferences' : 'User Preferences'}</Text>
        <SettingsSection
          title={formatSectionTitle(focusedSection)}
          schema={sectionSchema}
          preferences={sectionPrefs}
          onChange={(key, value) => handleSettingChange(`${focusedSection}.${key}`, value)}
          focused={true}
          editMode={true}
          focusedSetting={focusedSetting}
          onFocus={setFocusedSetting}
          showDescriptions={true}
        />
        {message && <Text color="yellow">{message}</Text>}
        <Text dimColor>Press Escape to go back</Text>
      </Box>
    );
  }
  
  // Main preferences form (sections mode)
  return (
    <Box flexDirection="column" padding={1} borderStyle="round">
      <Text bold>
        {projectMode ? 'Project Preferences' : 'User Preferences'}
        {projectMode && <Text dimColor> (overrides global settings)</Text>}
      </Text>
      
      <Box flexDirection="column" marginY={1}>
        {/* UI Settings */}
        <SettingsSection
          title="UI Settings"
          schema={schemas.ui}
          preferences={preferences.ui}
          onChange={(key, value) => handleSettingChange(`ui.${key}`, value)}
          focused={focusedSection === 'ui'}
          onSelect={() => {
            setFocusedSection('ui');
            setMode('settings');
          }}
        />
        
        {/* Commit Template Settings */}
        <SettingsSection
          title="Commit Template"
          schema={schemas.commitTemplate}
          preferences={preferences.commitTemplate}
          onChange={(key, value) => handleSettingChange(`commitTemplate.${key}`, value)}
          focused={focusedSection === 'commitTemplate'}
          onSelect={() => {
            setFocusedSection('commitTemplate');
            setMode('settings');
          }}
        />
        
        {/* Validation Settings */}
        <SettingsSection
          title="Validation"
          schema={schemas.validation}
          preferences={preferences.validation}
          onChange={(key, value) => handleSettingChange(`validation.${key}`, value)}
          focused={focusedSection === 'validation'}
          onSelect={() => {
            setFocusedSection('validation');
            setMode('settings');
          }}
        />
        
        {/* Behavior Settings */}
        <SettingsSection
          title="Behavior"
          schema={schemas.behavior}
          preferences={preferences.behavior}
          onChange={(key, value) => handleSettingChange(`behavior.${key}`, value)}
          focused={focusedSection === 'behavior'}
          onSelect={() => {
            setFocusedSection('behavior');
            setMode('settings');
          }}
        />
      </Box>
      
      {/* Action Buttons */}
      <Box marginTop={1}>
        <Text
          bold={focusedSection === 'actions'}
          color={focusedSection === 'actions' ? 'cyan' : undefined}
        >
          Actions:{' '}
          <Text
            underline
            onClick={() => handleAction('reset')}
          >
            Reset
          </Text>
          {' | '}
          <Text
            underline
            onClick={() => handleAction('import')}
          >
            Import
          </Text>
          {' | '}
          <Text
            underline
            onClick={() => handleAction('export')}
          >
            Export
          </Text>
        </Text>
      </Box>
      
      {message && (
        <Box marginTop={1}>
          <Text color="yellow">{message}</Text>
        </Box>
      )}
      
      <Box marginTop={1}>
        <Text dimColor>Use Tab to navigate • Enter to select • Esc to exit</Text>
      </Box>
    </Box>
  );
};

/**
 * Format section title for display
 */
function formatSectionTitle(section: string): string {
  // Convert camelCase to Title Case
  return section
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase());
}
```

### 6. Implement Settings Section Component
```typescript
// src/components/settingsSection.tsx
import React, { useState } from 'react';
import { Box, Text, useInput } from 'ink';
import TextInput from 'ink-text-input';
import SelectInput from 'ink-select-input';

interface SettingsSectionProps {
  title: string;
  schema: any;
  preferences: any;
  onChange: (key: string, value: any) => void;
  focused?: boolean;
  editMode?: boolean;
  focusedSetting?: string;
  onFocus?: (setting: string) => void;
  onSelect?: () => void;
  showDescriptions?: boolean;
}

/**
 * Component for a section of settings
 */
export const SettingsSection: React.FC<SettingsSectionProps> = ({
  title,
  schema,
  preferences,
  onChange,
  focused = false,
  editMode = false,
  focusedSetting = '',
  onFocus,
  onSelect,
  showDescriptions = false
}) => {
  const [editValue, setEditValue] = useState('');
  
  // Handle input
  useInput((input, key) => {
    if (!focused) return;
    
    // In non-edit mode
    if (!editMode) {
      if (key.return && onSelect) {
        onSelect();
      }
    }
  });
  
  // If no schema or preferences, show nothing
  if (!schema || !preferences) {
    return null;
  }
  
  // Get settings from schema
  const settings = Object.entries(schema.properties).map(([key, prop]: [string, any]) => ({
    key,
    ...prop
  }));
  
  // If in edit mode, show setting editor
  if (editMode) {
    const focusedProp = settings.find(s => s.key === focusedSetting);
    
    if (focusedProp) {
      const currentValue = preferences[focusedProp.key];
      
      // Editor for string enum
      if (focusedProp.type === 'string' && focusedProp.enum) {
        return (
          <Box flexDirection="column" marginY={1}>
            <Text bold>{formatSettingName(focusedProp.key)}</Text>
            {focusedProp.description && (
              <Text dimColor>{focusedProp.description}</Text>
            )}
            <SelectInput
              items={focusedProp.enum.map((value: string) => ({
                key: value,
                label: value,
                value
              }))}
              initialIndex={focusedProp.enum.indexOf(currentValue)}
              onSelect={item => onChange(focusedProp.key, item.value)}
            />
          </Box>
        );
      }
      
      // Editor for boolean
      if (focusedProp.type === 'boolean') {
        return (
          <Box flexDirection="column" marginY={1}>
            <Text bold>{formatSettingName(focusedProp.key)}</Text>
            {focusedProp.description && (
              <Text dimColor>{focusedProp.description}</Text>
            )}
            <SelectInput
              items={[
                { key: 'true', label: 'true', value: true },
                { key: 'false', label: 'false', value: false }
              ]}
              initialIndex={currentValue ? 0 : 1}
              onSelect={item => onChange(focusedProp.key, item.value)}
            />
          </Box>
        );
      }
      
      // Editor for number
      if (focusedProp.type === 'number') {
        // Show range if available
        const range = 
          focusedProp.minimum !== undefined && focusedProp.maximum !== undefined
            ? ` (${focusedProp.minimum}-${focusedProp.maximum})`
            : '';
        
        return (
          <Box flexDirection="column" marginY={1}>
            <Text bold>{formatSettingName(focusedProp.key)}</Text>
            {focusedProp.description && (
              <Text dimColor>{focusedProp.description}</Text>
            )}
            <Box>
              <Text>Enter value{range}: </Text>
              <TextInput
                value={editValue || String(currentValue)}
                onChange={setEditValue}
                onSubmit={value => {
                  const numValue = Number(value);
                  if (!isNaN(numValue)) {
                    // Validate range
                    if (focusedProp.minimum !== undefined && numValue < focusedProp.minimum) {
                      return;
                    }
                    if (focusedProp.maximum !== undefined && numValue > focusedProp.maximum) {
                      return;
                    }
                    
                    onChange(focusedProp.key, numValue);
                  }
                }}
              />
            </Box>
          </Box>
        );
      }
    }
    
    return (
      <Box>
        <Text>No setting selected</Text>
      </Box>
    );
  }
  
  // Section display (non-edit mode)
  return (
    <Box
      flexDirection="column"
      marginY={1}
      paddingX={1}
      borderStyle={focused ? 'round' : undefined}
    >
      <Text bold={focused}>
        {focused ? '● ' : '○ '}
        {title}
      </Text>
      
      {settings.map(setting => (
        <Box key={setting.key} marginLeft={2} flexDirection="column">
          <Box>
            <Text>{formatSettingName(setting.key)}: </Text>
            <Text>{stringifyValue(preferences[setting.key])}</Text>
          </Box>
          
          {showDescriptions && setting.description && (
            <Text dimColor>{setting.description}</Text>
          )}
        </Box>
      ))}
    </Box>
  );
};

/**
 * Format setting name for display
 */
function formatSettingName(name: string): string {
  // Convert camelCase to Title Case
  return name
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase());
}

/**
 * Convert a value to string for display
 */
function stringifyValue(value: any): string {
  if (typeof value === 'boolean') {
    return value ? 'true' : 'false';
  }
  
  if (value === undefined || value === null) {
    return 'not set';
  }
  
  return String(value);
}
```

### 7. Implement Preferences Command
```typescript
// src/commands/preferences.ts
import React from 'react';
import { render } from 'ink';
import { PreferencesForm } from '../components/preferencesForm';
import { createUserPreferencesService } from '../factories/preferencesFactory';
import { CommandModule } from 'yargs';

/**
 * Command for managing user preferences
 */
export const createPreferencesCommand = (): CommandModule => {
  return {
    command: 'preferences',
    aliases: ['prefs', 'config'],
    describe: 'Manage user preferences',
    builder: {
      project: {
        alias: 'p',
        type: 'boolean',
        default: false,
        description: 'Edit project-specific preferences'
      },
      reset: {
        alias: 'r',
        type: 'boolean',
        default: false,
        description: 'Reset preferences to defaults'
      },
      import: {
        alias: 'i',
        type: 'string',
        description: 'Import preferences from file'
      },
      export: {
        alias: 'e',
        type: 'string',
        description: 'Export preferences to file'
      }
    },
    handler: async (argv) => {
      try {
        // Create preferences service
        const preferencesService = createUserPreferencesService();
        
        // Handle reset option
        if (argv.reset) {
          await preferencesService.resetToDefaults(Boolean(argv.project));
          console.log(`Preferences reset to defaults${argv.project ? ' for project' : ''}`);
          return;
        }
        
        // Handle import option
        if (argv.import) {
          await preferencesService.importPreferences(
            argv.import as string,
            Boolean(argv.project)
          );
          console.log(`Preferences imported from ${argv.import}`);
          return;
        }
        
        // Handle export option
        if (argv.export) {
          await preferencesService.exportPreferences(argv.export as string);
          console.log(`Preferences exported to ${argv.export}`);
          return;
        }
        
        // Render preferences form
        render(
          <PreferencesForm
            preferencesService={preferencesService}
            projectMode={Boolean(argv.project)}
            onClose={() => process.exit(0)}
          />
        );
      } catch (error) {
        console.error('Error managing preferences:', error);
        process.exit(1);
      }
    }
  };
};
```

### 8. Create Preferences Factory
```typescript
// src/factories/preferencesFactory.ts
import { UserPreferencesService } from '../services/userPreferencesService';
import { ConfigurationManager } from '../services/configurationManager';
import { createConfigurationManager } from './configurationFactory';

/**
 * Creates a user preferences service
 */
export function createUserPreferencesService(): UserPreferencesService {
  const configManager = createConfigurationManager();
  return new UserPreferencesService(configManager);
}

/**
 * Creates a preferences context for UI components
 */
export function createPreferencesContext(
  preferencesService: UserPreferencesService
): {
  getPreference: <T>(section: string, key: string, defaultValue: T) => Promise<T>;
  applyPreferences: <T>(component: T) => Promise<T>;
} {
  return {
    /**
     * Get a specific preference value
     */
    getPreference: async <T>(section: string, key: string, defaultValue: T): Promise<T> => {
      try {
        const preferences = await preferencesService.getPreferences();
        if (preferences[section] && preferences[section][key] !== undefined) {
          return preferences[section][key] as T;
        }
      } catch (error) {
        console.error(`Error getting preference ${section}.${key}:`, error);
      }
      
      return defaultValue;
    },
    
    /**
     * Apply preferences to a component
     */
    applyPreferences: async <T>(component: T): Promise<T> => {
      return preferencesService.applyPreferencesToObject(component);
    }
  };
}
```

### 9. Update Main Export Files
```typescript
// src/services/index.ts
export * from './userPreferencesService';
// ... other exports
```

```typescript
// src/components/index.ts
export * from './preferencesForm';
export * from './settingsSection';
// ... other exports
```

```typescript
// src/factories/index.ts
export * from './preferencesFactory';
// ... other exports
```

```typescript
// src/commands/index.ts
export * from './preferences';
// ... other exports
```

### 10. Update CLI to Include Preferences Command
```typescript
// src/cli.ts
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { createCommitCommand } from './commands/commit';
import { createAnalyticsCommand } from './commands/analytics';
import { createPreferencesCommand } from './commands/preferences';
import { initializeApp } from './app';

/**
 * Main CLI entry point
 */
async function main(): Promise<void> {
  // Initialize app
  await initializeApp();
  
  // Configure CLI
  const cli = yargs(hideBin(process.argv))
    .scriptName('zen-commit')
    .usage('$0 <command> [options]')
    .option('verbose', {
      alias: 'v',
      type: 'boolean',
      description: 'Run with verbose logging'
    });
  
  // Register commands
  cli.command(createCommitCommand());
  cli.command(createAnalyticsCommand());
  cli.command(createPreferencesCommand());
  
  // Add help and version
  cli.help().alias('help', 'h');
  cli.version().alias('version', 'V');
  
  // Parse arguments
  await cli.parse();
}

// Run CLI
main().catch(error => {
  console.error('Error:', error);
  process.exit(1);
});
```

### 11. Implement Preferences Theme Provider
```typescript
// src/components/themeProvider.tsx
import React, { createContext, useContext, useEffect, useState } from 'react';
import { UserPreferencesService } from '../services/userPreferencesService';

interface ThemeContextType {
  theme: string;
  colorScheme: string;
  compactMode: boolean;
  showIcons: boolean;
  loading: boolean;
}

// Create theme context with default values
const ThemeContext = createContext<ThemeContextType>({
  theme: 'default',
  colorScheme: 'dark',
  compactMode: false,
  showIcons: true,
  loading: true
});

interface ThemeProviderProps {
  preferencesService: UserPreferencesService;
  children: React.ReactNode;
}

/**
 * Provider component for theme preferences
 */
export const ThemeProvider: React.FC<ThemeProviderProps> = ({
  preferencesService,
  children
}) => {
  const [theme, setTheme] = useState<ThemeContextType>({
    theme: 'default',
    colorScheme: 'dark',
    compactMode: false,
    showIcons: true,
    loading: true
  });
  
  // Load theme preferences
  useEffect(() => {
    const loadTheme = async () => {
      try {
        const preferences = await preferencesService.getPreferences();
        setTheme({
          theme: preferences.ui.theme,
          colorScheme: preferences.ui.colorScheme,
          compactMode: preferences.ui.compactMode,
          showIcons: preferences.ui.showIcons ?? true,
          loading: false
        });
      } catch (error) {
        console.error('Error loading theme preferences:', error);
        setTheme(theme => ({ ...theme, loading: false }));
      }
    };
    
    loadTheme();
  }, [preferencesService]);
  
  return (
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  );
};

/**
 * Hook to use theme context
 */
export function useTheme(): ThemeContextType {
  return useContext(ThemeContext);
}

/**
 * Higher-order component to apply theme to a component
 */
export function withTheme<P extends object>(
  Component: React.ComponentType<P & ThemeContextType>
): React.FC<P> {
  return (props: P) => {
    const theme = useTheme();
    return <Component {...props} {...theme} />;
  };
}
```

### 12. Implement Preferences Hook
```typescript
// src/hooks/usePreferences.ts
import { useState, useEffect } from 'react';
import { UserPreferencesService } from '../services/userPreferencesService';

/**
 * Hook for using preferences in components
 */
export function usePreferences<T = any>(
  preferencesService: UserPreferencesService,
  section: string,
  projectMode: boolean = false
): [T | null, (updates: Partial<T>) => Promise<void>, boolean] {
  const [preferences, setPreferences] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  
  // Load preferences
  useEffect(() => {
    const loadPreferences = async () => {
      setLoading(true);
      try {
        const prefs = projectMode
          ? await preferencesService.getProjectPreferences()
          : await preferencesService.getPreferences();
        
        setPreferences(prefs[section] as T);
      } catch (error) {
        console.error(`Error loading preferences for ${section}:`, error);
      } finally {
        setLoading(false);
      }
    };
    
    loadPreferences();
  }, [preferencesService, section, projectMode]);
  
  // Update preferences
  const updatePreferences = async (updates: Partial<T>): Promise<void> => {
    if (!preferences) return;
    
    try {
      // Create updates object with section
      const sectionUpdates = {
        [section]: updates
      };
      
      // Update preferences
      await preferencesService.updatePreferences(sectionUpdates, projectMode);
      
      // Update local state
      setPreferences({
        ...preferences,
        ...updates
      });
    } catch (error) {
      console.error(`Error updating preferences for ${section}:`, error);
      throw error;
    }
  };
  
  return [preferences, updatePreferences, loading];
}
```

## Definition of Done
- Users can view and edit preferences via the CLI
- Preferences are organized into logical sections
- Changes are validated before being saved
- Both global and project-specific settings are supported
- Preferences can be imported and exported
- All test cases pass and achieve adequate coverage

## Potential Blockers
- Complex validation for interdependent settings
- User experience limitations in terminal UI
- Handling conflicts between global and project settings
- Backwards compatibility with existing configuration

## Next Steps
- Team Integration Features (5.1.3)
- Issue Tracker Integration (5.2.1)