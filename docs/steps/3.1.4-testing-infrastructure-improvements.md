# Phase 3.1.4: Testing Infrastructure Improvements

## Overview

This step focuses on modernizing the testing infrastructure for the template-related components implemented in previous steps. Current tests for TemplateSelector, TemplateForm, and TemplateBrowser components are encountering issues with TypeScript compatibility and proper mocking of the React testing environment. This step will address these issues and ensure that all template-related components have thorough test coverage.

## Dependencies

- React and Ink (for terminal UI)
- Steps 3.1.1 (Conventional Commits), 3.1.2 (Custom Template Definition), and 3.1.3 (Template Selection UI) must be completed
- @testing-library/react for proper React component testing

## Prerequisites

- Phase 1 and 2 must be complete
- Step 3.1.3 (Template Selection UI) should be completed

## Issues to Address

1. Component Type Safety
   - Fix TypeScript errors in test files for template components
   - Ensure proper typing of component props and parameters
   - Address issues with `act` from testing libraries
   - Fix problems with type casting (e.g., `as any`) in component tests

2. Test Mocking Strategy
   - Create centralized, consistent mocks for Ink components
   - Improve mocking of SelectInput and TextInput components with proper TypeScript interfaces
   - Address issues with useInput hook mocking and keyboard event simulation
   - Create reusable mock factory functions for common test patterns

3. Component Testing Architecture
   - Create a more maintainable testing architecture for Ink components
   - Implement better support for both class and function components
   - Add proper error boundaries for component testing
   - Fix React warnings related to act() in async tests

4. Test Coverage
   - Add missing tests for TemplateFormSelect component
   - Expand test coverage for keyboard interactions and navigation
   - Ensure proper testing of error handling and edge cases
   - Improve test documentation and organization

## Tasks

### 1. Centralize Component Test Infrastructure

- [ ] Create a comprehensive testing utilities file
  - Create `tests/helpers/test-utils.tsx` to centralize testing utilities
  - Add proper type definitions for all testing utilities
  - Include helper functions for common testing patterns
  - Add utilities for keyboard event simulation and input handling

- [ ] Create a robust mock registry for Ink components
  - Create `tests/helpers/ink-mock-registry.ts` to maintain consistent component mocks
  - Add type-safe mock registration mechanism
  - Include factory functions for creating properly typed mocks
  - Provide consistent interfaces for all mock components

- [ ] Implement act() wrapper utilities
  - Create helper functions to properly handle async component rendering
  - Add utilities for simulating component updates within act()
  - Add proper timeout handling for effects and state updates
  - Include proper error boundary implementations

### 2. Improve Ink Component Mocks

- [ ] Create proper SelectInput mock
  - Implement a fully typed SelectInput mock
  - Support both class and function component implementations
  - Add proper event simulation for keyboard navigation
  - Properly handle props like initialIndex, items, and onSelect

- [ ] Create proper TextInput mock
  - Implement a fully typed TextInput mock
  - Add support for input value changes
  - Handle onSubmit and onChange events properly
  - Simulate keyboard interactions correctly

- [ ] Improve useInput hook mock
  - Create a hook testing utility based on @testing-library/react-hooks
  - Implement proper subscription handling for input events
  - Add utilities for simulating various key combinations
  - Ensure correct cleanup of hook subscriptions

- [ ] Implement Box and Text component mocks
  - Create proper Box and Text component mocks with full prop support
  - Add support for nesting and layout properties
  - Ensure correct rendering of nested components
  - Include support for styling properties

### 3. Fix Template Component Tests

- [ ] Fix TemplateSelector.test.tsx
  - Fix type issues with class-based TemplateSelectItem component
  - Implement proper mock for SelectInput that works with class component
  - Add missing act() wrapper for component rendering
  - Add tests for keyboard navigation and selection

- [ ] Fix TemplateForm.test.tsx
  - Fix global __useInputCallback type issues
  - Properly mock the useInput hook and TextInput component
  - Add tests for form field validation
  - Add tests for form submission and keyboard navigation

- [ ] Fix TemplateBrowser.test.tsx
  - Create fully typed mock for templateManager
  - Fix missing act() wrappers for async component updates
  - Add proper error handling tests
  - Add tests for component state transitions

- [ ] Create TemplateFormSelect.test.tsx
  - Add tests for TemplateFormSelect component
  - Test proper rendering of selected and unselected states
  - Test correct handling of item props
  - Ensure proper styling of selected items

### 4. Add Advanced Testing Scenarios

- [ ] Add keyboard navigation tests
  - Test Tab key handling between form fields
  - Test arrow key navigation in select inputs
  - Test Escape key for cancellation
  - Test Enter key for form submission

- [ ] Add tests for template validation
  - Test required field validation with various input combinations
  - Test format string validation with valid and invalid templates
  - Test error state handling for invalid templates
  - Test dynamic form generation based on template fields

- [ ] Add tests for error handling and edge cases
  - Test behavior with empty templates array
  - Test loading error scenarios
  - Test cancellation during form filling
  - Test handling of invalid or incomplete form data

- [ ] Add tests for component integration
  - Test TemplateBrowser, TemplateSelector and TemplateForm working together
  - Test data flow between components
  - Test proper state management during component transitions
  - Test user journey through the complete template selection process

## Implementation Details

### 1. Creating the Test Utilities Infrastructure

Create a comprehensive `tests/helpers/test-utils.tsx` file that provides:

```typescript
import React from 'react';
import { render as inkRender } from 'ink-testing-library';
import { render, RenderResult, act as testingLibraryAct } from '@testing-library/react';

// Wrapper for ink render that handles act() properly
export async function renderWithAct(ui: React.ReactElement): Promise<RenderResult & { lastFrame: () => string }> {
  let result: any;
  await testingLibraryAct(async () => {
    result = inkRender(ui);
    // Wait for any effects to resolve
    await new Promise((resolve) => setTimeout(resolve, 0));
  });
  return result;
}

// Simulate keyboard input with proper typing
export function simulateKey(callback: any, input: string, key: { 
  return?: boolean;
  escape?: boolean;
  tab?: boolean;
  upArrow?: boolean;
  downArrow?: boolean;
  leftArrow?: boolean;
  rightArrow?: boolean;
  ctrl?: boolean;
  shift?: boolean;
  meta?: boolean;
} = {}) {
  if (callback) {
    callback(input, key);
  }
}

// Mock component factory with proper typing
export function createMockComponent<P>(displayName: string, implementation?: (props: P) => React.ReactElement | null) {
  const defaultImpl = (props: P & { children?: React.ReactNode }) => <>{props.children}</>;
  const MockComponent = implementation || defaultImpl;
  Object.defineProperty(MockComponent, 'displayName', { value: displayName });
  return MockComponent;
}

// Create a proper mock registry
export const mocks = {
  registered: new Map<string, any>(),
  register<T>(name: string, implementation: T): T {
    this.registered.set(name, implementation);
    return implementation;
  },
  get<T>(name: string): T | undefined {
    return this.registered.get(name);
  }
};
```

### 2. Implementing Consistent Component Mocks

Create properly typed mocks for Ink components:

```typescript
import React from 'react';
import { mocks, createMockComponent } from './test-utils';

// SelectInput mock with proper typing
export interface SelectInputProps<T> {
  items: Array<{ label: string; value: T; [key: string]: any }>;
  onSelect: (item: { value: T; [key: string]: any }) => void;
  itemComponent?: React.ComponentType<{ isSelected: boolean; item: any }>;
  initialIndex?: number;
}

export const MockSelectInput = createMockComponent<SelectInputProps<any>>('SelectInput', (props) => {
  const { items, onSelect, itemComponent: ItemComponent, initialIndex = 0 } = props;
  
  return (
    <div data-testid="select-input">
      {items.map((item, i) => (
        <div key={i} onClick={() => onSelect(item)} data-testid={`select-item-${i}`}>
          {ItemComponent ? (
            <ItemComponent isSelected={i === initialIndex} item={item} />
          ) : (
            <div>{item.label}</div>
          )}
        </div>
      ))}
      <div data-testid="navigation-help">Use arrow keys to navigate, Enter to select</div>
    </div>
  );
});

// TextInput mock with proper typing
export interface TextInputProps {
  value: string;
  onChange: (value: string) => void;
  onSubmit?: () => void;
  placeholder?: string;
  focus?: boolean;
}

export const MockTextInput = createMockComponent<TextInputProps>('TextInput', (props) => {
  const { value, onChange, onSubmit, placeholder } = props;
  
  return (
    <div data-testid="text-input">
      <input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onKeyDown={(e) => e.key === 'Enter' && onSubmit?.()}
        placeholder={placeholder}
        data-testid="text-input-field"
      />
      {placeholder && <div style={{ display: 'none' }}>{placeholder}</div>}
    </div>
  );
});

// Register the mocks
mocks.register('SelectInput', MockSelectInput);
mocks.register('TextInput', MockTextInput);
```

### 3. Creating a Mock for useInput Hook

Create a proper mock for the useInput hook:

```typescript
import { mocks } from './test-utils';

// Global callback storage with proper typing
type UseInputCallback = (
  input: string, 
  key: { 
    return?: boolean; 
    escape?: boolean; 
    tab?: boolean;
    upArrow?: boolean;
    downArrow?: boolean;
    leftArrow?: boolean;
    rightArrow?: boolean;
  }
) => void;

let lastUseInputCallback: UseInputCallback | null = null;

// Mock implementation of useInput
const mockUseInput = jest.fn((callback: UseInputCallback) => {
  lastUseInputCallback = callback;
  return {
    simulateInput: (input: string, key = {}) => {
      if (lastUseInputCallback) {
        lastUseInputCallback(input, key);
      }
    }
  };
});

// Helper to get and simulate the last registered input callback
export function getInputHandler() {
  return {
    simulateInput: (input: string, key = {}) => {
      if (lastUseInputCallback) {
        lastUseInputCallback(input, key);
      }
    },
    simulateKey: (key: { 
      return?: boolean; 
      escape?: boolean; 
      tab?: boolean;
      upArrow?: boolean;
      downArrow?: boolean;
    }) => {
      if (lastUseInputCallback) {
        lastUseInputCallback('', key);
      }
    }
  };
}

// Register the mock
mocks.register('useInput', mockUseInput);
```

### 4. Implementing the Template Component Tests

After setting up the test infrastructure, implement the component tests with proper typing:

For TemplateSelector.test.tsx:
```typescript
import React from 'react';
import { renderWithAct } from '../../helpers/test-utils';
import TemplateSelector from '@ui/components/TemplateSelector';
import { TemplateDefinition } from '@core/template-definition';

// Use properly typed mocks
jest.mock('ink-select-input', () => require('../../helpers/ink-mocks').MockSelectInput);

describe('TemplateSelector Component', () => {
  const templates: TemplateDefinition[] = [
    {
      name: 'Conventional',
      description: 'Conventional Commits format',
      fields: [],
      format: '{type}({scope}): {description}',
    },
    {
      name: 'Simple',
      description: 'Simple format with subject only',
      fields: [],
      format: '{subject}',
    },
  ];

  it('should render the template selector with templates', async () => {
    const { lastFrame } = await renderWithAct(
      <TemplateSelector
        templates={templates}
        selectedTemplate={templates[0]}
        onSelectTemplate={() => {}}
      />
    );

    expect(lastFrame()).toContain('Select a template');
    expect(lastFrame()).toContain('Conventional');
    expect(lastFrame()).toContain('Simple');
  });

  // Add more tests here...
});
```

## Definition of Done

- All tests for template components pass without TypeScript errors or warnings
- No `as any` type casts remain in the component implementations or tests
- Test coverage for template components is comprehensive (>80%)
- Template selection UI functions correctly with proper keyboard navigation
- Error handling is thoroughly tested for all edge cases
- No act() warnings are present in the test output
- Tests provide clear documentation of component behavior
- A centralized testing infrastructure is in place for future components

## Implementation Recommendations

1. Start by creating the centralized testing utilities and mock registry
2. Create proper mocks for SelectInput, TextInput, and useInput
3. Fix the existing test files one by one, addressing type issues
4. Add proper act() wrappers for all component rendering
5. Add testing for keyboard navigation and edge cases
6. Create a detailed testing guide in the project documentation
7. Add comments explaining complex mocking strategies for future developers

## Next Steps

After completing this step, we will have a robust testing infrastructure for template-related components. The next step will be to implement the Pattern Detection Engine (Phase 3.2.1), which will analyze commit messages for common patterns and provide warnings or suggestions.