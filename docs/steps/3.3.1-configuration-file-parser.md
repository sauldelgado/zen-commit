# Phase 3.3.1: Configuration File Parser

## Overview

This step implements a configuration file parser for Zen Commit that enables loading and parsing configuration files in various formats (YAML, JSON, etc.). This component will allow users to customize the behavior of Zen Commit through configuration files at both the global and project levels, providing a flexible and powerful way to adapt the tool to different workflows and requirements.

## Dependencies

- None beyond the core project dependencies

## Prerequisites

- Phase 1 and 2 must be completed
- This component is fairly independent but builds on the foundation set in previous phases

## Implementation Order

This step is part of the project-specific configuration phase. The implementation order should be:

1. Define the configuration file format
2. Implement the file parser
3. Create configuration discovery and loading
4. Implement the inheritance chain resolution

## Development Workflow Guidelines

Before implementing this step, please adhere to the following guidelines:

1. **Check for Claude.md Files**
   - Look for both global and project-specific Claude.md files
   - If conflicts exist, project-specific settings override global settings
   - In absence of conflicts, adhere to both sets of guidelines

2. **Test-Driven Development (TDD)**
   - Write tests first for the configuration file parser
   - Commit these tests
   - Verify the tests fail (as expected)
   - Implement the functionality to make tests pass
   - Commit the implementation once all tests pass
   - Create a GitHub PR using `gh` CLI

3. **Reference Git History and External Resources**
   - Use `gh` commands to understand similar implementations
   - Consider industry standards for configuration file formats and organization

## Tasks

### 1. Define Configuration File Interface

- [ ] Create test file `tests/unit/core/config-model.test.ts`
  ```typescript
  import { defaultConfig, validateConfig, mergeConfigs } from '@core/config-model';
  import { ZenCommitConfig } from '@core/config-model';
  
  describe('Configuration Model', () => {
    describe('defaultConfig', () => {
      it('should provide a complete default configuration', () => {
        expect(defaultConfig).toBeDefined();
        expect(defaultConfig.templates).toBeDefined();
        expect(defaultConfig.patterns).toBeDefined();
        expect(defaultConfig.commit).toBeDefined();
      });
    });
    
    describe('validateConfig', () => {
      it('should validate a valid configuration', () => {
        const config: ZenCommitConfig = {
          templates: {
            default: 'conventional',
            allowed: ['conventional', 'simple'],
          },
          patterns: {
            enabled: true,
            severity: 'warning',
          },
          commit: {
            signOff: false,
            gpgSign: false,
            maxSubjectLength: 72,
          },
        };
        
        const result = validateConfig(config);
        expect(result.valid).toBe(true);
        expect(result.errors.length).toBe(0);
      });
      
      it('should detect invalid configuration properties', () => {
        const config: any = {
          templates: {
            default: 'conventional',
            allowed: 'not-an-array', // Should be an array
          },
          patterns: {
            enabled: true,
            severity: 'invalid-severity', // Not a valid severity
          },
          commit: {
            maxSubjectLength: 'not-a-number', // Should be a number
          },
        };
        
        const result = validateConfig(config);
        expect(result.valid).toBe(false);
        expect(result.errors.length).toBeGreaterThan(0);
        
        // Check specific error messages
        expect(result.errors).toContain(
          expect.stringContaining('templates.allowed should be an array')
        );
        expect(result.errors).toContain(
          expect.stringContaining('patterns.severity')
        );
        expect(result.errors).toContain(
          expect.stringContaining('commit.maxSubjectLength')
        );
      });
    });
    
    describe('mergeConfigs', () => {
      it('should merge configurations with base as fallback', () => {
        const base: ZenCommitConfig = {
          templates: {
            default: 'conventional',
            allowed: ['conventional', 'simple'],
          },
          patterns: {
            enabled: true,
            severity: 'warning',
          },
          commit: {
            signOff: false,
            gpgSign: false,
            maxSubjectLength: 72,
          },
        };
        
        const override: Partial<ZenCommitConfig> = {
          templates: {
            default: 'simple',
          },
          commit: {
            signOff: true,
          },
        };
        
        const result = mergeConfigs(base, override);
        
        // Check overridden values
        expect(result.templates.default).toBe('simple');
        expect(result.commit.signOff).toBe(true);
        
        // Check values from base config
        expect(result.templates.allowed).toEqual(['conventional', 'simple']);
        expect(result.patterns.enabled).toBe(true);
        expect(result.commit.maxSubjectLength).toBe(72);
      });
      
      it('should handle deep merging of nested objects', () => {
        const base: ZenCommitConfig = {
          templates: {
            default: 'conventional',
            allowed: ['conventional', 'simple'],
            custom: {
              path: '/base/path',
            },
          },
          patterns: {
            enabled: true,
            severity: 'warning',
            overrides: {
              'pattern-1': true,
            },
          },
          commit: {
            signOff: false,
            gpgSign: false,
            maxSubjectLength: 72,
          },
        };
        
        const override: Partial<ZenCommitConfig> = {
          templates: {
            custom: {
              path: '/override/path',
            },
          },
          patterns: {
            overrides: {
              'pattern-2': true,
            },
          },
        };
        
        const result = mergeConfigs(base, override);
        
        // Check deep merged objects
        expect(result.templates.custom.path).toBe('/override/path');
        expect(result.patterns.overrides['pattern-1']).toBe(true);
        expect(result.patterns.overrides['pattern-2']).toBe(true);
      });
      
      it('should handle arrays by replacing rather than merging', () => {
        const base: ZenCommitConfig = {
          templates: {
            default: 'conventional',
            allowed: ['conventional', 'simple'],
          },
          patterns: {
            enabled: true,
            severity: 'warning',
          },
          commit: {
            signOff: false,
            gpgSign: false,
            maxSubjectLength: 72,
          },
        };
        
        const override: Partial<ZenCommitConfig> = {
          templates: {
            allowed: ['custom'],
          },
        };
        
        const result = mergeConfigs(base, override);
        
        // Arrays should be replaced, not merged
        expect(result.templates.allowed).toEqual(['custom']);
      });
    });
  });
  ```

- [ ] Create `src/core/config-model.ts` implementation file
  ```typescript
  /**
   * Interface for Zen Commit configuration
   */
  export interface ZenCommitConfig {
    templates: {
      default: string;
      allowed: string[];
      custom?: {
        path?: string;
      };
    };
    patterns: {
      enabled: boolean;
      severity: 'info' | 'warning' | 'error';
      overrides?: Record<string, boolean>;
    };
    commit: {
      signOff: boolean;
      gpgSign: boolean;
      maxSubjectLength: number;
      maxBodyLineLength?: number;
    };
    hooks?: {
      preCommit?: string;
      postCommit?: string;
    };
  }
  
  /**
   * Interface for configuration validation result
   */
  export interface ConfigValidationResult {
    valid: boolean;
    errors: string[];
    warnings: string[];
  }
  
  /**
   * Default configuration for Zen Commit
   */
  export const defaultConfig: ZenCommitConfig = {
    templates: {
      default: 'conventional',
      allowed: ['conventional', 'simple', 'ticket-based'],
      custom: {
        path: '~/.config/zencommit/templates',
      },
    },
    patterns: {
      enabled: true,
      severity: 'warning',
      overrides: {},
    },
    commit: {
      signOff: false,
      gpgSign: false,
      maxSubjectLength: 72,
      maxBodyLineLength: 100,
    },
    hooks: {
      preCommit: '',
      postCommit: '',
    },
  };
  
  /**
   * Validate a configuration object
   * @param config Configuration to validate
   * @returns Validation result
   */
  export const validateConfig = (config: any): ConfigValidationResult => {
    const errors: string[] = [];
    const warnings: string[] = [];
    
    // Helper function to check if a property exists and is of the expected type
    const validateProperty = (
      obj: any, 
      path: string, 
      expectedType: string,
      required = true
    ): boolean => {
      const parts = path.split('.');
      let current = obj;
      
      // Navigate to the property
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        
        if (current === undefined || current === null) {
          if (required) {
            errors.push(`${path} is required`);
          }
          return false;
        }
        
        current = current[part];
      }
      
      // Check if the property exists
      if (current === undefined || current === null) {
        if (required) {
          errors.push(`${path} is required`);
        }
        return false;
      }
      
      // Check type
      const actualType = Array.isArray(current) ? 'array' : typeof current;
      if (actualType !== expectedType) {
        errors.push(`${path} should be a ${expectedType}, got ${actualType}`);
        return false;
      }
      
      return true;
    };
    
    // Validate templates section
    validateProperty(config, 'templates', 'object');
    validateProperty(config, 'templates.default', 'string');
    validateProperty(config, 'templates.allowed', 'array');
    
    // Validate patterns section
    validateProperty(config, 'patterns', 'object');
    validateProperty(config, 'patterns.enabled', 'boolean');
    
    if (validateProperty(config, 'patterns.severity', 'string')) {
      const validSeverities = ['info', 'warning', 'error'];
      if (!validSeverities.includes(config.patterns.severity)) {
        errors.push(`patterns.severity should be one of: ${validSeverities.join(', ')}`);
      }
    }
    
    // Validate commit section
    validateProperty(config, 'commit', 'object');
    validateProperty(config, 'commit.signOff', 'boolean');
    validateProperty(config, 'commit.gpgSign', 'boolean');
    validateProperty(config, 'commit.maxSubjectLength', 'number');
    validateProperty(config, 'commit.maxBodyLineLength', 'number', false);
    
    // Validate hooks section
    if (config.hooks !== undefined) {
      validateProperty(config, 'hooks', 'object', false);
      validateProperty(config, 'hooks.preCommit', 'string', false);
      validateProperty(config, 'hooks.postCommit', 'string', false);
    }
    
    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  };
  
  /**
   * Deep merge two configuration objects
   * @param base Base configuration
   * @param override Configuration to override base values
   * @returns Merged configuration
   */
  export const mergeConfigs = <T>(base: T, override: Partial<T>): T => {
    if (!override) {
      return base;
    }
    
    const result = { ...base };
    
    for (const key in override) {
      if (!Object.prototype.hasOwnProperty.call(override, key)) {
        continue;
      }
      
      const baseValue = base[key];
      const overrideValue = override[key];
      
      // Handle different types of values
      if (
        typeof overrideValue === 'object' && 
        overrideValue !== null && 
        !Array.isArray(overrideValue) &&
        typeof baseValue === 'object' &&
        baseValue !== null &&
        !Array.isArray(baseValue)
      ) {
        // If both are objects, recursively merge them
        result[key] = mergeConfigs(baseValue, overrideValue);
      } else {
        // Otherwise, override the value
        result[key] = overrideValue as any;
      }
    }
    
    return result;
  };
  ```

### 2. Implement Configuration File Parser

- [ ] Create test file `tests/unit/core/config-parser.test.ts`
  ```typescript
  import { 
    parseConfigFile, 
    ConfigFileFormat,
    ConfigParseResult,
  } from '@core/config-parser';
  import * as fs from 'fs';
  
  // Mock fs module
  jest.mock('fs', () => ({
    promises: {
      readFile: jest.fn(),
    },
  }));
  
  describe('Configuration Parser', () => {
    afterEach(() => {
      jest.resetAllMocks();
    });
    
    describe('parseConfigFile', () => {
      it('should parse JSON configuration file', async () => {
        // Sample JSON config
        const jsonConfig = `{
          "templates": {
            "default": "conventional",
            "allowed": ["conventional", "simple"]
          },
          "patterns": {
            "enabled": true,
            "severity": "warning"
          },
          "commit": {
            "signOff": false,
            "gpgSign": true,
            "maxSubjectLength": 72
          }
        }`;
        
        // Mock readFile to return the JSON config
        (fs.promises.readFile as jest.Mock).mockResolvedValue(jsonConfig);
        
        const result = await parseConfigFile('/path/to/config.json', ConfigFileFormat.JSON);
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('conventional');
          expect(result.config.commit.gpgSign).toBe(true);
        }
      });
      
      it('should parse YAML configuration file', async () => {
        // Sample YAML config
        const yamlConfig = `
          templates:
            default: simple
            allowed:
              - conventional
              - simple
          patterns:
            enabled: true
            severity: warning
          commit:
            signOff: true
            gpgSign: false
            maxSubjectLength: 80
        `;
        
        // Mock readFile to return the YAML config
        (fs.promises.readFile as jest.Mock).mockResolvedValue(yamlConfig);
        
        const result = await parseConfigFile('/path/to/config.yml', ConfigFileFormat.YAML);
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('simple');
          expect(result.config.commit.signOff).toBe(true);
          expect(result.config.commit.maxSubjectLength).toBe(80);
        }
      });
      
      it('should handle invalid JSON configuration file', async () => {
        // Invalid JSON
        const invalidJson = `{
          "templates": {
            "default": "conventional",
            "allowed": ["conventional", "simple"
          },
        }`;
        
        // Mock readFile to return the invalid JSON
        (fs.promises.readFile as jest.Mock).mockResolvedValue(invalidJson);
        
        const result = await parseConfigFile('/path/to/config.json', ConfigFileFormat.JSON);
        
        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
      });
      
      it('should handle invalid YAML configuration file', async () => {
        // Invalid YAML
        const invalidYaml = `
          templates:
            default: simple
            allowed:
            - conventional
          - simple  # This line is incorrectly indented
        `;
        
        // Mock readFile to return the invalid YAML
        (fs.promises.readFile as jest.Mock).mockResolvedValue(invalidYaml);
        
        const result = await parseConfigFile('/path/to/config.yml', ConfigFileFormat.YAML);
        
        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
      });
      
      it('should automatically determine format from file extension', async () => {
        // Sample JSON config
        const jsonConfig = `{
          "templates": {
            "default": "conventional"
          }
        }`;
        
        // Mock readFile to return the JSON config
        (fs.promises.readFile as jest.Mock).mockResolvedValue(jsonConfig);
        
        // Pass undefined for format to auto-detect
        const result = await parseConfigFile('/path/to/config.json');
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('conventional');
        }
      });
      
      it('should handle file read errors', async () => {
        // Mock readFile to throw an error
        (fs.promises.readFile as jest.Mock).mockRejectedValue(
          new Error('File not found')
        );
        
        const result = await parseConfigFile('/path/to/nonexistent.json');
        
        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
        expect(result.error).toContain('File not found');
      });
    });
  });
  ```

- [ ] Create `src/core/config-parser.ts` implementation file
  ```typescript
  import * as fs from 'fs';
  import * as path from 'path';
  import * as yaml from 'js-yaml';
  import { ZenCommitConfig, validateConfig } from './config-model';
  
  /**
   * Enum for supported configuration file formats
   */
  export enum ConfigFileFormat {
    JSON = 'json',
    YAML = 'yaml',
  }
  
  /**
   * Interface for configuration parse result
   */
  export interface ConfigParseResult {
    success: boolean;
    config?: ZenCommitConfig;
    error?: string;
    warnings?: string[];
  }
  
  /**
   * Determine the configuration format from file extension
   * @param filePath Path to the configuration file
   * @returns Configuration file format
   */
  const determineFormatFromExtension = (filePath: string): ConfigFileFormat => {
    const ext = path.extname(filePath).toLowerCase();
    
    if (ext === '.json') {
      return ConfigFileFormat.JSON;
    } else if (ext === '.yml' || ext === '.yaml') {
      return ConfigFileFormat.YAML;
    }
    
    // Default to JSON
    return ConfigFileFormat.JSON;
  };
  
  /**
   * Parse a configuration file
   * @param filePath Path to the configuration file
   * @param format Format of the configuration file (auto-detected if not provided)
   * @returns Parse result with configuration or error
   */
  export const parseConfigFile = async (
    filePath: string,
    format?: ConfigFileFormat
  ): Promise<ConfigParseResult> => {
    try {
      // Read the file content
      const content = await fs.promises.readFile(filePath, 'utf8');
      
      // Determine format if not provided
      const fileFormat = format || determineFormatFromExtension(filePath);
      
      // Parse the content based on format
      let parsedConfig: any;
      
      if (fileFormat === ConfigFileFormat.JSON) {
        try {
          parsedConfig = JSON.parse(content);
        } catch (error) {
          return {
            success: false,
            error: `Failed to parse JSON: ${error.message}`,
          };
        }
      } else if (fileFormat === ConfigFileFormat.YAML) {
        try {
          parsedConfig = yaml.load(content);
        } catch (error) {
          return {
            success: false,
            error: `Failed to parse YAML: ${error.message}`,
          };
        }
      } else {
        return {
          success: false,
          error: `Unsupported configuration format: ${fileFormat}`,
        };
      }
      
      // Validate the configuration
      const validationResult = validateConfig(parsedConfig);
      
      if (!validationResult.valid) {
        return {
          success: false,
          error: `Invalid configuration: ${validationResult.errors.join(', ')}`,
          warnings: validationResult.warnings,
        };
      }
      
      return {
        success: true,
        config: parsedConfig as ZenCommitConfig,
        warnings: validationResult.warnings,
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to read configuration file: ${error.message}`,
      };
    }
  };
  ```

### 3. Implement Configuration Loader

- [ ] Create test file `tests/unit/core/config-loader.test.ts`
  ```typescript
  import {
    ConfigLoader,
    createConfigLoader,
  } from '@core/config-loader';
  import { ZenCommitConfig, defaultConfig } from '@core/config-model';
  import * as fs from 'fs';
  import * as path from 'path';
  import * as os from 'os';
  
  // Mock modules
  jest.mock('fs', () => ({
    promises: {
      access: jest.fn(),
      readFile: jest.fn(),
    },
    constants: {
      R_OK: 4,
    },
  }));
  
  jest.mock('path', () => ({
    ...jest.requireActual('path'),
    join: jest.fn(),
    resolve: jest.fn(),
    dirname: jest.fn(),
  }));
  
  jest.mock('os', () => ({
    homedir: jest.fn(),
  }));
  
  // Mock the config parser
  jest.mock('@core/config-parser', () => ({
    parseConfigFile: jest.fn(),
  }));
  
  import { parseConfigFile } from '@core/config-parser';
  
  describe('Configuration Loader', () => {
    let configLoader: ConfigLoader;
    
    beforeEach(() => {
      jest.resetAllMocks();
      
      // Mock homedir
      (os.homedir as jest.Mock).mockReturnValue('/home/user');
      
      // Mock path.join to return predictable paths
      (path.join as jest.Mock).mockImplementation((...paths) => paths.join('/'));
      
      // Mock path.resolve to just return the path
      (path.resolve as jest.Mock).mockImplementation(p => p);
      
      // Create config loader
      configLoader = createConfigLoader();
    });
    
    describe('loadGlobalConfig', () => {
      it('should load global configuration if it exists', async () => {
        // Mock fs.access to indicate file exists
        (fs.promises.access as jest.Mock).mockResolvedValue(undefined);
        
        // Mock parseConfigFile to return a successful result
        (parseConfigFile as jest.Mock).mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'global-template',
            },
          },
        });
        
        const result = await configLoader.loadGlobalConfig();
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('global-template');
        }
      });
      
      it('should handle non-existent global configuration', async () => {
        // Mock fs.access to indicate file does not exist
        (fs.promises.access as jest.Mock).mockRejectedValue(new Error('ENOENT'));
        
        const result = await configLoader.loadGlobalConfig();
        
        expect(result.success).toBe(true);
        expect(result.config).toEqual(defaultConfig);
      });
      
      it('should handle parse errors in global configuration', async () => {
        // Mock fs.access to indicate file exists
        (fs.promises.access as jest.Mock).mockResolvedValue(undefined);
        
        // Mock parseConfigFile to return an error
        (parseConfigFile as jest.Mock).mockResolvedValue({
          success: false,
          error: 'Parse error',
        });
        
        const result = await configLoader.loadGlobalConfig();
        
        expect(result.success).toBe(false);
        expect(result.error).toBe('Parse error');
      });
    });
    
    describe('loadProjectConfig', () => {
      it('should load project configuration if it exists', async () => {
        // Mock fs.access to indicate file exists
        (fs.promises.access as jest.Mock).mockResolvedValue(undefined);
        
        // Mock parseConfigFile to return a successful result
        (parseConfigFile as jest.Mock).mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'project-template',
            },
          },
        });
        
        const result = await configLoader.loadProjectConfig('/project/dir');
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('project-template');
        }
      });
      
      it('should handle non-existent project configuration', async () => {
        // Mock fs.access to indicate file does not exist
        (fs.promises.access as jest.Mock).mockRejectedValue(new Error('ENOENT'));
        
        const result = await configLoader.loadProjectConfig('/project/dir');
        
        expect(result.success).toBe(true);
        expect(result.config).toBeUndefined();
      });
    });
    
    describe('loadConfig', () => {
      it('should load and merge global and project configurations', async () => {
        // Mock global config loading
        jest.spyOn(configLoader, 'loadGlobalConfig').mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'global-template',
              allowed: ['global-template'],
            },
            patterns: {
              enabled: true,
              severity: 'warning',
            },
            commit: {
              signOff: false,
              gpgSign: false,
              maxSubjectLength: 72,
            },
          },
        });
        
        // Mock project config loading
        jest.spyOn(configLoader, 'loadProjectConfig').mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'project-template',
            },
            commit: {
              signOff: true,
            },
          },
        });
        
        const result = await configLoader.loadConfig('/project/dir');
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          // Check merged values
          expect(result.config.templates.default).toBe('project-template'); // From project
          expect(result.config.templates.allowed).toEqual(['global-template']); // From global
          expect(result.config.commit.signOff).toBe(true); // From project
          expect(result.config.patterns.enabled).toBe(true); // From global
        }
      });
      
      it('should fall back to global config if project config fails to load', async () => {
        // Mock global config loading
        jest.spyOn(configLoader, 'loadGlobalConfig').mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'global-template',
            },
          },
        });
        
        // Mock project config loading failure
        jest.spyOn(configLoader, 'loadProjectConfig').mockResolvedValue({
          success: false,
          error: 'Failed to load project config',
        });
        
        const result = await configLoader.loadConfig('/project/dir');
        
        expect(result.success).toBe(true);
        expect(result.config).toBeDefined();
        
        if (result.success) {
          expect(result.config.templates.default).toBe('global-template');
        }
        expect(result.warnings).toContain(expect.stringContaining('project config'));
      });
      
      it('should handle both global and project config failing', async () => {
        // Mock global config loading failure
        jest.spyOn(configLoader, 'loadGlobalConfig').mockResolvedValue({
          success: false,
          error: 'Failed to load global config',
        });
        
        // Mock project config loading failure
        jest.spyOn(configLoader, 'loadProjectConfig').mockResolvedValue({
          success: false,
          error: 'Failed to load project config',
        });
        
        const result = await configLoader.loadConfig('/project/dir');
        
        expect(result.success).toBe(false);
        expect(result.error).toContain('global config');
      });
    });
  });
  ```

- [ ] Create `src/core/config-loader.ts` implementation file
  ```typescript
  import * as fs from 'fs';
  import * as path from 'path';
  import * as os from 'os';
  import { 
    ZenCommitConfig, 
    defaultConfig, 
    mergeConfigs,
  } from './config-model';
  import { parseConfigFile, ConfigParseResult } from './config-parser';
  
  /**
   * Default configuration file names
   */
  const CONFIG_FILE_NAMES = [
    '.zencommitrc',
    '.zencommitrc.json',
    '.zencommitrc.yaml',
    '.zencommitrc.yml',
    'zencommit.config.js',
  ];
  
  /**
   * Interface for config loader result
   */
  export interface ConfigLoadResult {
    success: boolean;
    config?: ZenCommitConfig;
    error?: string;
    warnings?: string[];
  }
  
  /**
   * Interface for configuration loader
   */
  export interface ConfigLoader {
    loadGlobalConfig(): Promise<ConfigLoadResult>;
    loadProjectConfig(projectDir: string): Promise<ConfigLoadResult>;
    loadConfig(projectDir: string): Promise<ConfigLoadResult>;
  }
  
  /**
   * Factory function to create a configuration loader
   */
  export const createConfigLoader = (): ConfigLoader => {
    return {
      /**
       * Load global configuration
       */
      async loadGlobalConfig(): Promise<ConfigLoadResult> {
        // Check in user's home directory
        const homeDir = os.homedir();
        const globalConfigPath = path.join(homeDir, '.config', 'zencommit', '.zencommitrc');
        
        try {
          // Check if file exists
          await fs.promises.access(globalConfigPath, fs.constants.R_OK);
          
          // Parse the file
          const parseResult = await parseConfigFile(globalConfigPath);
          
          if (!parseResult.success) {
            return {
              success: false,
              error: `Failed to parse global config: ${parseResult.error}`,
            };
          }
          
          return {
            success: true,
            config: parseResult.config,
            warnings: parseResult.warnings,
          };
        } catch (error) {
          // If file doesn't exist, use default config
          if (error.code === 'ENOENT') {
            return {
              success: true,
              config: defaultConfig,
            };
          }
          
          return {
            success: false,
            error: `Failed to load global config: ${error.message}`,
          };
        }
      },
      
      /**
       * Load project-specific configuration
       */
      async loadProjectConfig(projectDir: string): Promise<ConfigLoadResult> {
        // Try each possible config file name
        for (const fileName of CONFIG_FILE_NAMES) {
          const configPath = path.join(projectDir, fileName);
          
          try {
            // Check if file exists
            await fs.promises.access(configPath, fs.constants.R_OK);
            
            // Parse the file
            const parseResult = await parseConfigFile(configPath);
            
            if (!parseResult.success) {
              return {
                success: false,
                error: `Failed to parse project config: ${parseResult.error}`,
              };
            }
            
            return {
              success: true,
              config: parseResult.config,
              warnings: parseResult.warnings,
            };
          } catch (error) {
            // If file doesn't exist, try the next one
            if (error.code === 'ENOENT') {
              continue;
            }
            
            return {
              success: false,
              error: `Failed to load project config: ${error.message}`,
            };
          }
        }
        
        // No config file found, but that's not an error
        return {
          success: true,
        };
      },
      
      /**
       * Load and merge global and project configurations
       */
      async loadConfig(projectDir: string): Promise<ConfigLoadResult> {
        const warnings: string[] = [];
        
        // Load global config
        const globalResult = await this.loadGlobalConfig();
        
        if (!globalResult.success) {
          return globalResult;
        }
        
        const globalConfig = globalResult.config;
        
        if (globalResult.warnings) {
          warnings.push(...globalResult.warnings);
        }
        
        // Load project config
        const projectResult = await this.loadProjectConfig(projectDir);
        
        if (!projectResult.success) {
          warnings.push(`Warning: ${projectResult.error}`);
          
          // Fall back to global config
          return {
            success: true,
            config: globalConfig,
            warnings,
          };
        }
        
        if (projectResult.warnings) {
          warnings.push(...projectResult.warnings);
        }
        
        // If project config exists, merge with global config
        if (projectResult.config) {
          return {
            success: true,
            config: mergeConfigs(globalConfig, projectResult.config),
            warnings: warnings.length > 0 ? warnings : undefined,
          };
        }
        
        // No project config, use global config
        return {
          success: true,
          config: globalConfig,
          warnings: warnings.length > 0 ? warnings : undefined,
        };
      },
    };
  };
  ```

### 4. Implement Configuration Service

- [ ] Create test file `tests/unit/core/config-service.test.ts`
  ```typescript
  import {
    ConfigService,
    createConfigService,
  } from '@core/config-service';
  import { ZenCommitConfig } from '@core/config-model';
  
  describe('Configuration Service', () => {
    let configService: ConfigService;
    
    // Mock config loader
    const mockConfigLoader = {
      loadGlobalConfig: jest.fn(),
      loadProjectConfig: jest.fn(),
      loadConfig: jest.fn(),
    };
    
    beforeEach(() => {
      jest.resetAllMocks();
      
      // Mock loadConfig to return a basic config
      mockConfigLoader.loadConfig.mockResolvedValue({
        success: true,
        config: {
          templates: {
            default: 'conventional',
            allowed: ['conventional'],
          },
          patterns: {
            enabled: true,
            severity: 'warning',
          },
          commit: {
            signOff: false,
            gpgSign: false,
            maxSubjectLength: 72,
          },
        },
      });
      
      configService = createConfigService(mockConfigLoader);
    });
    
    describe('initialize', () => {
      it('should load configuration', async () => {
        await configService.initialize('/project/dir');
        
        expect(mockConfigLoader.loadConfig).toHaveBeenCalledWith('/project/dir');
        expect(configService.isInitialized()).toBe(true);
      });
      
      it('should handle configuration load errors', async () => {
        mockConfigLoader.loadConfig.mockResolvedValue({
          success: false,
          error: 'Failed to load config',
        });
        
        await expect(configService.initialize('/project/dir')).rejects.toThrow('Failed to load config');
        
        expect(configService.isInitialized()).toBe(false);
      });
    });
    
    describe('getConfig', () => {
      it('should return loaded configuration', async () => {
        await configService.initialize('/project/dir');
        
        const config = configService.getConfig();
        
        expect(config).toBeDefined();
        expect(config.templates.default).toBe('conventional');
      });
      
      it('should throw error if not initialized', () => {
        expect(() => configService.getConfig()).toThrow('ConfigService not initialized');
      });
    });
    
    describe('getValue', () => {
      it('should return specific configuration value', async () => {
        await configService.initialize('/project/dir');
        
        const value = configService.getValue('templates.default');
        
        expect(value).toBe('conventional');
      });
      
      it('should handle nested paths', async () => {
        await configService.initialize('/project/dir');
        
        const value = configService.getValue('commit.maxSubjectLength');
        
        expect(value).toBe(72);
      });
      
      it('should return undefined for non-existent path', async () => {
        await configService.initialize('/project/dir');
        
        const value = configService.getValue('nonexistent.path');
        
        expect(value).toBeUndefined();
      });
    });
    
    describe('getWarnings', () => {
      it('should return configuration warnings', async () => {
        mockConfigLoader.loadConfig.mockResolvedValue({
          success: true,
          config: {
            templates: {
              default: 'conventional',
              allowed: ['conventional'],
            },
            patterns: {
              enabled: true,
              severity: 'warning',
            },
            commit: {
              signOff: false,
              gpgSign: false,
              maxSubjectLength: 72,
            },
          },
          warnings: ['Warning 1', 'Warning 2'],
        });
        
        await configService.initialize('/project/dir');
        
        const warnings = configService.getWarnings();
        
        expect(warnings).toEqual(['Warning 1', 'Warning 2']);
      });
    });
  });
  ```

- [ ] Create `src/core/config-service.ts` implementation file
  ```typescript
  import { ZenCommitConfig } from './config-model';
  import { ConfigLoader } from './config-loader';
  
  /**
   * Interface for configuration service
   */
  export interface ConfigService {
    initialize(projectDir: string): Promise<void>;
    isInitialized(): boolean;
    getConfig(): ZenCommitConfig;
    getValue<T>(path: string): T | undefined;
    getWarnings(): string[] | undefined;
  }
  
  /**
   * Factory function to create a configuration service
   */
  export const createConfigService = (configLoader: ConfigLoader): ConfigService => {
    let config: ZenCommitConfig | undefined;
    let warnings: string[] | undefined;
    let initialized = false;
    
    return {
      /**
       * Initialize the configuration service by loading configuration
       */
      async initialize(projectDir: string): Promise<void> {
        const result = await configLoader.loadConfig(projectDir);
        
        if (!result.success) {
          throw new Error(result.error);
        }
        
        config = result.config;
        warnings = result.warnings;
        initialized = true;
      },
      
      /**
       * Check if the service is initialized
       */
      isInitialized(): boolean {
        return initialized;
      },
      
      /**
       * Get the loaded configuration
       */
      getConfig(): ZenCommitConfig {
        if (!initialized || !config) {
          throw new Error('ConfigService not initialized');
        }
        
        return config;
      },
      
      /**
       * Get a specific configuration value by path
       */
      getValue<T>(path: string): T | undefined {
        if (!initialized || !config) {
          throw new Error('ConfigService not initialized');
        }
        
        const parts = path.split('.');
        let current: any = config;
        
        for (const part of parts) {
          if (current === undefined || current === null) {
            return undefined;
          }
          
          current = current[part];
        }
        
        return current as T;
      },
      
      /**
       * Get configuration warnings
       */
      getWarnings(): string[] | undefined {
        return warnings;
      },
    };
  };
  ```

### 5. Update Core Exports

- [ ] Update `src/core/index.ts` to export configuration functionality
  ```typescript
  export * from './conventional-commits';
  export * from './template-definition';
  export * from './template-manager';
  export * from './pattern-detection';
  export * from './pattern-matcher';
  export * from './pattern-optimizer';
  export * from './warning-manager';
  export * from './override-manager';
  export * from './override-storage';
  export * from './config-model';
  export * from './config-parser';
  export * from './config-loader';
  export * from './config-service';
  // Export other core functions as they are created
  ```

## Testing

- [ ] Run the tests
  ```bash
  npm test -- -t "Config"
  ```

## Definition of Done

- All tests for the configuration file parser pass
- The configuration model is well-defined with validation
- Configuration can be loaded from both global and project-specific files
- Configuration formats (YAML, JSON) are properly supported
- Configuration inheritance works correctly
- Configuration service provides easy access to configuration values
- Code is well-documented with JSDoc comments
- TypeScript types are correctly defined
- Linting passes with `npm run lint`

## Potential Blockers

- File system permissions for accessing configuration files
- Compatibility issues between different configuration formats
- Performance impact of loading and parsing configuration files

## Next Steps

After completing this step, proceed to step 3.3.2: Configuration Schema Definition, which will define a formal schema for configuration validation and provide better error reporting for configuration issues.