# 5.1.1 Analytics Dashboard Implementation

## Overview
This step implements an analytics dashboard that provides insights into commit patterns, development habits, and team collaboration. The dashboard will visualize commit history, developer activity, message quality, and other metrics to help users understand and improve their development workflow.

## Dependencies
- Local History Storage (4.1.1)
- Developer Mood Tracking (4.2.2)
- Metadata Tagging System (4.2.1)
- Base UI Component Library (1.2.3)

## Prerequisites
- Working Local History Storage (4.1.1)
- Completed Developer Mood Tracking (4.2.2)
- Completed Metadata Tagging System (4.2.1)
- Completed Base UI Component Library (1.2.3)

## Implementation Order
1. Create analytics data service
2. Implement visualization components
3. Develop dashboard layout
4. Add report generation capabilities
5. Implement filtering and data slicing

## Development Guidelines
- Focus on meaningful insights rather than overwhelming with data
- Use clear, intuitive visualizations
- Ensure efficient data processing for large repositories
- Allow customization of metrics and display preferences
- Provide context and explanations for the displayed metrics

## Tasks

### 1. Create Test File for Analytics Service
```typescript
// __tests__/services/analyticsService.test.ts
import { AnalyticsService } from '../../src/services/analyticsService';
import { CommitHistoryManager } from '../../src/services/historyManager';
import { GitOperationsService } from '../../src/services/gitOperations';

// Mock dependencies
jest.mock('../../src/services/historyManager');
jest.mock('../../src/services/gitOperations');

describe('AnalyticsService', () => {
  let analyticsService: AnalyticsService;
  let mockHistoryManager: jest.Mocked<CommitHistoryManager>;
  let mockGitOps: jest.Mocked<GitOperationsService>;
  
  const mockCommits = [
    {
      id: 'commit1',
      message: 'feat(auth): implement login',
      author: 'Alice',
      date: '2023-01-15T10:00:00Z',
      metadata: { mood: 'productive' }
    },
    {
      id: 'commit2',
      message: 'fix(auth): resolve token refresh issue',
      author: 'Bob',
      date: '2023-01-16T14:30:00Z',
      metadata: { mood: 'focused' }
    },
    {
      id: 'commit3',
      message: 'docs: update README',
      author: 'Alice',
      date: '2023-01-17T09:15:00Z',
      metadata: { mood: 'tired' }
    },
    {
      id: 'commit4',
      message: 'refactor: improve error handling',
      author: 'Charlie',
      date: '2023-01-18T16:45:00Z',
      metadata: { mood: 'frustrated' }
    },
    {
      id: 'commit5',
      message: 'feat(ui): add dark theme',
      author: 'Bob',
      date: '2023-01-19T11:20:00Z',
      metadata: { mood: 'inspired' }
    }
  ];
  
  beforeEach(() => {
    mockHistoryManager = new CommitHistoryManager() as jest.Mocked<CommitHistoryManager>;
    mockGitOps = new GitOperationsService('') as jest.Mocked<GitOperationsService>;
    
    mockHistoryManager.getEntries.mockResolvedValue(mockCommits);
    mockGitOps.getCommitCount.mockResolvedValue(100);
    
    analyticsService = new AnalyticsService(mockHistoryManager, mockGitOps);
  });
  
  test('should get commit count by author', async () => {
    const stats = await analyticsService.getCommitCountByAuthor();
    
    expect(stats).toEqual({
      'Alice': 2,
      'Bob': 2,
      'Charlie': 1
    });
  });
  
  test('should get commit count by type', async () => {
    const stats = await analyticsService.getCommitCountByType();
    
    expect(stats).toEqual({
      'feat': 2,
      'fix': 1,
      'docs': 1,
      'refactor': 1
    });
  });
  
  test('should get commit count by day of week', async () => {
    // Mock Date.parse to return controlled timestamps
    jest.spyOn(Date, 'parse').mockImplementation((dateString) => {
      if (dateString === '2023-01-15T10:00:00Z') return new Date(2023, 0, 15).getTime(); // Sunday
      if (dateString === '2023-01-16T14:30:00Z') return new Date(2023, 0, 16).getTime(); // Monday
      if (dateString === '2023-01-17T09:15:00Z') return new Date(2023, 0, 17).getTime(); // Tuesday
      if (dateString === '2023-01-18T16:45:00Z') return new Date(2023, 0, 18).getTime(); // Wednesday
      if (dateString === '2023-01-19T11:20:00Z') return new Date(2023, 0, 19).getTime(); // Thursday
      return 0;
    });
    
    const stats = await analyticsService.getCommitCountByDayOfWeek();
    
    expect(stats).toEqual({
      0: 1, // Sunday
      1: 1, // Monday
      2: 1, // Tuesday
      3: 1, // Wednesday
      4: 1, // Thursday
      5: 0, // Friday
      6: 0  // Saturday
    });
  });
  
  test('should get commit count by hour of day', async () => {
    const stats = await analyticsService.getCommitCountByHourOfDay();
    
    // We expect commits at 10:00, 14:30, 9:15, 16:45, and 11:20
    expect(stats[9]).toBe(1);  // 9 AM
    expect(stats[10]).toBe(1); // 10 AM
    expect(stats[11]).toBe(1); // 11 AM
    expect(stats[14]).toBe(1); // 2 PM
    expect(stats[16]).toBe(1); // 4 PM
  });
  
  test('should get mood distribution', async () => {
    const stats = await analyticsService.getMoodDistribution();
    
    expect(stats).toEqual({
      'productive': 1,
      'focused': 1,
      'tired': 1,
      'frustrated': 1,
      'inspired': 1
    });
  });
  
  test('should get commit message quality metrics', async () => {
    const metrics = await analyticsService.getCommitMessageQualityMetrics();
    
    expect(metrics.averageLength).toBeGreaterThan(0);
    expect(metrics.conventionalCommitPercentage).toBe(60); // 3 out of 5
    expect(metrics.withDescriptionPercentage).toBe(0); // None have descriptions in our mock
  });
  
  test('should get commit velocity over time', async () => {
    // Mock getCommitHistory to return commits with controlled timestamps
    mockGitOps.getCommitHistory.mockResolvedValue(
      Array.from({ length: 50 }, (_, i) => ({
        hash: `hash${i}`,
        date: new Date(2023, 0, 1 + Math.floor(i / 10)).toISOString(),
        message: 'test commit'
      }))
    );
    
    const velocity = await analyticsService.getCommitVelocityOverTime('day');
    
    // Should have 5 days with 10 commits each
    expect(Object.keys(velocity).length).toBe(5);
    Object.values(velocity).forEach(count => {
      expect(count).toBe(10);
    });
  });
  
  test('should get repository contribution summary', async () => {
    const summary = await analyticsService.getRepositoryContributionSummary();
    
    expect(summary.totalCommits).toBe(100); // From mock
    expect(summary.totalAuthors).toBe(3);
    expect(summary.activeContributors).toHaveLength(3);
    expect(summary.mostActiveAuthor).toBeDefined();
    expect(summary.mostCommonCommitType).toBe('feat');
  });
});
```

### 2. Create Test File for Chart Component
```typescript
// __tests__/components/analyticsChart.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { BarChart, PieChart, LineChart } from '../../src/components/analyticsChart';

describe('Analytics Chart Components', () => {
  test('should render bar chart', () => {
    const data = {
      'Alice': 10,
      'Bob': 5,
      'Charlie': 8
    };
    
    const { lastFrame } = render(
      <BarChart
        data={data}
        title="Commits by Author"
        width={30}
        height={10}
      />
    );
    
    expect(lastFrame()).toContain('Commits by Author');
    expect(lastFrame()).toContain('Alice');
    expect(lastFrame()).toContain('Bob');
    expect(lastFrame()).toContain('Charlie');
    expect(lastFrame()).toContain('10'); // Alice's count
  });
  
  test('should render pie chart', () => {
    const data = {
      'feat': 12,
      'fix': 8,
      'docs': 5,
      'refactor': 3
    };
    
    const { lastFrame } = render(
      <PieChart
        data={data}
        title="Commits by Type"
      />
    );
    
    expect(lastFrame()).toContain('Commits by Type');
    expect(lastFrame()).toContain('feat');
    expect(lastFrame()).toContain('fix');
    expect(lastFrame()).toContain('docs');
    expect(lastFrame()).toContain('refactor');
    expect(lastFrame()).toContain('43%'); // feat percentage (12/28)
  });
  
  test('should render line chart', () => {
    const data = {
      '2023-01-01': 5,
      '2023-01-02': 8,
      '2023-01-03': 3,
      '2023-01-04': 10,
      '2023-01-05': 7
    };
    
    const { lastFrame } = render(
      <LineChart
        data={data}
        title="Commits Over Time"
        width={40}
        height={10}
      />
    );
    
    expect(lastFrame()).toContain('Commits Over Time');
    expect(lastFrame()).toContain('2023-01-01');
    expect(lastFrame()).toContain('2023-01-05');
    expect(lastFrame()).toContain('10'); // Maximum value
  });
  
  test('should handle empty data in bar chart', () => {
    const { lastFrame } = render(
      <BarChart
        data={{}}
        title="Empty Chart"
        width={30}
        height={10}
      />
    );
    
    expect(lastFrame()).toContain('Empty Chart');
    expect(lastFrame()).toContain('No data available');
  });
  
  test('should render chart with custom colors', () => {
    const data = {
      'Alice': 10,
      'Bob': 5
    };
    
    const colors = {
      'Alice': 'blue',
      'Bob': 'green'
    };
    
    const { lastFrame } = render(
      <BarChart
        data={data}
        title="Custom Colors"
        width={30}
        height={10}
        colors={colors}
      />
    );
    
    expect(lastFrame()).toContain('Custom Colors');
    // Note: Cannot easily test colors in the output, but the component should not error
  });
  
  test('should handle overflow in line chart', () => {
    // Create data with many points that would exceed width
    const data: Record<string, number> = {};
    for (let i = 1; i <= 50; i++) {
      data[`2023-01-${i.toString().padStart(2, '0')}`] = i % 10;
    }
    
    const { lastFrame } = render(
      <LineChart
        data={data}
        title="Overflow Test"
        width={30} // Too narrow for all 50 points
        height={10}
      />
    );
    
    expect(lastFrame()).toContain('Overflow Test');
    // Component should not crash and should render something reasonable
  });
});
```

### 3. Create Test File for Dashboard Component
```typescript
// __tests__/components/analyticsDashboard.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { AnalyticsDashboard } from '../../src/components/analyticsDashboard';
import { AnalyticsService } from '../../src/services/analyticsService';

// Mock the analytics service
jest.mock('../../src/services/analyticsService');

describe('AnalyticsDashboard', () => {
  let mockAnalyticsService: jest.Mocked<AnalyticsService>;
  
  beforeEach(() => {
    mockAnalyticsService = new AnalyticsService() as jest.Mocked<AnalyticsService>;
    
    // Mock data for various metrics
    mockAnalyticsService.getCommitCountByAuthor.mockResolvedValue({
      'Alice': 10,
      'Bob': 8,
      'Charlie': 5
    });
    
    mockAnalyticsService.getCommitCountByType.mockResolvedValue({
      'feat': 12,
      'fix': 6,
      'docs': 3,
      'refactor': 2
    });
    
    mockAnalyticsService.getCommitCountByDayOfWeek.mockResolvedValue({
      0: 3, // Sunday
      1: 5, // Monday
      2: 7, // Tuesday
      3: 4, // Wednesday
      4: 2, // Thursday
      5: 1, // Friday
      6: 1  // Saturday
    });
    
    mockAnalyticsService.getMoodDistribution.mockResolvedValue({
      'productive': 8,
      'focused': 5,
      'tired': 4,
      'frustrated': 2,
      'inspired': 4
    });
    
    mockAnalyticsService.getCommitMessageQualityMetrics.mockResolvedValue({
      averageLength: 48.3,
      conventionalCommitPercentage: 75,
      withDescriptionPercentage: 30,
      withScopePercentage: 60
    });
    
    mockAnalyticsService.getRepositoryContributionSummary.mockResolvedValue({
      totalCommits: 23,
      totalAuthors: 3,
      activeContributors: [
        { name: 'Alice', commits: 10 },
        { name: 'Bob', commits: 8 },
        { name: 'Charlie', commits: 5 }
      ],
      mostActiveAuthor: 'Alice',
      mostCommonCommitType: 'feat'
    });
  });
  
  test('should render dashboard with tabs', () => {
    const { lastFrame } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
      />
    );
    
    // Should show loading initially
    expect(lastFrame()).toContain('Loading analytics data');
    
    // Should eventually render tabs
    setTimeout(() => {
      expect(lastFrame()).toContain('Overview');
      expect(lastFrame()).toContain('Contribution');
      expect(lastFrame()).toContain('Time');
      expect(lastFrame()).toContain('Quality');
      expect(lastFrame()).toContain('Mood');
    }, 0);
  });
  
  test('should navigate between tabs', () => {
    const { lastFrame, stdin } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Should start on Overview tab
      expect(lastFrame()).toContain('Repository Overview');
      
      // Navigate to Contribution tab
      stdin.write('\t');
      expect(lastFrame()).toContain('Contribution Analysis');
      
      // Navigate to Time tab
      stdin.write('\t');
      expect(lastFrame()).toContain('Time Analysis');
      
      // Navigate back to Overview tab
      stdin.write('\t');
      stdin.write('\t');
      stdin.write('\t');
      expect(lastFrame()).toContain('Repository Overview');
    }, 0);
  });
  
  test('should render repository overview', () => {
    const { lastFrame } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
        initialTab="overview"
      />
    );
    
    // Wait for data to load
    setTimeout(() => {
      expect(lastFrame()).toContain('Repository Overview');
      expect(lastFrame()).toContain('Total Commits: 23');
      expect(lastFrame()).toContain('Total Contributors: 3');
      expect(lastFrame()).toContain('Most Active: Alice');
      expect(lastFrame()).toContain('Most Common Type: feat');
    }, 0);
  });
  
  test('should render contribution analysis', () => {
    const { lastFrame } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
        initialTab="contribution"
      />
    );
    
    // Wait for data to load
    setTimeout(() => {
      expect(lastFrame()).toContain('Contribution Analysis');
      expect(lastFrame()).toContain('Alice');
      expect(lastFrame()).toContain('Bob');
      expect(lastFrame()).toContain('Charlie');
    }, 0);
  });
  
  test('should render time analysis', () => {
    const { lastFrame } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
        initialTab="time"
      />
    );
    
    // Wait for data to load
    setTimeout(() => {
      expect(lastFrame()).toContain('Time Analysis');
      expect(lastFrame()).toContain('Monday');
      expect(lastFrame()).toContain('Tuesday');
      expect(lastFrame()).toContain('Wednesday');
    }, 0);
  });
  
  test('should render mood analysis', () => {
    const { lastFrame } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
        initialTab="mood"
      />
    );
    
    // Wait for data to load
    setTimeout(() => {
      expect(lastFrame()).toContain('Mood Analysis');
      expect(lastFrame()).toContain('productive');
      expect(lastFrame()).toContain('focused');
      expect(lastFrame()).toContain('tired');
    }, 0);
  });
  
  test('should handle refresh', () => {
    const { lastFrame, stdin } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Press 'r' to refresh
      stdin.write('r');
      
      // Should show loading again
      expect(lastFrame()).toContain('Refreshing data');
      
      // Should fetch data again
      expect(mockAnalyticsService.getRepositoryContributionSummary).toHaveBeenCalledTimes(2);
    }, 0);
  });
  
  test('should handle date range selection', () => {
    const { lastFrame, stdin } = render(
      <AnalyticsDashboard
        analyticsService={mockAnalyticsService}
      />
    );
    
    // Wait for initial load
    setTimeout(() => {
      // Press 'd' to show date range selector
      stdin.write('d');
      
      expect(lastFrame()).toContain('Select Date Range');
      
      // Select "Last 7 Days"
      stdin.write('\n');
      
      // Should refresh with date filter
      expect(mockAnalyticsService.setDateRange).toHaveBeenCalled();
      expect(lastFrame()).toContain('Time Range: Last 7 Days');
    }, 0);
  });
});
```

### 4. Implement Analytics Service
```typescript
// src/services/analyticsService.ts
import { CommitHistoryManager } from './historyManager';
import { GitOperationsService } from './gitOperations';

interface CommitMessageQualityMetrics {
  averageLength: number;
  conventionalCommitPercentage: number;
  withDescriptionPercentage: number;
  withScopePercentage: number;
}

interface RepositoryContributionSummary {
  totalCommits: number;
  totalAuthors: number;
  activeContributors: { name: string; commits: number }[];
  mostActiveAuthor: string;
  mostCommonCommitType: string;
}

type TimeUnit = 'hour' | 'day' | 'week' | 'month';

/**
 * Service for analyzing commit history and generating metrics
 */
export class AnalyticsService {
  private startDate: Date | null = null;
  private endDate: Date | null = null;
  
  constructor(
    private historyManager: CommitHistoryManager,
    private gitOps: GitOperationsService
  ) {}
  
  /**
   * Set date range for analytics
   * @param startDate Start date
   * @param endDate End date
   */
  setDateRange(startDate: Date | null, endDate: Date | null): void {
    this.startDate = startDate;
    this.endDate = endDate;
  }
  
  /**
   * Clear date range filter
   */
  clearDateRange(): void {
    this.startDate = null;
    this.endDate = null;
  }
  
  /**
   * Get count of commits by author
   * @returns Object mapping author names to commit counts
   */
  async getCommitCountByAuthor(): Promise<Record<string, number>> {
    const commits = await this.getFilteredCommits();
    const counts: Record<string, number> = {};
    
    for (const commit of commits) {
      const author = commit.author;
      counts[author] = (counts[author] || 0) + 1;
    }
    
    return counts;
  }
  
  /**
   * Get count of commits by type
   * @returns Object mapping commit types to counts
   */
  async getCommitCountByType(): Promise<Record<string, number>> {
    const commits = await this.getFilteredCommits();
    const counts: Record<string, number> = {};
    
    for (const commit of commits) {
      const type = this.extractCommitType(commit.message);
      if (type) {
        counts[type] = (counts[type] || 0) + 1;
      }
    }
    
    return counts;
  }
  
  /**
   * Get count of commits by day of week
   * @returns Object mapping day numbers (0=Sunday, 6=Saturday) to counts
   */
  async getCommitCountByDayOfWeek(): Promise<Record<number, number>> {
    const commits = await this.getFilteredCommits();
    const counts: Record<number, number> = {
      0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0
    };
    
    for (const commit of commits) {
      const date = new Date(commit.date);
      const day = date.getDay();
      counts[day]++;
    }
    
    return counts;
  }
  
  /**
   * Get count of commits by hour of day
   * @returns Object mapping hours (0-23) to counts
   */
  async getCommitCountByHourOfDay(): Promise<Record<number, number>> {
    const commits = await this.getFilteredCommits();
    const counts: Record<number, number> = {};
    
    // Initialize all hours to 0
    for (let i = 0; i < 24; i++) {
      counts[i] = 0;
    }
    
    for (const commit of commits) {
      const date = new Date(commit.date);
      const hour = date.getHours();
      counts[hour]++;
    }
    
    return counts;
  }
  
  /**
   * Get distribution of developer moods
   * @returns Object mapping mood names to counts
   */
  async getMoodDistribution(): Promise<Record<string, number>> {
    const commits = await this.getFilteredCommits();
    const counts: Record<string, number> = {};
    
    for (const commit of commits) {
      if (commit.metadata?.mood) {
        const mood = commit.metadata.mood;
        counts[mood] = (counts[mood] || 0) + 1;
      }
    }
    
    return counts;
  }
  
  /**
   * Get commit message quality metrics
   * @returns Object with quality metrics
   */
  async getCommitMessageQualityMetrics(): Promise<CommitMessageQualityMetrics> {
    const commits = await this.getFilteredCommits();
    
    if (commits.length === 0) {
      return {
        averageLength: 0,
        conventionalCommitPercentage: 0,
        withDescriptionPercentage: 0,
        withScopePercentage: 0
      };
    }
    
    let totalLength = 0;
    let conventionalCount = 0;
    let withDescriptionCount = 0;
    let withScopeCount = 0;
    
    for (const commit of commits) {
      const message = commit.message;
      totalLength += message.length;
      
      // Check for conventional commit format
      if (this.isConventionalCommit(message)) {
        conventionalCount++;
      }
      
      // Check for description (optional body after header)
      if (message.includes('\n\n')) {
        withDescriptionCount++;
      }
      
      // Check for scope
      if (this.hasCommitScope(message)) {
        withScopeCount++;
      }
    }
    
    return {
      averageLength: totalLength / commits.length,
      conventionalCommitPercentage: (conventionalCount / commits.length) * 100,
      withDescriptionPercentage: (withDescriptionCount / commits.length) * 100,
      withScopePercentage: (withScopeCount / commits.length) * 100
    };
  }
  
  /**
   * Get commit velocity over time
   * @param unit Time unit for grouping (hour, day, week, month)
   * @returns Object mapping time periods to commit counts
   */
  async getCommitVelocityOverTime(unit: TimeUnit = 'day'): Promise<Record<string, number>> {
    const commits = await this.getFilteredCommits();
    const velocity: Record<string, number> = {};
    
    for (const commit of commits) {
      const date = new Date(commit.date);
      const period = this.formatDateByUnit(date, unit);
      
      velocity[period] = (velocity[period] || 0) + 1;
    }
    
    return velocity;
  }
  
  /**
   * Get summary of repository contributions
   * @returns Repository contribution summary
   */
  async getRepositoryContributionSummary(): Promise<RepositoryContributionSummary> {
    const commits = await this.getFilteredCommits();
    const totalCommits = await this.gitOps.getCommitCount();
    
    // Count by author
    const authorCounts: Record<string, number> = {};
    for (const commit of commits) {
      authorCounts[commit.author] = (authorCounts[commit.author] || 0) + 1;
    }
    
    // Get most active author
    let mostActiveAuthor = '';
    let maxCommits = 0;
    for (const [author, count] of Object.entries(authorCounts)) {
      if (count > maxCommits) {
        mostActiveAuthor = author;
        maxCommits = count;
      }
    }
    
    // Get most common commit type
    const typeCounts = await this.getCommitCountByType();
    let mostCommonType = '';
    let maxTypeCount = 0;
    for (const [type, count] of Object.entries(typeCounts)) {
      if (count > maxTypeCount) {
        mostCommonType = type;
        maxTypeCount = count;
      }
    }
    
    // Format active contributors
    const activeContributors = Object.entries(authorCounts)
      .map(([name, commits]) => ({ name, commits }))
      .sort((a, b) => b.commits - a.commits);
    
    return {
      totalCommits,
      totalAuthors: Object.keys(authorCounts).length,
      activeContributors,
      mostActiveAuthor,
      mostCommonCommitType: mostCommonType
    };
  }
  
  /**
   * Get commits for team collaboration analysis
   * @returns Object with collaboration metrics
   */
  async getTeamCollaborationMetrics(): Promise<any> {
    const commits = await this.getFilteredCommits();
    
    // Count file co-editing
    const fileEditors: Record<string, Set<string>> = {};
    for (const commit of commits) {
      if (commit.files) {
        for (const file of commit.files) {
          if (!fileEditors[file]) {
            fileEditors[file] = new Set();
          }
          fileEditors[file].add(commit.author);
        }
      }
    }
    
    // Calculate collaboration score (files edited by multiple people)
    let collaborationScore = 0;
    let totalFiles = 0;
    for (const editors of Object.values(fileEditors)) {
      totalFiles++;
      if (editors.size > 1) {
        collaborationScore++;
      }
    }
    
    // Calculate code review ratio
    const commitWithReviews = commits.filter(c => 
      c.metadata?.reviewedBy || (c.message && c.message.includes('Reviewed-by:'))
    ).length;
    
    return {
      collaborationScore: totalFiles > 0 ? (collaborationScore / totalFiles) * 100 : 0,
      codeReviewRatio: commits.length > 0 ? (commitWithReviews / commits.length) * 100 : 0,
      fileEditorCount: Object.entries(fileEditors)
        .map(([file, editors]) => ({ file, count: editors.size }))
        .filter(item => item.count > 1)
        .sort((a, b) => b.count - a.count)
        .slice(0, 10)
    };
  }
  
  /**
   * Get filtered commits based on date range
   */
  private async getFilteredCommits(): Promise<any[]> {
    const commits = await this.historyManager.getEntries();
    
    if (!this.startDate && !this.endDate) {
      return commits;
    }
    
    return commits.filter(commit => {
      const commitDate = new Date(commit.date);
      
      if (this.startDate && commitDate < this.startDate) {
        return false;
      }
      
      if (this.endDate && commitDate > this.endDate) {
        return false;
      }
      
      return true;
    });
  }
  
  /**
   * Extract commit type from message
   */
  private extractCommitType(message: string): string | null {
    const match = message.match(/^(feat|fix|docs|style|refactor|test|chore|perf|build|ci|revert)(\(.*?\))?:/);
    return match ? match[1] : null;
  }
  
  /**
   * Check if message is a conventional commit
   */
  private isConventionalCommit(message: string): boolean {
    return /^(feat|fix|docs|style|refactor|test|chore|perf|build|ci|revert)(\(.*?\))?:/.test(message);
  }
  
  /**
   * Check if message has a commit scope
   */
  private hasCommitScope(message: string): boolean {
    return /^(feat|fix|docs|style|refactor|test|chore|perf|build|ci|revert)\(.*?\):/.test(message);
  }
  
  /**
   * Format date by time unit
   */
  private formatDateByUnit(date: Date, unit: TimeUnit): string {
    if (unit === 'hour') {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:00`;
    }
    
    if (unit === 'day') {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    }
    
    if (unit === 'week') {
      // Get the first day of the week (Sunday)
      const firstDay = new Date(date);
      const day = date.getDay();
      firstDay.setDate(date.getDate() - day);
      
      return `Week of ${firstDay.getFullYear()}-${String(firstDay.getMonth() + 1).padStart(2, '0')}-${String(firstDay.getDate()).padStart(2, '0')}`;
    }
    
    if (unit === 'month') {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    }
    
    return date.toISOString();
  }
}
```

### 5. Implement Chart Components
```typescript
// src/components/analyticsChart.tsx
import React from 'react';
import { Box, Text } from 'ink';
import figures from 'figures';

interface ChartProps {
  data: Record<string, number>;
  title: string;
  width?: number;
  height?: number;
  colors?: Record<string, string>;
}

/**
 * Component for rendering a bar chart
 */
export const BarChart: React.FC<ChartProps> = ({
  data,
  title,
  width = 40,
  height = 10,
  colors
}) => {
  if (Object.keys(data).length === 0) {
    return (
      <Box flexDirection="column" width={width} height={height} borderStyle="round">
        <Text bold>{title}</Text>
        <Box justifyContent="center" alignItems="center" flex={1}>
          <Text>No data available</Text>
        </Box>
      </Box>
    );
  }
  
  // Find the maximum value for scaling
  const maxValue = Math.max(...Object.values(data));
  const barWidth = width - 15; // Reserve space for labels and borders
  
  // Sort data by value (descending)
  const sortedData = Object.entries(data)
    .sort(([, a], [, b]) => b - a)
    .slice(0, height - 2); // Limit to available vertical space
  
  return (
    <Box flexDirection="column" width={width} height={height} borderStyle="round">
      <Text bold>{title}</Text>
      
      {sortedData.map(([label, value]) => {
        const barLength = Math.max(1, Math.round((value / maxValue) * barWidth));
        const bar = '█'.repeat(barLength);
        const color = colors?.[label] || 'white';
        
        return (
          <Box key={label}>
            <Box width={10} paddingRight={1}>
              <Text>{label}</Text>
            </Box>
            <Box>
              <Text color={color}>{bar}</Text>
              <Text> {value}</Text>
            </Box>
          </Box>
        );
      })}
    </Box>
  );
};

/**
 * Component for rendering a pie chart
 */
export const PieChart: React.FC<ChartProps> = ({
  data,
  title,
  colors
}) => {
  if (Object.keys(data).length === 0) {
    return (
      <Box flexDirection="column" borderStyle="round">
        <Text bold>{title}</Text>
        <Box justifyContent="center" alignItems="center" padding={1}>
          <Text>No data available</Text>
        </Box>
      </Box>
    );
  }
  
  // Calculate total and percentages
  const total = Object.values(data).reduce((sum, value) => sum + value, 0);
  
  // Sort data by value (descending)
  const sortedData = Object.entries(data)
    .sort(([, a], [, b]) => b - a);
  
  // Unicode block characters for simple pie visualization
  const pieChars = [
    '🔶', '🔷', '🔴', '🔵', '🟢', '🟣', '🟡', '⚪'
  ];
  
  return (
    <Box flexDirection="column" borderStyle="round">
      <Text bold>{title}</Text>
      
      <Box flexDirection="column" padding={1}>
        {sortedData.map(([label, value], index) => {
          const percent = Math.round((value / total) * 100);
          const color = colors?.[label] || 'white';
          const pieChar = pieChars[index % pieChars.length];
          
          return (
            <Box key={label}>
              <Text>
                <Text color={color}>{pieChar}</Text> {label}: {value} ({percent}%)
              </Text>
            </Box>
          );
        })}
      </Box>
    </Box>
  );
};

/**
 * Component for rendering a line chart
 */
export const LineChart: React.FC<ChartProps> = ({
  data,
  title,
  width = 60,
  height = 10,
  colors
}) => {
  if (Object.keys(data).length === 0) {
    return (
      <Box flexDirection="column" width={width} height={height} borderStyle="round">
        <Text bold>{title}</Text>
        <Box justifyContent="center" alignItems="center" flex={1}>
          <Text>No data available</Text>
        </Box>
      </Box>
    );
  }
  
  // Find min and max values for scaling
  const values = Object.values(data);
  const maxValue = Math.max(...values);
  const minValue = Math.min(...values);
  
  // Sort data by keys (assuming they're dates)
  const sortedData = Object.entries(data)
    .sort(([a], [b]) => a.localeCompare(b));
  
  // Calculate chart dimensions
  const chartHeight = height - 3; // Reserve space for title, labels, etc.
  const chartWidth = width - 10; // Reserve space for y-axis labels
  
  // Scale data to fit chart height
  const range = maxValue - minValue;
  const scale = range === 0 ? 1 : chartHeight / range;
  
  // Generate chart grid
  const grid: string[][] = Array.from({ length: chartHeight }, () => 
    Array.from({ length: Math.min(chartWidth, sortedData.length) }, () => ' ')
  );
  
  // Plot the data points
  const step = sortedData.length > chartWidth ? sortedData.length / chartWidth : 1;
  for (let i = 0; i < Math.min(chartWidth, sortedData.length); i++) {
    const dataIndex = Math.floor(i * step);
    const value = sortedData[dataIndex][1];
    const y = chartHeight - 1 - Math.round((value - minValue) * scale);
    
    if (y >= 0 && y < chartHeight) {
      grid[y][i] = '•';
    }
  }
  
  return (
    <Box flexDirection="column" width={width} height={height} borderStyle="round">
      <Text bold>{title}</Text>
      
      {grid.map((row, i) => (
        <Box key={i}>
          <Box width={8} paddingRight={1}>
            <Text>{Math.round(maxValue - (i * range / chartHeight))}</Text>
          </Box>
          <Text>{row.join('')}</Text>
        </Box>
      ))}
      
      <Box marginLeft={8}>
        <Text>
          {sortedData.length <= chartWidth
            ? `${sortedData[0][0]} to ${sortedData[sortedData.length - 1][0]}`
            : `${sortedData[0][0]} ... ${sortedData[sortedData.length - 1][0]}`}
        </Text>
      </Box>
    </Box>
  );
};

/**
 * Component for rendering a heat map (for day/hour visualization)
 */
export const HeatMap: React.FC<{
  data: number[][];
  title: string;
  xLabels: string[];
  yLabels: string[];
  width?: number;
  height?: number;
}> = ({
  data,
  title,
  xLabels,
  yLabels,
  width = 60,
  height = 20
}) => {
  // Find the max value for color intensity
  let maxValue = 0;
  for (const row of data) {
    for (const value of row) {
      maxValue = Math.max(maxValue, value);
    }
  }
  
  // Heat map intensity characters
  const intensities = [' ', '░', '▒', '▓', '█'];
  
  return (
    <Box flexDirection="column" width={width} height={height} borderStyle="round">
      <Text bold>{title}</Text>
      
      <Box flexDirection="row" marginLeft={6}>
        {xLabels.map(label => (
          <Box key={label} width={2} justifyContent="center">
            <Text>{label[0]}</Text>
          </Box>
        ))}
      </Box>
      
      {data.map((row, y) => (
        <Box key={y} flexDirection="row">
          <Box width={6} paddingRight={1}>
            <Text>{yLabels[y]}</Text>
          </Box>
          
          {row.map((value, x) => {
            const intensity = maxValue === 0 
              ? 0 
              : Math.floor((value / maxValue) * (intensities.length - 1));
            
            return (
              <Box key={x} width={2} justifyContent="center">
                <Text>{intensities[intensity]}</Text>
              </Box>
            );
          })}
        </Box>
      ))}
    </Box>
  );
};
```

### 6. Implement Dashboard Component
```typescript
// src/components/analyticsDashboard.tsx
import React, { useState, useEffect } from 'react';
import { Box, Text, useInput } from 'ink';
import TextInput from 'ink-text-input';
import SelectInput from 'ink-select-input';
import { AnalyticsService } from '../services/analyticsService';
import { BarChart, PieChart, LineChart, HeatMap } from './analyticsChart';

type DashboardTab = 'overview' | 'contribution' | 'time' | 'quality' | 'mood';

interface AnalyticsDashboardProps {
  analyticsService: AnalyticsService;
  initialTab?: DashboardTab;
}

/**
 * Component for displaying analytics dashboard
 */
export const AnalyticsDashboard: React.FC<AnalyticsDashboardProps> = ({
  analyticsService,
  initialTab = 'overview'
}) => {
  const [tab, setTab] = useState<DashboardTab>(initialTab);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [dateRangeSelector, setDateRangeSelector] = useState(false);
  const [dateRange, setDateRange] = useState<string | null>(null);
  
  // Analytics data
  const [authorData, setAuthorData] = useState<Record<string, number>>({});
  const [typeData, setTypeData] = useState<Record<string, number>>({});
  const [dayData, setDayData] = useState<Record<number, number>>({});
  const [hourData, setHourData] = useState<Record<number, number>>({});
  const [moodData, setMoodData] = useState<Record<string, number>>({});
  const [qualityMetrics, setQualityMetrics] = useState<any>({});
  const [repositorySummary, setRepositorySummary] = useState<any>({});
  const [velocityData, setVelocityData] = useState<Record<string, number>>({});
  
  // Load initial data
  useEffect(() => {
    loadData();
  }, []);
  
  // Handle keyboard input
  useInput((input, key) => {
    if (key.tab) {
      // Cycle through tabs
      if (tab === 'overview') setTab('contribution');
      else if (tab === 'contribution') setTab('time');
      else if (tab === 'time') setTab('quality');
      else if (tab === 'quality') setTab('mood');
      else setTab('overview');
    }
    
    // Handle tab shortcuts
    if (input === '1') setTab('overview');
    if (input === '2') setTab('contribution');
    if (input === '3') setTab('time');
    if (input === '4') setTab('quality');
    if (input === '5') setTab('mood');
    
    // Handle refresh
    if (input === 'r') {
      refreshData();
    }
    
    // Handle date range selector
    if (input === 'd') {
      setDateRangeSelector(true);
    }
    
    // Handle export
    if (input === 'e') {
      exportReport();
    }
  });
  
  // Load analytics data
  const loadData = async () => {
    setLoading(true);
    
    try {
      // Load data in parallel
      const [
        authors,
        types,
        days,
        hours,
        moods,
        quality,
        summary,
        velocity
      ] = await Promise.all([
        analyticsService.getCommitCountByAuthor(),
        analyticsService.getCommitCountByType(),
        analyticsService.getCommitCountByDayOfWeek(),
        analyticsService.getCommitCountByHourOfDay(),
        analyticsService.getMoodDistribution(),
        analyticsService.getCommitMessageQualityMetrics(),
        analyticsService.getRepositoryContributionSummary(),
        analyticsService.getCommitVelocityOverTime('day')
      ]);
      
      // Update state
      setAuthorData(authors);
      setTypeData(types);
      setDayData(days);
      setHourData(hours);
      setMoodData(moods);
      setQualityMetrics(quality);
      setRepositorySummary(summary);
      setVelocityData(velocity);
    } catch (error) {
      console.error('Error loading analytics data:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };
  
  // Refresh data
  const refreshData = () => {
    setRefreshing(true);
    loadData();
  };
  
  // Export report
  const exportReport = () => {
    // This would generate and save a report file
    console.log('Exporting analytics report...');
  };
  
  // Handle date range selection
  const handleDateRangeSelect = (range: { value: string }) => {
    setDateRangeSelector(false);
    setDateRange(range.value);
    
    const now = new Date();
    let startDate: Date | null = null;
    let endDate: Date | null = null;
    
    if (range.value === 'last7days') {
      startDate = new Date(now);
      startDate.setDate(now.getDate() - 7);
      endDate = now;
    } else if (range.value === 'last30days') {
      startDate = new Date(now);
      startDate.setDate(now.getDate() - 30);
      endDate = now;
    } else if (range.value === 'thisMonth') {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = now;
    } else if (range.value === 'lastMonth') {
      startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0);
    } else if (range.value === 'allTime') {
      startDate = null;
      endDate = null;
    }
    
    analyticsService.setDateRange(startDate, endDate);
    refreshData();
  };
  
  // Date range options
  const dateRangeOptions = [
    { key: 'last7days', label: 'Last 7 Days', value: 'last7days' },
    { key: 'last30days', label: 'Last 30 Days', value: 'last30days' },
    { key: 'thisMonth', label: 'This Month', value: 'thisMonth' },
    { key: 'lastMonth', label: 'Last Month', value: 'lastMonth' },
    { key: 'allTime', label: 'All Time', value: 'allTime' }
  ];
  
  // Date range display text
  const getDateRangeText = () => {
    if (!dateRange) return 'All Time';
    if (dateRange === 'last7days') return 'Last 7 Days';
    if (dateRange === 'last30days') return 'Last 30 Days';
    if (dateRange === 'thisMonth') return 'This Month';
    if (dateRange === 'lastMonth') return 'Last Month';
    if (dateRange === 'allTime') return 'All Time';
    return dateRange;
  };
  
  // If in date range selector mode
  if (dateRangeSelector) {
    return (
      <Box flexDirection="column" padding={1} borderStyle="round">
        <Text bold>Select Date Range</Text>
        <SelectInput
          items={dateRangeOptions}
          onSelect={handleDateRangeSelect}
        />
      </Box>
    );
  }
  
  // If loading or refreshing
  if (loading) {
    return (
      <Box justifyContent="center" alignItems="center" height={20}>
        <Text>{refreshing ? 'Refreshing data...' : 'Loading analytics data...'}</Text>
      </Box>
    );
  }
  
  // Render dashboard
  return (
    <Box flexDirection="column" width={100}>
      {/* Header */}
      <Box borderStyle="round" marginBottom={1}>
        <Text bold>Commit Analytics Dashboard</Text>
        <Box marginLeft={2}>
          <Text>Time Range: {getDateRangeText()}</Text>
        </Box>
        <Box marginLeft="auto">
          <Text dimColor>(r: refresh, d: date range, e: export, 1-5: tabs)</Text>
        </Box>
      </Box>
      
      {/* Tab Navigation */}
      <Box marginBottom={1}>
        <Box marginRight={2}>
          <Text bold={tab === 'overview'}>1. Overview</Text>
        </Box>
        <Box marginRight={2}>
          <Text bold={tab === 'contribution'}>2. Contribution</Text>
        </Box>
        <Box marginRight={2}>
          <Text bold={tab === 'time'}>3. Time</Text>
        </Box>
        <Box marginRight={2}>
          <Text bold={tab === 'quality'}>4. Quality</Text>
        </Box>
        <Box marginRight={2}>
          <Text bold={tab === 'mood'}>5. Mood</Text>
        </Box>
      </Box>
      
      {/* Tab Content */}
      <Box>
        {tab === 'overview' && (
          <Box flexDirection="column">
            <Text bold>Repository Overview</Text>
            <Box flexDirection="row" marginY={1}>
              <Box borderStyle="round" padding={1} marginRight={2}>
                <Text>Total Commits: {repositorySummary.totalCommits}</Text>
                <Text>Total Contributors: {repositorySummary.totalAuthors}</Text>
                <Text>Most Active: {repositorySummary.mostActiveAuthor}</Text>
                <Text>Most Common Type: {repositorySummary.mostCommonCommitType}</Text>
              </Box>
              <PieChart
                data={typeData}
                title="Commit Types"
                colors={{
                  feat: 'green',
                  fix: 'red',
                  docs: 'blue',
                  style: 'magenta',
                  refactor: 'cyan',
                  test: 'yellow',
                  chore: 'gray'
                }}
              />
            </Box>
            <LineChart
              data={velocityData}
              title="Commit Velocity Over Time"
              width={80}
              height={12}
            />
          </Box>
        )}
        
        {tab === 'contribution' && (
          <Box flexDirection="column">
            <Text bold>Contribution Analysis</Text>
            <Box flexDirection="row" marginY={1}>
              <BarChart
                data={authorData}
                title="Commits by Author"
                width={50}
                height={15}
              />
              <Box flexDirection="column" marginLeft={2}>
                <Text bold>Active Contributors</Text>
                <Box flexDirection="column" padding={1}>
                  {repositorySummary.activeContributors?.map((contributor: any) => (
                    <Text key={contributor.name}>
                      {contributor.name}: {contributor.commits} commits
                    </Text>
                  ))}
                </Box>
              </Box>
            </Box>
          </Box>
        )}
        
        {tab === 'time' && (
          <Box flexDirection="column">
            <Text bold>Time Analysis</Text>
            <Box flexDirection="row" marginY={1}>
              <BarChart
                data={{
                  'Sunday': dayData[0],
                  'Monday': dayData[1],
                  'Tuesday': dayData[2],
                  'Wednesday': dayData[3],
                  'Thursday': dayData[4],
                  'Friday': dayData[5],
                  'Saturday': dayData[6]
                }}
                title="Commits by Day of Week"
                width={40}
                height={12}
              />
              <BarChart
                data={{
                  'Morning (6-12)': Object.entries(hourData)
                    .filter(([hour]) => Number(hour) >= 6 && Number(hour) < 12)
                    .reduce((sum, [, count]) => sum + count, 0),
                  'Afternoon (12-18)': Object.entries(hourData)
                    .filter(([hour]) => Number(hour) >= 12 && Number(hour) < 18)
                    .reduce((sum, [, count]) => sum + count, 0),
                  'Evening (18-24)': Object.entries(hourData)
                    .filter(([hour]) => Number(hour) >= 18 && Number(hour) < 24)
                    .reduce((sum, [, count]) => sum + count, 0),
                  'Night (0-6)': Object.entries(hourData)
                    .filter(([hour]) => Number(hour) >= 0 && Number(hour) < 6)
                    .reduce((sum, [, count]) => sum + count, 0)
                }}
                title="Commits by Time of Day"
                width={40}
                height={12}
                colors={{
                  'Morning (6-12)': 'yellow',
                  'Afternoon (12-18)': 'green',
                  'Evening (18-24)': 'blue',
                  'Night (0-6)': 'magenta'
                }}
              />
            </Box>
          </Box>
        )}
        
        {tab === 'quality' && (
          <Box flexDirection="column">
            <Text bold>Commit Quality Analysis</Text>
            <Box flexDirection="row" marginY={1}>
              <Box borderStyle="round" padding={1} marginRight={2} width={40}>
                <Text bold>Quality Metrics</Text>
                <Text>Average Message Length: {qualityMetrics.averageLength?.toFixed(1)} chars</Text>
                <Text>Conventional Commits: {qualityMetrics.conventionalCommitPercentage?.toFixed(1)}%</Text>
                <Text>With Description: {qualityMetrics.withDescriptionPercentage?.toFixed(1)}%</Text>
                <Text>With Scope: {qualityMetrics.withScopePercentage?.toFixed(1)}%</Text>
              </Box>
              <PieChart
                data={typeData}
                title="Commit Types"
                colors={{
                  feat: 'green',
                  fix: 'red',
                  docs: 'blue',
                  style: 'magenta',
                  refactor: 'cyan',
                  test: 'yellow',
                  chore: 'gray'
                }}
              />
            </Box>
          </Box>
        )}
        
        {tab === 'mood' && (
          <Box flexDirection="column">
            <Text bold>Mood Analysis</Text>
            <Box flexDirection="row" marginY={1}>
              <PieChart
                data={moodData}
                title="Developer Moods"
                colors={{
                  productive: 'green',
                  focused: 'blue',
                  tired: 'yellow',
                  frustrated: 'red',
                  inspired: 'magenta'
                }}
              />
              <BarChart
                data={moodData}
                title="Mood Distribution"
                width={40}
                height={12}
                colors={{
                  productive: 'green',
                  focused: 'blue',
                  tired: 'yellow',
                  frustrated: 'red',
                  inspired: 'magenta'
                }}
              />
            </Box>
          </Box>
        )}
      </Box>
      
      {/* Footer */}
      <Box borderStyle="round" marginTop={1}>
        <Text dimColor>Press Tab to switch between tabs</Text>
      </Box>
    </Box>
  );
};
```

### 7. Implement Report Generator
```typescript
// src/services/reportGenerator.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { AnalyticsService } from './analyticsService';

/**
 * Service for generating analytics reports
 */
export class ReportGenerator {
  constructor(private analyticsService: AnalyticsService) {}
  
  /**
   * Generate a text report
   * @param outputPath Path to save the report
   * @param title Report title
   */
  async generateTextReport(outputPath: string, title: string = 'Commit Analytics Report'): Promise<string> {
    try {
      // Get analytics data
      const [
        authors,
        types,
        days,
        hours,
        moods,
        quality,
        summary
      ] = await Promise.all([
        this.analyticsService.getCommitCountByAuthor(),
        this.analyticsService.getCommitCountByType(),
        this.analyticsService.getCommitCountByDayOfWeek(),
        this.analyticsService.getCommitCountByHourOfDay(),
        this.analyticsService.getMoodDistribution(),
        this.analyticsService.getCommitMessageQualityMetrics(),
        this.analyticsService.getRepositoryContributionSummary()
      ]);
      
      // Generate report content
      let report = `# ${title}\n\n`;
      report += `Generated: ${new Date().toISOString()}\n\n`;
      
      // Repository summary
      report += `## Repository Summary\n\n`;
      report += `Total Commits: ${summary.totalCommits}\n`;
      report += `Total Contributors: ${summary.totalAuthors}\n`;
      report += `Most Active Contributor: ${summary.mostActiveAuthor}\n`;
      report += `Most Common Commit Type: ${summary.mostCommonCommitType}\n\n`;
      
      // Contribution analysis
      report += `## Contribution Analysis\n\n`;
      report += `### Commits by Author\n\n`;
      
      Object.entries(authors)
        .sort(([, a], [, b]) => b - a)
        .forEach(([author, count]) => {
          report += `${author}: ${count}\n`;
        });
      
      report += `\n### Commits by Type\n\n`;
      
      Object.entries(types)
        .sort(([, a], [, b]) => b - a)
        .forEach(([type, count]) => {
          report += `${type}: ${count}\n`;
        });
      
      // Time analysis
      report += `\n## Time Analysis\n\n`;
      report += `### Commits by Day of Week\n\n`;
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      dayNames.forEach((day, index) => {
        report += `${day}: ${days[index] || 0}\n`;
      });
      
      // Quality metrics
      report += `\n## Quality Metrics\n\n`;
      report += `Average Message Length: ${quality.averageLength.toFixed(1)} characters\n`;
      report += `Conventional Commit Format: ${quality.conventionalCommitPercentage.toFixed(1)}%\n`;
      report += `Commits with Description: ${quality.withDescriptionPercentage.toFixed(1)}%\n`;
      report += `Commits with Scope: ${quality.withScopePercentage.toFixed(1)}%\n\n`;
      
      // Mood analysis
      if (Object.keys(moods).length > 0) {
        report += `## Mood Analysis\n\n`;
        
        Object.entries(moods)
          .sort(([, a], [, b]) => b - a)
          .forEach(([mood, count]) => {
            report += `${mood}: ${count}\n`;
          });
      }
      
      // Write report to file
      await fs.mkdir(path.dirname(outputPath), { recursive: true });
      await fs.writeFile(outputPath, report, 'utf-8');
      
      return outputPath;
    } catch (error) {
      console.error('Error generating report:', error);
      throw new Error(`Failed to generate report: ${error}`);
    }
  }
  
  /**
   * Generate a JSON report
   * @param outputPath Path to save the report
   */
  async generateJsonReport(outputPath: string): Promise<string> {
    try {
      // Get analytics data
      const [
        authors,
        types,
        days,
        hours,
        moods,
        quality,
        summary,
        velocity
      ] = await Promise.all([
        this.analyticsService.getCommitCountByAuthor(),
        this.analyticsService.getCommitCountByType(),
        this.analyticsService.getCommitCountByDayOfWeek(),
        this.analyticsService.getCommitCountByHourOfDay(),
        this.analyticsService.getMoodDistribution(),
        this.analyticsService.getCommitMessageQualityMetrics(),
        this.analyticsService.getRepositoryContributionSummary(),
        this.analyticsService.getCommitVelocityOverTime('day')
      ]);
      
      // Prepare report data
      const reportData = {
        generated: new Date().toISOString(),
        summary,
        authors,
        types,
        days,
        hours,
        moods,
        quality,
        velocity
      };
      
      // Write report to file
      await fs.mkdir(path.dirname(outputPath), { recursive: true });
      await fs.writeFile(outputPath, JSON.stringify(reportData, null, 2), 'utf-8');
      
      return outputPath;
    } catch (error) {
      console.error('Error generating JSON report:', error);
      throw new Error(`Failed to generate JSON report: ${error}`);
    }
  }
  
  /**
   * Generate an HTML report
   * @param outputPath Path to save the report
   * @param title Report title
   */
  async generateHtmlReport(outputPath: string, title: string = 'Commit Analytics Report'): Promise<string> {
    try {
      // Get analytics data
      const [
        authors,
        types,
        days,
        hours,
        moods,
        quality,
        summary
      ] = await Promise.all([
        this.analyticsService.getCommitCountByAuthor(),
        this.analyticsService.getCommitCountByType(),
        this.analyticsService.getCommitCountByDayOfWeek(),
        this.analyticsService.getCommitCountByHourOfDay(),
        this.analyticsService.getMoodDistribution(),
        this.analyticsService.getCommitMessageQualityMetrics(),
        this.analyticsService.getRepositoryContributionSummary()
      ]);
      
      // Generate HTML content
      let html = `<!DOCTYPE html>
<html>
<head>
  <title>${title}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
    h1, h2, h3 { color: #333; }
    .container { max-width: 1200px; margin: 0 auto; }
    .section { margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
    .chart { height: 300px; margin-top: 20px; }
    .metric { font-size: 18px; margin: 10px 0; }
    .metric-value { font-weight: bold; }
    .footer { text-align: center; margin-top: 30px; color: #777; }
  </style>
</head>
<body>
  <div class="container">
    <h1>${title}</h1>
    <p>Generated: ${new Date().toLocaleString()}</p>
    
    <div class="section">
      <h2>Repository Summary</h2>
      <div class="metric">Total Commits: <span class="metric-value">${summary.totalCommits}</span></div>
      <div class="metric">Total Contributors: <span class="metric-value">${summary.totalAuthors}</span></div>
      <div class="metric">Most Active Contributor: <span class="metric-value">${summary.mostActiveAuthor}</span></div>
      <div class="metric">Most Common Commit Type: <span class="metric-value">${summary.mostCommonCommitType}</span></div>
    </div>
    
    <div class="section">
      <h2>Contribution Analysis</h2>
      <h3>Commits by Author</h3>
      <ul>
        ${Object.entries(authors)
          .sort(([, a], [, b]) => b - a)
          .map(([author, count]) => `<li>${author}: ${count}</li>`)
          .join('')}
      </ul>
      
      <h3>Commits by Type</h3>
      <ul>
        ${Object.entries(types)
          .sort(([, a], [, b]) => b - a)
          .map(([type, count]) => `<li>${type}: ${count}</li>`)
          .join('')}
      </ul>
    </div>
    
    <div class="section">
      <h2>Time Analysis</h2>
      <h3>Commits by Day of Week</h3>
      <ul>
        ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
          .map((day, index) => `<li>${day}: ${days[index] || 0}</li>`)
          .join('')}
      </ul>
    </div>
    
    <div class="section">
      <h2>Quality Metrics</h2>
      <div class="metric">Average Message Length: <span class="metric-value">${quality.averageLength.toFixed(1)} characters</span></div>
      <div class="metric">Conventional Commit Format: <span class="metric-value">${quality.conventionalCommitPercentage.toFixed(1)}%</span></div>
      <div class="metric">Commits with Description: <span class="metric-value">${quality.withDescriptionPercentage.toFixed(1)}%</span></div>
      <div class="metric">Commits with Scope: <span class="metric-value">${quality.withScopePercentage.toFixed(1)}%</span></div>
    </div>
    
    ${Object.keys(moods).length > 0 ? `
    <div class="section">
      <h2>Mood Analysis</h2>
      <ul>
        ${Object.entries(moods)
          .sort(([, a], [, b]) => b - a)
          .map(([mood, count]) => `<li>${mood}: ${count}</li>`)
          .join('')}
      </ul>
    </div>
    ` : ''}
    
    <div class="footer">
      Generated by Zen Commit Analytics
    </div>
  </div>
</body>
</html>`;
      
      // Write report to file
      await fs.mkdir(path.dirname(outputPath), { recursive: true });
      await fs.writeFile(outputPath, html, 'utf-8');
      
      return outputPath;
    } catch (error) {
      console.error('Error generating HTML report:', error);
      throw new Error(`Failed to generate HTML report: ${error}`);
    }
  }
}
```

### 8. Create Factory for Analytics Components
```typescript
// src/factories/analyticsFactory.ts
import { AnalyticsService } from '../services/analyticsService';
import { ReportGenerator } from '../services/reportGenerator';
import { CommitHistoryManager } from '../services/historyManager';
import { GitOperationsService } from '../services/gitOperations';

/**
 * Creates an analytics service
 */
export function createAnalyticsService(
  historyManager: CommitHistoryManager,
  gitOps: GitOperationsService
): AnalyticsService {
  return new AnalyticsService(historyManager, gitOps);
}

/**
 * Creates a report generator
 */
export function createReportGenerator(
  analyticsService: AnalyticsService
): ReportGenerator {
  return new ReportGenerator(analyticsService);
}

/**
 * Creates all analytics components
 */
export function createAnalyticsComponents(
  historyManager: CommitHistoryManager,
  gitOps: GitOperationsService
): {
  analyticsService: AnalyticsService;
  reportGenerator: ReportGenerator;
} {
  const analyticsService = createAnalyticsService(historyManager, gitOps);
  const reportGenerator = createReportGenerator(analyticsService);
  
  return {
    analyticsService,
    reportGenerator
  };
}
```

### 9. Implement Analytics Command
```typescript
// src/commands/analytics.ts
import React from 'react';
import { render } from 'ink';
import { AnalyticsDashboard } from '../components/analyticsDashboard';
import { createAnalyticsComponents } from '../factories/analyticsFactory';
import { createHistoryManager } from '../factories/historyFactory';
import { createGitOperationsService } from '../factories/gitFactory';
import { CommandModule } from 'yargs';

/**
 * Command for showing analytics dashboard
 */
export const createAnalyticsCommand = (): CommandModule => {
  return {
    command: 'analytics',
    describe: 'Show commit analytics dashboard',
    builder: {
      tab: {
        alias: 't',
        choices: ['overview', 'contribution', 'time', 'quality', 'mood'],
        default: 'overview',
        description: 'Initial dashboard tab to display'
      },
      report: {
        alias: 'r',
        type: 'string',
        description: 'Generate a report to the specified file path'
      },
      format: {
        alias: 'f',
        choices: ['text', 'json', 'html'],
        default: 'text',
        description: 'Report format'
      }
    },
    handler: async (argv) => {
      try {
        // Create services
        const historyManager = createHistoryManager();
        const gitOps = createGitOperationsService();
        
        const { analyticsService, reportGenerator } = createAnalyticsComponents(
          historyManager,
          gitOps
        );
        
        // Generate report if requested
        if (argv.report) {
          const format = argv.format as string;
          const outputPath = argv.report as string;
          
          console.log(`Generating ${format} report to ${outputPath}...`);
          
          if (format === 'json') {
            await reportGenerator.generateJsonReport(outputPath);
          } else if (format === 'html') {
            await reportGenerator.generateHtmlReport(outputPath);
          } else {
            await reportGenerator.generateTextReport(outputPath);
          }
          
          console.log(`Report generated successfully: ${outputPath}`);
          return;
        }
        
        // Render analytics dashboard
        render(
          <AnalyticsDashboard
            analyticsService={analyticsService}
            initialTab={argv.tab as any}
          />
        );
      } catch (error) {
        console.error('Error displaying analytics dashboard:', error);
        process.exit(1);
      }
    }
  };
};
```

### 10. Update Main Export Files
```typescript
// src/services/index.ts
export * from './analyticsService';
export * from './reportGenerator';
// ... other exports
```

```typescript
// src/components/index.ts
export * from './analyticsChart';
export * from './analyticsDashboard';
// ... other exports
```

```typescript
// src/factories/index.ts
export * from './analyticsFactory';
// ... other exports
```

```typescript
// src/commands/index.ts
export * from './analytics';
// ... other exports
```

### 11. Update CLI to Include Analytics Command
```typescript
// src/cli.ts
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { createCommitCommand } from './commands/commit';
import { createAnalyticsCommand } from './commands/analytics';
import { initializeApp } from './app';

/**
 * Main CLI entry point
 */
async function main(): Promise<void> {
  // Initialize app
  await initializeApp();
  
  // Configure CLI
  const cli = yargs(hideBin(process.argv))
    .scriptName('zen-commit')
    .usage('$0 <command> [options]')
    .option('verbose', {
      alias: 'v',
      type: 'boolean',
      description: 'Run with verbose logging'
    });
  
  // Register commands
  cli.command(createCommitCommand());
  cli.command(createAnalyticsCommand());
  
  // Add help and version
  cli.help().alias('help', 'h');
  cli.version().alias('version', 'V');
  
  // Parse arguments
  await cli.parse();
}

// Run CLI
main().catch(error => {
  console.error('Error:', error);
  process.exit(1);
});
```

## Definition of Done
- Analytics dashboard displays commit history metrics and patterns
- Dashboard includes multiple tabs for different metric categories
- Charts provide clear visualizations of the metrics
- Dashboard supports filtering by date range
- Report generation is available in multiple formats
- All test cases pass and achieve adequate coverage

## Potential Blockers
- Complex analytics may be slow for large repositories
- Terminal-based chart visualization has limitations
- Meaningful metrics require sufficient commit history data
- Integration with different Git hosting providers may vary

## Next Steps
- User Preferences Interface (5.1.2)
- Team Integration Features (5.1.3)